/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.20
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

/***********************************************************************
 * common.swg
 *
 *     This file contains generic SWIG runtime support for pointer
 *     type checking as well as a few commonly used macros to control
 *     external linkage.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 *
 * Copyright (c) 1999-2000, The University of Chicago
 * 
 * This file may be freely redistributed without license or fee provided
 * this copyright message remains intact.
 ************************************************************************/

#include <string.h>

#if defined(_WIN32) || defined(__WIN32__)
#       if defined(_MSC_VER)
#               if defined(STATIC_LINKED)
#                       define SWIGEXPORT(a) a
#                       define SWIGIMPORT(a) extern a
#               else
#                       define SWIGEXPORT(a) __declspec(dllexport) a
#                       define SWIGIMPORT(a) extern a
#               endif
#       else
#               if defined(__BORLANDC__)
#                       define SWIGEXPORT(a) a _export
#                       define SWIGIMPORT(a) a _export
#               else
#                       define SWIGEXPORT(a) a
#                       define SWIGIMPORT(a) a
#               endif
#       endif
#else
#       define SWIGEXPORT(a) a
#       define SWIGIMPORT(a) a
#endif

#ifdef SWIG_GLOBAL
#define SWIGRUNTIME(a) SWIGEXPORT(a)
#else
#define SWIGRUNTIME(a) static a
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

typedef struct swig_type_info {
  const char             *name;                 
  swig_converter_func     converter;
  const char             *str;
  void                   *clientdata;	
  swig_dycast_func        dcast;
  struct swig_type_info  *next;
  struct swig_type_info  *prev;
} swig_type_info;

#ifdef SWIG_NOINCLUDE

SWIGIMPORT(swig_type_info *) SWIG_TypeRegister(swig_type_info *);
SWIGIMPORT(swig_type_info *) SWIG_TypeCheck(char *c, swig_type_info *);
SWIGIMPORT(void *)           SWIG_TypeCast(swig_type_info *, void *);
SWIGIMPORT(swig_type_info *) SWIG_TypeDynamicCast(swig_type_info *, void **);
SWIGIMPORT(const char *)     SWIG_TypeName(const swig_type_info *);
SWIGIMPORT(swig_type_info *) SWIG_TypeQuery(const char *);
SWIGIMPORT(void)             SWIG_TypeClientData(swig_type_info *, void *);

#else

static swig_type_info *swig_type_list = 0;

/* Register a type mapping with the type-checking */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeRegister(swig_type_info *ti)
{
  swig_type_info *tc, *head, *ret, *next;
  /* Check to see if this type has already been registered */
  tc = swig_type_list;
  while (tc) {
    if (strcmp(tc->name, ti->name) == 0) {
      /* Already exists in the table.  Just add additional types to the list */
      if (tc->clientdata) ti->clientdata = tc->clientdata;	
      head = tc;
      next = tc->next;
      goto l1;
    }
    tc = tc->prev;
  }
  head = ti;
  next = 0;

  /* Place in list */
  ti->prev = swig_type_list;
  swig_type_list = ti;

  /* Build linked lists */
 l1:
  ret = head;
  tc = ti + 1;
  /* Patch up the rest of the links */
  while (tc->name) {
    head->next = tc;
    tc->prev = head;
    head = tc;
    tc++;
  }
  if (next) next->prev = head;  /**/
  head->next = next;
  return ret;
}

/* Check the typename */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeCheck(char *c, swig_type_info *ty)
{
  swig_type_info *s;
  if (!ty) return 0;        /* Void pointer */
  s = ty->next;             /* First element always just a name */
  do {
    if (strcmp(s->name,c) == 0) {
      if (s == ty->next) return s;
      /* Move s to the top of the linked list */
      s->prev->next = s->next;
      if (s->next) {
	s->next->prev = s->prev;
      }
      /* Insert s as second element in the list */
      s->next = ty->next;
      if (ty->next) ty->next->prev = s;
      ty->next = s;
      s->prev = ty;  /**/
      return s;
    }
    s = s->next;
  } while (s && (s != ty->next));
  return 0;
}

/* Cast a pointer up an inheritance hierarchy */
SWIGRUNTIME(void *) 
SWIG_TypeCast(swig_type_info *ty, void *ptr) 
{
  if ((!ty) || (!ty->converter)) return ptr;
  return (*ty->converter)(ptr);
}

/* Dynamic pointer casting. Down an inheritance hierarchy */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) 
{
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
     ty = (*ty->dcast)(ptr);
     if (ty) lastty = ty;
  }
  return lastty;
}

/* Return the name associated with this type */
SWIGRUNTIME(const char *)
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/* Search for a swig_type_info structure */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeQuery(const char *name) {
  swig_type_info *ty = swig_type_list;
  while (ty) {
    if (ty->str && (strcmp(name,ty->str) == 0)) return ty;
    if (ty->name && (strcmp(name,ty->name) == 0)) return ty;
    ty = ty->prev;
  }
  return 0;
}

/* Set the clientdata field for a type */
SWIGRUNTIME(void)
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_type_info *tc, *equiv;
  if (ti->clientdata == clientdata) return;
  ti->clientdata = clientdata;
  equiv = ti->next;
  while (equiv) {
    if (!equiv->converter) {
      tc = swig_type_list;
      while (tc) {
	if ((strcmp(tc->name, equiv->name) == 0))
	  SWIG_TypeClientData(tc,clientdata);
	tc = tc->prev;
      }
    }
    equiv = equiv->next;
  }
}
#endif

#ifdef __cplusplus
}

#endif

/* -----------------------------------------------------------------------------
 * perl5.swg
 *
 * Perl5 runtime library
 * $Header: /cvsroot/SWIG/Lib/perl5/perlrun.swg,v 1.5 2003/09/23 21:17:46 cheetah Exp $
 * ----------------------------------------------------------------------------- */

#define SWIGPERL
#define SWIGPERL5
#ifdef __cplusplus
/* Needed on some windows machines---since MS plays funny
   games with the header files under C++ */
#include <math.h>
#include <stdlib.h>
extern "C" {
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

/* Get rid of free and malloc defined by perl */
#undef free
#undef malloc

#ifndef pTHX_
#define pTHX_
#endif

#include <string.h>
#ifdef __cplusplus
}
#endif

/* Macro to call an XS function */

#ifdef PERL_OBJECT 
#define SWIG_CALLXS(_name) _name(cv,pPerl) 
#else 
#ifndef MULTIPLICITY 
#define SWIG_CALLXS(_name) _name(cv) 
#else 
#define SWIG_CALLXS(_name) _name(PERL_GET_THX, cv) 
#endif 
#endif 

/* Macros for low-level exception handling */
#define SWIG_fail      goto fail
#define SWIG_croak(x)  { if ((_swigerr = (const char *) x)) goto fail; }
#define SWIG_MAX_ERRMSG 256

/* Note: SwigMagicFuncHack is a typedef used to get the C++
   compiler to just shut up already */

#ifdef PERL_OBJECT
#define MAGIC_PPERL  CPerlObj *pPerl = (CPerlObj *) this;
typedef int (CPerlObj::*SwigMagicFunc)(SV *, MAGIC *);

#ifdef __cplusplus
extern "C" {
#endif
typedef int (CPerlObj::*SwigMagicFuncHack)(SV *, MAGIC *);
#ifdef __cplusplus
}
#endif

#define SWIG_MAGIC(a,b) (SV *a, MAGIC *b)
#define SWIGCLASS_STATIC
#else
#define MAGIC_PPERL
#define SWIGCLASS_STATIC static
#ifndef MULTIPLICITY
#define SWIG_MAGIC(a,b) (SV *a, MAGIC *b)
typedef int (*SwigMagicFunc)(SV *, MAGIC *);

#ifdef __cplusplus
extern "C" {
#endif
typedef int (*SwigMagicFuncHack)(SV *, MAGIC *);
#ifdef __cplusplus
}
#endif


#else
#define SWIG_MAGIC(a,b) (struct interpreter *interp, SV *a, MAGIC *b)
typedef int (*SwigMagicFunc)(struct interpreter *, SV *, MAGIC *);
#ifdef __cplusplus
extern "C" {
#endif
typedef int (*SwigMagicFuncHack)(struct interpreter *, SV *, MAGIC *);
#ifdef __cplusplus
}
#endif

#endif
#endif

#if defined(WIN32) && defined(PERL_OBJECT) && !defined(PerlIO_exportFILE)
#define PerlIO_exportFILE(fh,fl) (FILE*)(fh)
#endif

/* Modifications for newer Perl 5.005 releases */

#if !defined(PERL_REVISION) || ((PERL_REVISION >= 5) && ((PERL_VERSION < 5) || ((PERL_VERSION == 5) && (PERL_SUBVERSION < 50))))
#ifndef PL_sv_yes
#define PL_sv_yes sv_yes
#endif
#ifndef PL_sv_undef
#define PL_sv_undef sv_undef
#endif
#ifndef PL_na
#define PL_na na
#endif
#endif

#include <stdlib.h>

#ifdef __cplusplus
extern "C" {
#endif

#define SWIG_OWNER 1
#define SWIG_SHADOW 2

#ifdef SWIG_NOINCLUDE

#ifndef PERL_OBJECT
extern int SWIG_ConvertPtr(SV *, void **, swig_type_info *, int flags);
extern void SWIG_MakePtr(SV *, void *, swig_type_info *, int flags);
swig_type_info *SWIG_TypeCheckRV(SV *rv, swig_type_info *ty);
#else
extern int SWIG_ConvertPtr_(CPerlObj *, SV *, void **, swig_type_info *,int flags);
extern void SWIG_MakePtr_(CPerlObj *, SV *, void *, swig_type_info *, int flags);
swig_type_info * SWIG_TypeCheckRV_(CPerlObj *pPerl, SV *rv, swig_type_info *ty);
#define SWIG_ConvertPtr(a,b,c,d) SWIG_ConvertPtr_(pPerl,a,b,c,d)
#define SWIG_MakePtr(a,b,c,d) SWIG_MakePtr_(pPerl,a,b,c,d)
#define SWIG_TypeCheckRV(a,b,c) SWIG_TypeCheckRV_(pPerl,a,b,c)
#endif

#else

/* Function for getting a pointer value */

#ifndef PERL_OBJECT
SWIGRUNTIME(swig_type_info *)
SWIG_TypeCheckRV(SV *rv, swig_type_info *ty)
#else
#define SWIG_TypeCheckRV(a,b,c) SWIG_TypeCheckRV_(pPerl,a,b,c)
SWIGRUNTIME(swig_type_info *)
SWIG_TypeCheckRV_(CPerlObj *pPerl, SV *rv, swig_type_info *ty)
#endif
{
  swig_type_info *s;
  if (!ty) return 0;        /* Void pointer */
  s = ty->next;             /* First element always just a name */
  do {
    if (sv_derived_from(rv, s->name)) {
      if (s == ty->next) return s;
      /* Move s to the top of the linked list */
      s->prev->next = s->next;
      if (s->next) {
	s->next->prev = s->prev;
      }
      /* Insert s as second element in the list */
      s->next = ty->next;
      if (ty->next) ty->next->prev = s;
      ty->next = s;
      s->prev = ty;  /**/
      return s;
    }
    s = s->next;
  } while (s && (s != ty->next));
  return 0;  
}

#ifndef PERL_OBJECT
SWIGRUNTIME(int) 
SWIG_ConvertPtr(SV *sv, void **ptr, swig_type_info *_t, int flags)
#else
#define SWIG_ConvertPtr(a,b,c,d) SWIG_ConvertPtr_(pPerl,a,b,c,d)
SWIGRUNTIME(int)
SWIG_ConvertPtr_(CPerlObj *pPerl, SV *sv, void **ptr, swig_type_info *_t, int flags)
#endif
{
  /* char *_c; */
  swig_type_info *tc;
  void *voidptr = (void *)0;

  /* If magical, apply more magic */
  if (SvGMAGICAL(sv))
    mg_get(sv);

  /* Check to see if this is an object */
  if (sv_isobject(sv)) {
    SV *tsv = (SV*) SvRV(sv);
    IV tmp = 0;
    if ((SvTYPE(tsv) == SVt_PVHV)) {
      MAGIC *mg;
      if (SvMAGICAL(tsv)) {
        mg = mg_find(tsv,'P');
        if (mg) {
          SV *rsv = mg->mg_obj;
          if (sv_isobject(rsv)) {
            tmp = SvIV((SV*)SvRV(rsv));
          }
        }
      } else {
        return -1;
      }
    } else {
      tmp = SvIV((SV*)SvRV(sv));
    }
    voidptr = (void *)tmp;
    if (!_t) {
      *(ptr) = voidptr;
      return 0;
    }
  } else if (! SvOK(sv)) {            /* Check for undef */
    *(ptr) = (void *) 0;
    return 0;
  } else if (SvTYPE(sv) == SVt_RV) {  /* Check for NULL pointer */
    *(ptr) = (void *) 0;
    if (!SvROK(sv)) 
      return 0;
    else
      return -1;
  } else {                            /* Don't know what it is */
      *(ptr) = (void *) 0;
      return -1;
  }
  if (_t) {
    /* Now see if the types match */      
    /* _c = HvNAME(SvSTASH(SvRV(sv))); */
    /* tc = SWIG_TypeCheck(_c,_t); */
    tc = SWIG_TypeCheckRV(sv, _t);
    if (!tc) {
      *ptr = voidptr;
      return -1;
    }
    *ptr = SWIG_TypeCast(tc,voidptr);
    return 0;
  }
  *ptr = voidptr;
  return 0;
}

#ifndef PERL_OBJECT
SWIGRUNTIME(void) 
SWIG_MakePtr(SV *sv, void *ptr, swig_type_info *t,int flags)
#else
#define SWIG_MakePtr(a,b,c,d) SWIG_MakePtr_(pPerl,a,b,c,d)
SWIGRUNTIME(void)
SWIG_MakePtr_(CPerlObj *pPerl, SV *sv, void *ptr, swig_type_info *t, int flags)
#endif
{
  if (ptr && (flags & SWIG_SHADOW)) {
    SV *self;
    SV *obj=newSV(0);
    HV *hash=newHV();
    HV *stash;
    sv_setref_pv(obj, (char *) t->name, ptr);
    stash=SvSTASH(SvRV(obj));
    if (flags & SWIG_OWNER) {
      HV *hv;
      GV *gv=*(GV**)hv_fetch(stash, "OWNER", 5, TRUE);
      if (!isGV(gv))
        gv_init(gv, stash, "OWNER", 5, FALSE);
      hv=GvHVn(gv);
      hv_store_ent(hv, obj, newSViv(1), 0);
    }
    sv_magic((SV *)hash, (SV *)obj, PERL_MAGIC_tied, Nullch, 0);
    SvREFCNT_dec(obj);
    self=newRV_noinc((SV *)hash);
    sv_setsv(sv, self);
    SvREFCNT_dec((SV *)self);
    sv_bless(sv, stash);
  }
  else {
    sv_setref_pv(sv, (char *) t->name, ptr);
  }
}

#endif

typedef XS(SwigPerlWrapper);
typedef SwigPerlWrapper *SwigPerlWrapperPtr;

/* Structure for command table */
typedef struct {
  const char         *name;
  SwigPerlWrapperPtr  wrapper;
} swig_command_info;

/* Information for constant table */

#define SWIG_INT     1
#define SWIG_FLOAT   2
#define SWIG_STRING  3
#define SWIG_POINTER 4
#define SWIG_BINARY  5

/* Constant information structure */
typedef struct swig_constant_info {
    int              type;
    const char      *name;
    long             lvalue;
    double           dvalue;
    void            *pvalue;
    swig_type_info **ptype;
} swig_constant_info;

#ifdef __cplusplus
}
#endif

/* Structure for variable table */
typedef struct {
  const char   *name;
  SwigMagicFunc   set;
  SwigMagicFunc   get;
  swig_type_info  **type;
} swig_variable_info;

/* Magic variable code */
#ifndef PERL_OBJECT
#define swig_create_magic(s,a,b,c) _swig_create_magic(s,a,b,c)
  #ifndef MULTIPLICITY 
       static void _swig_create_magic(SV *sv, char *name, int (*set)(SV *, MAGIC *), int \
(*get)(SV *,MAGIC *)) { 
  #else 
       static void _swig_create_magic(SV *sv, char *name, int (*set)(struct interpreter*,\
 SV *, MAGIC *), int (*get)(struct interpreter*, SV *,MAGIC *)) { 
  #endif 
#else
#define swig_create_magic(s,a,b,c) _swig_create_magic(pPerl,s,a,b,c)
static void _swig_create_magic(CPerlObj *pPerl, SV *sv, const char *name, int (CPerlObj::*set)(SV *, MAGIC *), int (CPerlObj::*get)(SV *, MAGIC *)) {
#endif
  MAGIC *mg;
  sv_magic(sv,sv,'U',(char *) name,strlen(name));
  mg = mg_find(sv,'U');
  mg->mg_virtual = (MGVTBL *) malloc(sizeof(MGVTBL));
  mg->mg_virtual->svt_get = (SwigMagicFuncHack) get;
  mg->mg_virtual->svt_set = (SwigMagicFuncHack) set;
  mg->mg_virtual->svt_len = 0;
  mg->mg_virtual->svt_clear = 0;
  mg->mg_virtual->svt_free = 0;
}






#ifdef do_open
  #undef do_open
#endif
#ifdef do_close
  #undef do_close
#endif
#ifdef scalar
  #undef scalar
#endif
#ifdef list
  #undef list
#endif
#ifdef apply
  #undef apply
#endif
#ifdef convert
  #undef convert
#endif
#ifdef Error
  #undef Error
#endif
#ifdef form
  #undef form
#endif
#ifdef vform
  #undef vform
#endif
#ifdef LABEL
  #undef LABEL
#endif
#ifdef METHOD
  #undef METHOD
#endif
#ifdef Move
  #undef Move
#endif
#ifdef yylex
  #undef yylex
#endif
#ifdef yyparse
  #undef yyparse
#endif
#ifdef yyerror
  #undef yyerror
#endif
#ifdef invert
  #undef invert
#endif
#ifdef ref
  #undef ref
#endif
#ifdef ENTER
  #undef ENTER
#endif


/* -------- TYPES TABLE (BEGIN) -------- */

#define  SWIGTYPE_p_ber_slen_t swig_types[0] 
#define  SWIGTYPE_p_ldap swig_types[1] 
#define  SWIGTYPE_p_LDAPDN_rewrite_func swig_types[2] 
#define  SWIGTYPE_p_ldap_url_desc swig_types[3] 
#define  SWIGTYPE_p_Sockbuf swig_types[4] 
#define  SWIGTYPE_p_p_LDAPMessage swig_types[5] 
#define  SWIGTYPE_p_LDAPMessage swig_types[6] 
#define  SWIGTYPE_p_LDAP_SASL_INTERACT_PROC swig_types[7] 
#define  SWIGTYPE_p_LDAPVLVInfo swig_types[8] 
#define  SWIGTYPE_STRING swig_types[9] 
#define  SWIGTYPE_p_p_STRING swig_types[10] 
#define  SWIGTYPE_p_p_char swig_types[11] 
#define  SWIGTYPE_p_LDAP_REBIND_PROC swig_types[12] 
#define  SWIGTYPE_p_p_p_char swig_types[13] 
#define  SWIGTYPE_p_LDAPRDN swig_types[14] 
#define  SWIGTYPE_p_p_LDAPRDN swig_types[15] 
#define  SWIGTYPE_p_LDAPSortKey swig_types[16] 
#define  SWIGTYPE_p_p_p_LDAPSortKey swig_types[17] 
#define  SWIGTYPE_p_p_LDAPSortKey swig_types[18] 
#define  SWIGTYPE_p_Seqorset swig_types[19] 
#define  SWIGTYPE_p_void swig_types[20] 
#define  SWIGTYPE_p_p_void swig_types[21] 
#define  SWIGTYPE_p_p_p_LDAPControl swig_types[22] 
#define  SWIGTYPE_p_LDAPControl swig_types[23] 
#define  SWIGTYPE_p_p_LDAPControl swig_types[24] 
#define  SWIGTYPE_p_Sockbuf_IO swig_types[25] 
#define  SWIGTYPE_p_LDAPMod_mod_vals swig_types[26] 
#define  SWIGTYPE_p_ber_tag_t swig_types[27] 
#define  SWIGTYPE_p_BerVarray swig_types[28] 
#define  SWIGTYPE_p_ber_int_t swig_types[29] 
#define  SWIGTYPE_p_LDAPURLDesc swig_types[30] 
#define  SWIGTYPE_p_p_LDAPURLDesc swig_types[31] 
#define  SWIGTYPE_p_ber_len_t swig_types[32] 
#define  SWIGTYPE_p_ldapmsg swig_types[33] 
#define  SWIGTYPE_p_p_berval swig_types[34] 
#define  SWIGTYPE_p_berval swig_types[35] 
#define  SWIGTYPE_p_LDAPMod swig_types[36] 
#define  SWIGTYPE_p_p_LDAPMod swig_types[37] 
#define  SWIGTYPE_BerValue swig_types[38] 
#define  SWIGTYPE_p_BerValue swig_types[39] 
#define  SWIGTYPE_p_p_BerValue swig_types[40] 
#define  SWIGTYPE_p_SV swig_types[41] 
#define  SWIGTYPE_p_timeval swig_types[42] 
#define  SWIGTYPE_p_LDAPAPIFeatureInfo swig_types[43] 
#define  SWIGTYPE_p_LDAPDN swig_types[44] 
#define  SWIGTYPE_p_p_LDAPDN swig_types[45] 
#define  SWIGTYPE_p_BerElement swig_types[46] 
#define  SWIGTYPE_p_p_BerElement swig_types[47] 
#define  SWIGTYPE_p_int swig_types[48] 
#define  SWIGTYPE_p_LDAPAVA swig_types[49] 
#define  SWIGTYPE_p_LDAP swig_types[50] 
#define  SWIGTYPE_p_p_LDAP swig_types[51] 
#define  SWIGTYPE_p_LDAP_SORT_AD_CMP_PROC swig_types[52] 
#define  SWIGTYPE_p_LDAP_SORT_AV_CMP_PROC swig_types[53] 
#define  SWIGTYPE_p_unsigned_long swig_types[54] 
#define  SWIGTYPE_p_LDAPAPIInfo swig_types[55] 
static swig_type_info *swig_types[57];

/* -------- TYPES TABLE (END) -------- */

#define SWIG_init    boot_OnLDAP__Base

#define SWIG_name   "OnLDAP::Basec::boot_OnLDAP__Base"
#define SWIG_prefix "OnLDAP::Basec::"

#ifdef __cplusplus
extern "C"
#endif
#ifndef PERL_OBJECT
#ifndef MULTIPLICITY
SWIGEXPORT(void) SWIG_init (CV* cv);
#else
SWIGEXPORT(void) SWIG_init (pTHXo_ CV* cv);
#endif
#else
SWIGEXPORT(void) SWIG_init (CV *cv, CPerlObj *);
#endif


#include <string.h>

#include <lber.h>
#include <ldap.h>


typedef char ** PUSHPPchar;
typedef char * STRING;


static char **PERLARRAY2PPchar(SV *input, char **croak) {
    char **p;
    *croak=NULL;
    if(SvOK(input)) {
	if (SvROK(input)) {
	    AV *av=(AV *)SvRV(input);
	    if (SvTYPE((SV *)av)==SVt_PVAV) {
		int len=av_len(av)+1;
		if(p=calloc(len+1, sizeof(char *))) {
		    int i;
		    for(i=0; i<len; i++) {
			SV **sv=av_fetch(av, i, 0);
			if (!sv) {
			    *croak="Sparse array detected";
			    free(p);
			    return NULL;
			}
			p[i]=SvPV_nolen(*sv);
		    }
		    return p; 
		}
		else *croak="Out of memory";
	    }
	}
	else *croak="Invalid type, ARRAY ref expected";
    }
    return NULL;
}


static void PERLARRAY2PPANY(SV *input, void **output, char **croak,
			    swig_type_info *type) {
    void **p;
    *croak=NULL;
    if(SvOK(input)) {
	if(SvROK(input)) {
	    AV *av=(AV *)SvRV(input);
	    if (SvTYPE((SV *)av)==SVt_PVAV) {
		int len=av_len(av)+1;
		if(p=calloc(len+1, sizeof(void *))) {
		    int i;
		    for(i=0; i<len; i++) {
			SV **sv=av_fetch(av, i, 0);
			if (!sv) {
			    *croak="Sparse array detected";
			    free(p);
			    *output=NULL;
			    return;
			}
			if (SWIG_ConvertPtr(*sv, p+i, type, 0) < 0) {
			    *croak="Array element of invalid type";
			    free(p);
			    *output=NULL;
			    return;
			}
		    }
		    *output=p;
		    return;
		}
		else *croak="Out of memory";
	    }
	}
	else *croak="Invalid type, ARRAY ref expected";
    }
    *output=NULL;
}


static SV *PPANY2PERLARRAY(void **pe1,
			   void (*conversor)(SV *, void *,
					    swig_type_info *, int),
			   swig_type_info *type, int flags,
			   void *freeder) {
    if (pe1) {
	AV *av=newAV();
	SV *output=sv_2mortal(newRV_noinc((SV *)av));
	void **pe;
	for (pe=pe1; *pe; pe++) {
	    SV *sv=newSV(0);
	    (*conversor)(sv, *pe, type, flags);
	    av_push(av, sv);
	}
	if (freeder) { (*((void (*)(void *))freeder))(pe1); }
	return output;
    }
    else return &PL_sv_undef;
}
   


static void PCHAR2PERL(SV *output, void *input,
		      swig_type_info *type, int flags) {
    sv_setpv(output, (char *)input);
}



static LDAPControl *new_control(char *oid, BerValue *bv, int critical) {
    LDAPControl *c;
    if (c=malloc(sizeof(*c))) {
	c->ldctl_oid=oid ? strdup(oid) : NULL;
	if (bv) {
	    c->ldctl_value.bv_len=bv->bv_len;
	    if (bv->bv_val) {
		char *mem=(char *)malloc(bv->bv_len+1);
		memcpy(mem, bv->bv_val, bv->bv_len);
		mem[bv->bv_len]='\0';
		c->ldctl_value.bv_val=mem;
	    }
	    else c->ldctl_value.bv_val=NULL;
	}
	else {
	    c->ldctl_value.bv_val=NULL;
	    c->ldctl_value.bv_len=0;
	}
	c->ldctl_iscritical=critical;
    }
    return c;
}

static LDAPControl *dup_control(LDAPControl *s) {
    return new_control(s->ldctl_oid,
		       &(s->ldctl_value), 
		       s->ldctl_iscritical);
}

static void free_control(LDAPControl *s) {
    if (s) {
	if (s->ldctl_oid) free(s->ldctl_oid);
	if (s->ldctl_value.bv_val) free(s->ldctl_value.bv_val);
	free(s);
    }
}

static void LDAPControl2PERL_COPY(SV *output, void *input,
				 swig_type_info *type, int flags) {
    LDAPControl *copy=dup_control((LDAPControl *) input);
    return SWIG_MakePtr(output, (void *) copy,
			type, flags|SWIG_OWNER);
}



static void free_BerValueARRAY(BerValue **array, int copied) {
    if (array) {
	BerValue *bv=*array;
	if (bv) {
	    if (copied) {
		char *v=bv->bv_val;
		if (v) {
		    free(v);
		}
	    }
	    free(bv);
	}
	free(array);
    }
	
}


static BerValue **RV2BerValueARRAY(SV *rv, int copy, char **croak) {
    if (SvOK(rv)) {
	if (SvROK(rv)) {
	    AV *av=(AV *)SvRV(rv);
	    if (SvTYPE(av)==SVt_PVAV) {
		int len=av_len(av)+1;
		BerValue **array=malloc(sizeof(BerValue *)*len+1);
		BerValue *bv=malloc(sizeof(BerValue)*len);
		if (array && bv) {
		    int i;
		    int clen=0;
		    for (i=0; i<len; i++) {
			SV **sv=av_fetch(av, i, 0);
			array[i]=bv+i;
			if (sv) {
			    int l;
			    bv[i].bv_val=SvPV(*sv, l);
			    bv[i].bv_len=l;
			    clen+=l+1;
			}
			else {
			    bv[i].bv_len=0;
			    bv[i].bv_val="";
			}
		    }
		    array[len]=NULL;
		    if (copy) {
			char *v=malloc(clen+1);
			if (v) {
			    for (i=0; i<len; i++) {
				int l=bv[i].bv_len;
				memcpy(v, bv[i].bv_val, l);
				bv[i].bv_val=v;
				v+=l;
				*v='\0';
				v++;
			    }
			}
			else {
			    free_BerValueARRAY(array, 0);
			    *croak="Out of memory";
			    return NULL;
			}
		    }
		    return array;
		}
		*croak="Out of memory";
		return NULL;
	    }
	}
	*croak="Type error array of scalars representing BerValues expected";
    }
    return NULL;
}

static void BerValue2RV(SV *output, void *input,
			swig_type_info *type, int flags) {
    BerValue *bv=(BerValue *)input;
    if (bv) {
	sv_setpvn(output, bv->bv_val, bv->bv_len);
    }
    else {
	sv_setref_pv(output, NULL, NULL);
    }
}


struct ldap *new_ldap(char *host,int port){
	return ldap_init(host, port);
    }
void delete_ldap(struct ldap *self){}
int ldap__unbind(struct ldap *self,LDAPControl **serverctrls,LDAPControl **clientctrls){
	if (!self) return -1;
	return ldap_unbind_ext(self, serverctrls, clientctrls);
    }
int ldap__get_option__bool(struct ldap *self,int option,char **CROAK){
	void *v;
	if (ldap_get_option(self, option, &v)!=-1)
	    return (v==((void *) 0))?0:1;
	(*CROAK=("ldap_get_option failed"));
	return 0;
    }
int ldap__get_option__int(struct ldap *self,int option,char **CROAK){
	int v;
	if(ldap_get_option(self, option, &v)!=-1)
	    return v;
	(*CROAK=("ldap_get_option failed"));
	return 0;
    }
char *ldap__get_option__string(struct ldap *self,int option,char **CROAK){
	char *v;
	if(ldap_get_option(self, option, &v)!=-1)
	    return v;
	(*CROAK=("ldap_get_option failed"));
	return NULL;
    }
LDAPAPIInfo *ldap__get_option__APIInfo(struct ldap *self,int option,char **CROAK){
	LDAPAPIInfo *v;
	if (v=(LDAPAPIInfo *) malloc(sizeof(*v))) {
	    v->ldapai_info_version=(1);
	    if (ldap_get_option(self, option, v)!=-1)
		return v;
	    free(v);
	}
	(*CROAK=("ldap_get_option failed [APIInfo]"));
	return NULL;
    }
LDAPAPIFeatureInfo *ldap__get_option__APIFeatureInfo(struct ldap *self,int option,char *name,char **CROAK){
	LDAPAPIFeatureInfo *v;
	if (v=(LDAPAPIFeatureInfo *)malloc(sizeof(*v))) {
	    v->ldapaif_info_version=(1);
	    v->ldapaif_name=strdup(name);
	    if (ldap_get_option(self, option, v)!=-1)
		return v;
	    free(v);
	}
	(*CROAK=("ldap_get_option failed [APIFeatureInfo]"));
	return NULL;
    }
LDAPControl **ldap__get_option__Controls(struct ldap *self,int option,char **CROAK){
	LDAPControl **v;
	if (ldap_get_option(self, option, &v)!=-1) {
	    return v;
	}
	(*CROAK=("ldap_get_option failed [Controls]"));
	return NULL;
    }
void ldap__set_option__bool(struct ldap *self,int option,int value,char **CROAK){
	if (ldap_set_option(self, option,
			    value ? ((void *) 1) : ((void *) 0))==-1)
	    (*CROAK=("ldap_set_option failed"));
    }
void ldap__set_option__int(struct ldap *self,int option,int value,char **CROAK){
	int v=value;
	if (ldap_set_option(self, option, &v)==-1)
	    (*CROAK=("ldap_set_option failed"));
    }
void ldap__set_option__string(struct ldap *self,int option,char *value,char **CROAK){
	if (ldap_set_option(self, option, value)==-1)
	    (*CROAK=("ldap_set_option failed"));
    }
void ldap__set_option__Controls(struct ldap *self,int option,LDAPControl **PPANY,char **CROAK){
	if (ldap_set_option(self, option, PPANY)==-1)
	    (*CROAK=("ldap_set_option failed"));
    }
struct ldapmsg *new_ldapmsg(char **CROAK){
	(*CROAK=("ldapmsg->new access forbidden"));
    }
void delete_ldapmsg(struct ldapmsg *self){ ldap_msgfree(self); }
int ldapmsg_type(struct ldapmsg *self){ return ldap_msgtype(self); }
int ldapmsg_id(struct ldapmsg *self){ return ldap_msgid(self); }
int BerValue_lenght(BerValue *self){ return self->bv_len; }
char *BerValue_string(BerValue *self){ return self->bv_val; }
void delete_BerValue(BerValue *self){ ber_bvfree(self); }
extern void ber_error_print(char const *);
extern void ber_bprint(char const *,ber_len_t);
extern void ber_dump(BerElement *,int);
extern void ber_sos_dump(Seqorset *);
extern ber_tag_t ber_get_tag(BerElement *);
extern ber_tag_t ber_skip_tag(BerElement *,ber_len_t *);
extern ber_tag_t ber_peek_tag(BerElement *,ber_len_t *);
extern ber_tag_t ber_get_int(BerElement *,ber_int_t *);
extern ber_tag_t ber_get_enum(BerElement *,ber_int_t *);
extern ber_tag_t ber_get_stringb(BerElement *,char *,ber_len_t *);
extern ber_tag_t ber_get_stringbv(BerElement *,struct berval *,int);
extern ber_tag_t ber_get_stringa(BerElement *,char **);
extern ber_tag_t ber_get_stringal(BerElement *,struct berval **);
extern ber_tag_t ber_get_bitstringa(BerElement *,char **,ber_len_t *);
extern ber_tag_t ber_get_null(BerElement *);
extern ber_tag_t ber_get_boolean(BerElement *,ber_int_t *);
extern ber_tag_t ber_first_element(BerElement *,ber_len_t *,char **);
extern ber_tag_t ber_next_element(BerElement *,ber_len_t *,char const *);
extern ber_tag_t ber_scanf(BerElement *,char const *,...);
extern int ber_put_enum(BerElement *,ber_int_t,ber_tag_t);
extern int ber_put_int(BerElement *,ber_int_t,ber_tag_t);
extern int ber_put_ostring(BerElement *,char const *,ber_len_t,ber_tag_t);
extern int ber_put_berval(BerElement *,struct berval *,ber_tag_t);
extern int ber_put_string(BerElement *,char const *,ber_tag_t);
extern int ber_put_bitstring(BerElement *,char const *,ber_len_t,ber_tag_t);
extern int ber_put_null(BerElement *,ber_tag_t);
extern int ber_put_boolean(BerElement *,ber_int_t,ber_tag_t);
extern int ber_start_seq(BerElement *,ber_tag_t);
extern int ber_start_set(BerElement *,ber_tag_t);
extern int ber_put_seq(BerElement *);
extern int ber_put_set(BerElement *);
extern int ber_printf(BerElement *,char const *,...);
extern ber_slen_t ber_read(BerElement *,char *,ber_len_t);
extern ber_slen_t ber_write(BerElement *,char const *,ber_len_t,int);
extern void ber_free(BerElement *,int);
extern void ber_free_buf(BerElement *);
extern int ber_flush(Sockbuf *,BerElement *,int);
extern BerElement *ber_alloc(void);
extern BerElement *der_alloc(void);
extern BerElement *ber_alloc_t(int);
extern BerElement *ber_dup(BerElement *);
extern ber_tag_t ber_get_next(Sockbuf *,ber_len_t *,BerElement *);
extern void ber_init2(BerElement *,struct berval *,int);
extern void ber_init_w_nullc(BerElement *,int);
extern void ber_reset(BerElement *,int);
extern BerElement *ber_init(struct berval *);
extern int ber_flatten(BerElement *,struct berval **);
extern int ber_flatten2(BerElement *,struct berval *,int);
extern int ber_get_option(void *,int,void *);
extern int ber_set_option(void *,int,void const *);
extern Sockbuf *ber_sockbuf_alloc(void);
extern void ber_sockbuf_free(Sockbuf *);
extern int ber_sockbuf_add_io(Sockbuf *,Sockbuf_IO *,int,void *);
extern int ber_sockbuf_remove_io(Sockbuf *,Sockbuf_IO *,int);
extern int ber_sockbuf_ctrl(Sockbuf *,int,void *);
extern int ber_bvarray_add(BerVarray *,BerValue *);
extern int *ber_errno_addr(void);
int LDAPAPIInfo_info_version(LDAPAPIInfo *self){ return self->ldapai_info_version; }
int LDAPAPIInfo_api_version(LDAPAPIInfo *self){ return self->ldapai_api_version; }
int LDAPAPIInfo_protocol_version(LDAPAPIInfo *self){ return self->ldapai_protocol_version; }
PUSHPPchar LDAPAPIInfo_extensions(LDAPAPIInfo *self){ return self->ldapai_extensions; }
char *LDAPAPIInfo_vendor_name(LDAPAPIInfo *self){ return self->ldapai_vendor_name; }
int LDAPAPIInfo_vendor_version(LDAPAPIInfo *self){ return self->ldapai_vendor_version; }
int LDAPAPIFeatureInfo_info_version(LDAPAPIFeatureInfo *self){ return self->ldapaif_info_version; }
char *LDAPAPIFeatureInfo_name(LDAPAPIFeatureInfo *self){ return self->ldapaif_name; }
int LDAPAPIFeatureInfo_version(LDAPAPIFeatureInfo *self){ return self->ldapaif_version; }
void delete_LDAPAPIFeatureInfo(LDAPAPIFeatureInfo *self){
	if (self->ldapaif_name) free(self->ldapaif_name);
	free (self);
    }
LDAPControl *new_LDAPControl(char *oid,BerValue *bv,int critical){
	return new_control(oid, bv, critical);
    }
void delete_LDAPControl(LDAPControl *self){ free_control(self); }
char *LDAPControl_oid(LDAPControl *self){ return self->ldctl_oid; }
BerValue LDAPControl_value(LDAPControl *self){ return self->ldctl_value; }
int LDAPControl_critical(LDAPControl *self){ return self->ldctl_iscritical; }

typedef union {
		char		**modv_strvals;
		struct berval	**modv_bvals;
	} LDAPMod_mod_vals;


LDAPMod *new_LDAPMod(int op,char *type,SV *array,char **CROAK){
	LDAPMod *self;
	*CROAK=NULL;
	if (self=malloc(sizeof(struct ldapmod *))) {
	    self->mod_op=op|(0x0080);
	    self->mod_type=strdup(type);
	    self->mod_vals.modv_bvals=RV2BerValueARRAY(array, 1, CROAK);
	    if (*CROAK) {
		free(self);
		return NULL;
	    }
	}
	return self;
    }
void delete_LDAPMod(LDAPMod *self){
	if (self) {
	    if (self->mod_type) free(self->mod_type);
	    free_BerValueARRAY(self->mod_vals.modv_bvals, 1);
	    free (self);
	}
    }
int LDAPMod_op(LDAPMod *self){ return self->mod_op; }
char *LDAPMod_type(LDAPMod *self){ return self->mod_type; }
BerValue **LDAPMod_values(LDAPMod *self){ return self->mod_vals.modv_bvals; }
extern int ldap_set_rebind_proc(LDAP *,LDAP_REBIND_PROC *,void *);
extern int ldap_domain2dn(char const *,char **);
extern int ldap_dn2domain(char const *,char **);
extern int ldap_domain2hostlist(char const *,char **);
extern int ldap_extended_operation(LDAP *,char const *,struct berval *,LDAPControl **,LDAPControl **,int *);
extern int ldap_extended_operation_s(LDAP *,char const *,struct berval *,LDAPControl **,LDAPControl **,char **,struct berval **);
extern int ldap_parse_extended_result(LDAP *,LDAPMessage *,char **,struct berval **,int);
extern int ldap_parse_extended_partial(LDAP *,LDAPMessage *,char **,struct berval **,LDAPControl ***,int);
extern int ldap_parse_intermediate_resp_result(LDAP *,LDAPMessage *,char **,struct berval **,int);
extern int ldap_abandon_ext(LDAP *,int,LDAPControl **,LDAPControl **);
extern int ldap_abandon(LDAP *,int);
extern int ldap_add_ext(LDAP *,char const *,LDAPMod **,LDAPControl **,LDAPControl **,int *);
extern int ldap_add_ext_s(LDAP *,char const *,LDAPMod **,LDAPControl **,LDAPControl **);
extern int ldap_add(LDAP *,char const *,LDAPMod **);
extern int ldap_add_s(LDAP *,char const *,LDAPMod **);
extern int ldap_sasl_interactive_bind_s(LDAP *,char const *,char const *,LDAPControl **,LDAPControl **,unsigned int,LDAP_SASL_INTERACT_PROC *,void *);
extern int ldap_bind(LDAP *,char const *,char const *,int);
extern int ldap_bind_s(LDAP *,char const *,char const *,int);
extern int ldap_kerberos_bind_s(LDAP *,char const *);
extern int ldap_kerberos_bind1(LDAP *,char const *);
extern int ldap_kerberos_bind1_s(LDAP *,char const *);
extern int ldap_kerberos_bind2(LDAP *,char const *);
extern int ldap_kerberos_bind2_s(LDAP *,char const *);
extern int ldap_cancel(LDAP *,int,LDAPControl **,LDAPControl **,int *);
extern int ldap_cancel_s(LDAP *,int,LDAPControl **,LDAPControl **);
extern int ldap_compare_ext(LDAP *,char const *,char const *,struct berval *,LDAPControl **,LDAPControl **,int *);
extern int ldap_compare_ext_s(LDAP *,char const *,char const *,struct berval *,LDAPControl **,LDAPControl **);
extern int ldap_compare(LDAP *,char const *,char const *,char const *);
extern int ldap_compare_s(LDAP *,char const *,char const *,char const *);
extern int ldap_delete_ext(LDAP *,char const *,LDAPControl **,LDAPControl **,int *);
extern int ldap_delete_ext_s(LDAP *,char const *,LDAPControl **,LDAPControl **);
extern int ldap_delete(LDAP *,char const *);
extern int ldap_delete_s(LDAP *,char const *);
extern char *ldap_err2string(int);
extern int ldap_result2error(LDAP *,LDAPMessage *,int);
extern void ldap_perror(LDAP *,char const *);
extern int ldap_modify_ext(LDAP *,char const *,LDAPMod **,LDAPControl **,LDAPControl **,int *);
extern int ldap_modify_ext_s(LDAP *,char const *,LDAPMod **,LDAPControl **,LDAPControl **);
extern int ldap_modify(LDAP *,char const *,LDAPMod **);
extern int ldap_modify_s(LDAP *,char const *,LDAPMod **);
extern int ldap_rename(LDAP *,char const *,char const *,char const *,int,LDAPControl **,LDAPControl **,int *);
extern int ldap_rename_s(LDAP *,char const *,char const *,char const *,int,LDAPControl **,LDAPControl **);
extern int ldap_rename2(LDAP *,char const *,char const *,char const *,int);
extern int ldap_rename2_s(LDAP *,char const *,char const *,char const *,int);
extern int ldap_modrdn(LDAP *,char const *,char const *);
extern int ldap_modrdn_s(LDAP *,char const *,char const *);
extern int ldap_modrdn2(LDAP *,char const *,char const *,int);
extern int ldap_modrdn2_s(LDAP *,char const *,char const *,int);
extern LDAP *ldap_open(char const *,int);
extern int ldap_create(LDAP **);
extern int ldap_initialize(LDAP **,char const *);
extern int ldap_start_tls_s(LDAP *,LDAPControl **,LDAPControl **);
extern int ldap_parse_reference(LDAP *,LDAPMessage *,char ***,LDAPControl ***,int);
extern int ldap_get_entry_controls(LDAP *,LDAPMessage *,LDAPControl ***);
extern LDAPMessage *ldap_delete_result_entry(LDAPMessage **,LDAPMessage *);
extern void ldap_add_result_entry(LDAPMessage **,LDAPMessage *);
extern char *ldap_get_dn(LDAP *,LDAPMessage *);
extern void ldap_avafree(LDAPAVA *);
extern void ldap_rdnfree(LDAPRDN *);
extern void ldap_dnfree(LDAPDN *);
extern int ldap_bv2dn(struct berval *,LDAPDN **,unsigned int);
extern int ldap_str2dn(char const *,LDAPDN **,unsigned int);
extern int ldap_dn2bv(LDAPDN *,struct berval *,unsigned int);
extern int ldap_dn2str(LDAPDN *,char **,unsigned int);
extern int ldap_bv2rdn(struct berval *,LDAPRDN **,char **,unsigned int);
extern int ldap_str2rdn(char const *,LDAPRDN **,char **,unsigned int);
extern int ldap_rdn2bv(LDAPRDN *,struct berval *,unsigned int);
extern int ldap_rdn2str(LDAPRDN *,char **,unsigned int);
extern int ldap_dn_normalize(char const *,unsigned int,char **,unsigned int);
extern char *ldap_dn2ufn(char const *);
extern char **ldap_explode_dn(char const *,int);
extern char **ldap_explode_rdn(char const *,int);
extern int ldap_X509dn2bv(void *,struct berval *,LDAPDN_rewrite_func *,unsigned int);
extern char *ldap_dn2dcedn(char const *);
extern char *ldap_dcedn2dn(char const *);
extern char *ldap_dn2ad_canonical(char const *);
extern int ldap_get_dn_ber(LDAP *,LDAPMessage *,BerElement **,struct berval *);
extern int ldap_get_attribute_ber(LDAP *,LDAPMessage *,BerElement *,struct berval *,struct berval **);
extern char *ldap_first_attribute(LDAP *,LDAPMessage *,BerElement **);
extern char *ldap_next_attribute(LDAP *,LDAPMessage *,BerElement *);
extern struct berval **ldap_get_values_len(LDAP *,LDAPMessage *,char const *);
extern int ldap_count_values_len(struct berval **);
extern void ldap_value_free_len(struct berval **);
extern char **ldap_get_values(LDAP *,LDAPMessage *,char const *);
extern int ldap_count_values(char **);
extern void ldap_value_free(char **);
extern int ldap_msgtype(LDAPMessage *);
extern int ldap_msgid(LDAPMessage *);
extern int ldap_msgfree(LDAPMessage *);
extern int ldap_msgdelete(LDAP *,int);
extern int ldap_unbind(LDAP *);
extern int ldap_unbind_s(LDAP *);
extern int ldap_unbind_ext(LDAP *,LDAPControl **,LDAPControl **);
extern int ldap_unbind_ext_s(LDAP *,LDAPControl **,LDAPControl **);
extern int ldap_put_vrFilter(BerElement *,char const *);
extern void *ldap_memalloc(ber_len_t);
extern void *ldap_memrealloc(void *,ber_len_t);
extern void *ldap_memcalloc(ber_len_t,ber_len_t);
extern void ldap_memfree(void *);
extern void ldap_memvfree(void **);
extern char *ldap_strdup(char const *);
extern void ldap_mods_free(LDAPMod **,int);
extern int ldap_sort_entries(LDAP *,LDAPMessage **,char const *,LDAP_SORT_AD_CMP_PROC *);
extern int ldap_sort_values(LDAP *,char **,LDAP_SORT_AV_CMP_PROC *);
extern int ldap_sort_strcasecmp(void const *,void const *);
extern int ldap_is_ldap_url(char const *);
extern int ldap_is_ldaps_url(char const *);
extern int ldap_is_ldapi_url(char const *);
extern int ldap_url_parse(char const *,LDAPURLDesc **);
extern char *ldap_url_desc2str(LDAPURLDesc *);
extern void ldap_free_urldesc(LDAPURLDesc *);
extern int ldap_create_sort_keylist(LDAPSortKey ***,char *);
extern void ldap_free_sort_keylist(LDAPSortKey **);
extern int ldap_create_sort_control(LDAP *,LDAPSortKey **,int,LDAPControl **);
extern int ldap_parse_sort_control(LDAP *,LDAPControl **,unsigned long *,char **);
extern int ldap_create_vlv_control(LDAP *,LDAPVLVInfo *,LDAPControl **);
extern int ldap_parse_vlv_control(LDAP *,LDAPControl **,unsigned long *,unsigned long *,struct berval **,int *);
extern int ldap_parse_whoami(LDAP *,LDAPMessage *,struct berval **);
extern int ldap_whoami(LDAP *,LDAPControl **,LDAPControl **,int *);
extern int ldap_whoami_s(LDAP *,struct berval **,LDAPControl **,LDAPControl **);
extern int ldap_parse_passwd(LDAP *,LDAPMessage *,struct berval *);
extern int ldap_passwd(LDAP *,struct berval *,struct berval *,struct berval *,LDAPControl **,LDAPControl **,int *);
extern int ldap_passwd_s(LDAP *,struct berval *,struct berval *,struct berval *,struct berval *,LDAPControl **,LDAPControl **);
#ifdef PERL_OBJECT
#define MAGIC_CLASS _wrap_OnLDAP::Base_var::
class _wrap_OnLDAP::Base_var : public CPerlObj {
public:
#else
#define MAGIC_CLASS
#endif
SWIGCLASS_STATIC int swig_magic_readonly(pTHX_ SV *sv, MAGIC *mg) {
    MAGIC_PPERL
    sv = sv; mg = mg;
    croak("Value is read-only.");
    return 0;
}


#ifdef PERL_OBJECT
};
#endif

#ifdef __cplusplus
extern "C" {
#endif
XS(_wrap_Client_sasl_bind) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        char *arg2 = (char *) 0 ;
        char *arg3 = (char *) 0 ;
        BerValue *arg4 = (BerValue *) NULL ;
        LDAPControl **arg5 = (LDAPControl **) NULL ;
        LDAPControl **arg6 = (LDAPControl **) NULL ;
        int *arg7 = (int *) 0 ;
        int result;
        BerValue temp4 ;
        int temp7 ;
        int argvi = 0;
        dXSARGS;
        
        arg7 = &temp7;
        if ((items < 3) || (items > 6)) {
            SWIG_croak("Usage: Client_sasl_bind(self,dn,mechanism,cred,serverctrls,clientctrls);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client_sasl_bind. Expected _p_ldap");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        if (items > 3) {
            if (SvROK((SV *)(ST(3)))) {
                if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_BerValue,0) < 0) {
                    SWIG_croak("Type error in argument 4 of Client_sasl_bind. Expected _p_BerValue or string");
                }
            }
            else if (SvOK((SV *)(ST(3)))) {
                int n;
                arg4=&temp4;
                temp4.bv_val=SvPV((SV *)(ST(3)), n);
                temp4.bv_len=n;
            }
            else {
                arg4=NULL;
            }
            
        }
        if (items > 4) {
            {
                if (SWIG_ConvertPtr(ST(4), (void **) &arg5, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                    SWIG_croak("Type error in argument 5 of Client_sasl_bind. Expected _p_p_LDAPControl");
                }
            }
        }
        if (items > 5) {
            {
                if (SWIG_ConvertPtr(ST(5), (void **) &arg6, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                    SWIG_croak("Type error in argument 6 of Client_sasl_bind. Expected _p_p_LDAPControl");
                }
            }
        }
        result = (int)ldap_sasl_bind(arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6,arg7);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        {
            if (argvi >= items) {
                EXTEND(sp,1);
            }
            ST(argvi) = sv_newmortal();
            sv_setiv(ST(argvi),(IV) *(arg7));
            argvi++;
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client_sasl_bind_s) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        char *arg2 = (char *) 0 ;
        char *arg3 = (char *) 0 ;
        BerValue *arg4 = (BerValue *) NULL ;
        LDAPControl **arg5 = (LDAPControl **) NULL ;
        LDAPControl **arg6 = (LDAPControl **) NULL ;
        BerValue **arg7 = (BerValue **) 0 ;
        int result;
        BerValue temp4 ;
        BerValue *temp7 ;
        int argvi = 0;
        dXSARGS;
        
        temp7=0; arg7=&temp7;
        if ((items < 3) || (items > 6)) {
            SWIG_croak("Usage: Client_sasl_bind_s(self,dn,mechanism,cred,serverctrls,clientctrls);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client_sasl_bind_s. Expected _p_ldap");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        if (items > 3) {
            if (SvROK((SV *)(ST(3)))) {
                if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_BerValue,0) < 0) {
                    SWIG_croak("Type error in argument 4 of Client_sasl_bind_s. Expected _p_BerValue or string");
                }
            }
            else if (SvOK((SV *)(ST(3)))) {
                int n;
                arg4=&temp4;
                temp4.bv_val=SvPV((SV *)(ST(3)), n);
                temp4.bv_len=n;
            }
            else {
                arg4=NULL;
            }
            
        }
        if (items > 4) {
            {
                if (SWIG_ConvertPtr(ST(4), (void **) &arg5, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                    SWIG_croak("Type error in argument 5 of Client_sasl_bind_s. Expected _p_p_LDAPControl");
                }
            }
        }
        if (items > 5) {
            {
                if (SWIG_ConvertPtr(ST(5), (void **) &arg6, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                    SWIG_croak("Type error in argument 6 of Client_sasl_bind_s. Expected _p_p_LDAPControl");
                }
            }
        }
        result = (int)ldap_sasl_bind_s(arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6,arg7);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        {
            if (argvi >= items) EXTEND(sp, 1);
            if (*(arg7) && (*(arg7))->bv_val) {
                ST(argvi) = sv_2mortal(newSVpvn((*(arg7))->bv_val, (*(arg7))->bv_len));
                ber_bvfree(*(arg7));
            }
            else
            ST(argvi) = &PL_sv_undef;
            argvi++;
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client_parse_sasl_bind_result) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        LDAPMessage *arg2 = (LDAPMessage *) 0 ;
        BerValue **arg3 = (BerValue **) 0 ;
        int arg4 ;
        int result;
        BerValue *temp3 ;
        int argvi = 0;
        dXSARGS;
        
        temp3=0; arg3=&temp3;
        arg4=0;
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Client_parse_sasl_bind_result(self,res);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client_parse_sasl_bind_result. Expected _p_ldap");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_LDAPMessage,0) < 0) {
                SWIG_croak("Type error in argument 2 of Client_parse_sasl_bind_result. Expected _p_LDAPMessage");
            }
        }
        result = (int)ldap_parse_sasl_bind_result(arg1,arg2,arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        {
            if (argvi >= items) EXTEND(sp, 1);
            if (*(arg3) && (*(arg3))->bv_val) {
                ST(argvi) = sv_2mortal(newSVpvn((*(arg3))->bv_val, (*(arg3))->bv_len));
                ber_bvfree(*(arg3));
            }
            else
            ST(argvi) = &PL_sv_undef;
            argvi++;
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client_simple_bind) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        char *arg2 = (char *) 0 ;
        char *arg3 = (char *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: Client_simple_bind(self,who,passwd);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client_simple_bind. Expected _p_ldap");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        result = (int)ldap_simple_bind(arg1,(char const *)arg2,(char const *)arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client_simple_bind_s) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        char *arg2 = (char *) 0 ;
        char *arg3 = (char *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: Client_simple_bind_s(self,who,passwd);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client_simple_bind_s. Expected _p_ldap");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        result = (int)ldap_simple_bind_s(arg1,(char const *)arg2,(char const *)arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_new_Client) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        char *arg1 = (char *) 0 ;
        int arg2 = (int) 389 ;
        struct ldap *result = (struct ldap *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 2)) {
            SWIG_croak("Usage: new_Client(host,port);");
        }
        if (!SvOK((SV*) ST(0))) arg1 = 0;
        else arg1 = (char *) SvPV(ST(0), PL_na);
        if (items > 1) {
            arg2 = (int) SvIV(ST(1));
        }
        result = (struct ldap *)new_ldap(arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_ldap, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_delete_Client) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_Client(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_Client. Expected _p_ldap");
            }
        }
        delete_ldap(arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client__unbind) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        LDAPControl **arg2 = (LDAPControl **) NULL ;
        LDAPControl **arg3 = (LDAPControl **) NULL ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 3)) {
            SWIG_croak("Usage: Client__unbind(self,serverctrls,clientctrls);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client__unbind. Expected _p_ldap");
            }
        }
        if (items > 1) {
            {
                if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                    SWIG_croak("Type error in argument 2 of Client__unbind. Expected _p_p_LDAPControl");
                }
            }
        }
        if (items > 2) {
            {
                if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                    SWIG_croak("Type error in argument 3 of Client__unbind. Expected _p_p_LDAPControl");
                }
            }
        }
        result = (int)ldap__unbind(arg1,arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client__get_option__bool) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        int arg2 ;
        char **arg3 = (char **) 0 ;
        int result;
        char *err3 ;
        int argvi = 0;
        dXSARGS;
        
        err3=NULL; arg3=&err3;
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Client__get_option__bool(self,option);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client__get_option__bool. Expected _p_ldap");
            }
        }
        arg2 = (int) SvIV(ST(1));
        result = (int)ldap__get_option__bool(arg1,arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        if (*(arg3)) SWIG_croak(*(arg3));
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client__get_option__int) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        int arg2 ;
        char **arg3 = (char **) 0 ;
        int result;
        char *err3 ;
        int argvi = 0;
        dXSARGS;
        
        err3=NULL; arg3=&err3;
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Client__get_option__int(self,option);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client__get_option__int. Expected _p_ldap");
            }
        }
        arg2 = (int) SvIV(ST(1));
        result = (int)ldap__get_option__int(arg1,arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        if (*(arg3)) SWIG_croak(*(arg3));
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client__get_option__string) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        int arg2 ;
        char **arg3 = (char **) 0 ;
        char *result = (char *) 0;
        char *err3 ;
        int argvi = 0;
        dXSARGS;
        
        err3=NULL; arg3=&err3;
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Client__get_option__string(self,option);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client__get_option__string. Expected _p_ldap");
            }
        }
        arg2 = (int) SvIV(ST(1));
        result = (char *)ldap__get_option__string(arg1,arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        } else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        if (*(arg3)) SWIG_croak(*(arg3));
        if (result) ldap_memfree(result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client__get_option__APIInfo) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        int arg2 ;
        char **arg3 = (char **) 0 ;
        LDAPAPIInfo *result = (LDAPAPIInfo *) 0;
        char *err3 ;
        int argvi = 0;
        dXSARGS;
        
        err3=NULL; arg3=&err3;
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Client__get_option__APIInfo(self,option);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client__get_option__APIInfo. Expected _p_ldap");
            }
        }
        arg2 = (int) SvIV(ST(1));
        result = (LDAPAPIInfo *)ldap__get_option__APIInfo(arg1,arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_LDAPAPIInfo, SWIG_SHADOW|SWIG_OWNER);
        if (*(arg3)) SWIG_croak(*(arg3));
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client__get_option__APIFeatureInfo) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        int arg2 ;
        char *arg3 = (char *) 0 ;
        char **arg4 = (char **) 0 ;
        LDAPAPIFeatureInfo *result = (LDAPAPIFeatureInfo *) 0;
        char *err4 ;
        int argvi = 0;
        dXSARGS;
        
        err4=NULL; arg4=&err4;
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: Client__get_option__APIFeatureInfo(self,option,name);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client__get_option__APIFeatureInfo. Expected _p_ldap");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        result = (LDAPAPIFeatureInfo *)ldap__get_option__APIFeatureInfo(arg1,arg2,arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_LDAPAPIFeatureInfo, SWIG_SHADOW|SWIG_OWNER);
        if (*(arg4)) SWIG_croak(*(arg4));
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client__get_option__Controls) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        int arg2 ;
        char **arg3 = (char **) 0 ;
        LDAPControl **result = (LDAPControl **) 0;
        char *err3 ;
        int argvi = 0;
        dXSARGS;
        
        err3=NULL; arg3=&err3;
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Client__get_option__Controls(self,option);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client__get_option__Controls. Expected _p_ldap");
            }
        }
        arg2 = (int) SvIV(ST(1));
        result = (LDAPControl **)ldap__get_option__Controls(arg1,arg2,arg3);
        
        {
            ST(argvi++)=PPANY2PERLARRAY((void **)(result), &LDAPControl2PERL_COPY,
            SWIGTYPE_p_LDAPControl, SWIG_SHADOW, &ldap_controls_free);
        }
        if (*(arg3)) SWIG_croak(*(arg3));
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client__set_option__bool) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        int arg2 ;
        int arg3 ;
        char **arg4 = (char **) 0 ;
        char *err4 ;
        int argvi = 0;
        dXSARGS;
        
        err4=NULL; arg4=&err4;
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: Client__set_option__bool(self,option,value);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client__set_option__bool. Expected _p_ldap");
            }
        }
        arg2 = (int) SvIV(ST(1));
        arg3 = (int) SvIV(ST(2));
        ldap__set_option__bool(arg1,arg2,arg3,arg4);
        
        
        if (*(arg4)) SWIG_croak(*(arg4));
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client__set_option__int) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        int arg2 ;
        int arg3 ;
        char **arg4 = (char **) 0 ;
        char *err4 ;
        int argvi = 0;
        dXSARGS;
        
        err4=NULL; arg4=&err4;
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: Client__set_option__int(self,option,value);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client__set_option__int. Expected _p_ldap");
            }
        }
        arg2 = (int) SvIV(ST(1));
        arg3 = (int) SvIV(ST(2));
        ldap__set_option__int(arg1,arg2,arg3,arg4);
        
        
        if (*(arg4)) SWIG_croak(*(arg4));
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client__set_option__string) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        int arg2 ;
        char *arg3 = (char *) 0 ;
        char **arg4 = (char **) 0 ;
        char *err4 ;
        int argvi = 0;
        dXSARGS;
        
        err4=NULL; arg4=&err4;
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: Client__set_option__string(self,option,value);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client__set_option__string. Expected _p_ldap");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        ldap__set_option__string(arg1,arg2,arg3,arg4);
        
        
        if (*(arg4)) SWIG_croak(*(arg4));
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client__set_option__Controls) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        int arg2 ;
        LDAPControl **arg3 = (LDAPControl **) 0 ;
        char **arg4 = (char **) 0 ;
        char *err4 ;
        int argvi = 0;
        dXSARGS;
        
        err4=NULL; arg4=&err4;
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: Client__set_option__Controls(self,option,PPANY);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client__set_option__Controls. Expected _p_ldap");
            }
        }
        arg2 = (int) SvIV(ST(1));
        {
            char *croak;
            PERLARRAY2PPANY(ST(2), (void **)(&(arg3)), &croak, SWIGTYPE_p_LDAPControl);
            if(croak) SWIG_croak(croak);
        }
        ldap__set_option__Controls(arg1,arg2,arg3,arg4);
        
        
        if (*(arg4)) SWIG_croak(*(arg4));
        if (arg3) free(arg3);
        XSRETURN(argvi);
        fail:
        if (arg3) free(arg3);
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client_first_message) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        LDAPMessage *arg2 = (LDAPMessage *) 0 ;
        LDAPMessage *result = (LDAPMessage *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Client_first_message(self,chain);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client_first_message. Expected _p_ldap");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_LDAPMessage,0) < 0) {
                SWIG_croak("Type error in argument 2 of Client_first_message. Expected _p_LDAPMessage");
            }
        }
        result = (LDAPMessage *)ldap_first_message(arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_LDAPMessage, SWIG_SHADOW|0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client_next_message) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        LDAPMessage *arg2 = (LDAPMessage *) 0 ;
        LDAPMessage *result = (LDAPMessage *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Client_next_message(self,msg);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client_next_message. Expected _p_ldap");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_LDAPMessage,0) < 0) {
                SWIG_croak("Type error in argument 2 of Client_next_message. Expected _p_LDAPMessage");
            }
        }
        result = (LDAPMessage *)ldap_next_message(arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_LDAPMessage, SWIG_SHADOW|0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client_count_messages) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        LDAPMessage *arg2 = (LDAPMessage *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Client_count_messages(self,chain);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client_count_messages. Expected _p_ldap");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_LDAPMessage,0) < 0) {
                SWIG_croak("Type error in argument 2 of Client_count_messages. Expected _p_LDAPMessage");
            }
        }
        result = (int)ldap_count_messages(arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client_first_reference) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        LDAPMessage *arg2 = (LDAPMessage *) 0 ;
        LDAPMessage *result = (LDAPMessage *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Client_first_reference(self,chain);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client_first_reference. Expected _p_ldap");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_LDAPMessage,0) < 0) {
                SWIG_croak("Type error in argument 2 of Client_first_reference. Expected _p_LDAPMessage");
            }
        }
        result = (LDAPMessage *)ldap_first_reference(arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_LDAPMessage, SWIG_SHADOW|0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client_next_reference) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        LDAPMessage *arg2 = (LDAPMessage *) 0 ;
        LDAPMessage *result = (LDAPMessage *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Client_next_reference(self,ref);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client_next_reference. Expected _p_ldap");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_LDAPMessage,0) < 0) {
                SWIG_croak("Type error in argument 2 of Client_next_reference. Expected _p_LDAPMessage");
            }
        }
        result = (LDAPMessage *)ldap_next_reference(arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_LDAPMessage, SWIG_SHADOW|0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client_count_references) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        LDAPMessage *arg2 = (LDAPMessage *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Client_count_references(self,chain);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client_count_references. Expected _p_ldap");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_LDAPMessage,0) < 0) {
                SWIG_croak("Type error in argument 2 of Client_count_references. Expected _p_LDAPMessage");
            }
        }
        result = (int)ldap_count_references(arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client_ldap_parse_reference) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        LDAP *arg2 = (LDAP *) 0 ;
        LDAPMessage *arg3 = (LDAPMessage *) 0 ;
        STRING **arg4 = (STRING **) 0 ;
        LDAPControl ***arg5 = (LDAPControl ***) 0 ;
        int arg6 ;
        int result;
        STRING *temp4 ;
        LDAPControl **temp5 ;
        int argvi = 0;
        dXSARGS;
        
        temp4=0; arg4=&temp4;
        temp5=0; arg5=&temp5;
        arg6=0;
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: Client_ldap_parse_reference(self,ld,ref);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client_ldap_parse_reference. Expected _p_ldap");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 2 of Client_ldap_parse_reference. Expected _p_LDAP");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_LDAPMessage,0) < 0) {
                SWIG_croak("Type error in argument 3 of Client_ldap_parse_reference. Expected _p_LDAPMessage");
            }
        }
        result = (int)ldap_ldap_parse_reference(arg1,arg2,arg3,arg4,arg5,arg6);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        {
            if (argvi >= items) EXTEND(sp, 1);
            ST(argvi) = PPANY2PERLARRAY((void **)(*(arg4)), &PCHAR2PERL,
            SWIGTYPE_STRING, 0, &ldap_value_free);
            argvi++;
        }
        {
            if (argvi >= items) EXTEND(sp, 1);
            ST(argvi) = PPANY2PERLARRAY((void **)(*(arg5)), &LDAPControl2PERL_COPY,
            SWIGTYPE_p_LDAPControl, SWIG_SHADOW, &ldap_controls_free);
            argvi++;
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client_first_entry) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        LDAPMessage *arg2 = (LDAPMessage *) 0 ;
        LDAPMessage *result = (LDAPMessage *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Client_first_entry(self,chain);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client_first_entry. Expected _p_ldap");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_LDAPMessage,0) < 0) {
                SWIG_croak("Type error in argument 2 of Client_first_entry. Expected _p_LDAPMessage");
            }
        }
        result = (LDAPMessage *)ldap_first_entry(arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_LDAPMessage, SWIG_SHADOW|0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client_next_entry) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        LDAPMessage *arg2 = (LDAPMessage *) 0 ;
        LDAPMessage *result = (LDAPMessage *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Client_next_entry(self,entry);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client_next_entry. Expected _p_ldap");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_LDAPMessage,0) < 0) {
                SWIG_croak("Type error in argument 2 of Client_next_entry. Expected _p_LDAPMessage");
            }
        }
        result = (LDAPMessage *)ldap_next_entry(arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_LDAPMessage, SWIG_SHADOW|0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client_count_entries) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        LDAPMessage *arg2 = (LDAPMessage *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Client_count_entries(self,chain);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client_count_entries. Expected _p_ldap");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_LDAPMessage,0) < 0) {
                SWIG_croak("Type error in argument 2 of Client_count_entries. Expected _p_LDAPMessage");
            }
        }
        result = (int)ldap_count_entries(arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client_get_entry_controls) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        LDAPMessage *arg2 = (LDAPMessage *) 0 ;
        LDAPControl ***arg3 = (LDAPControl ***) 0 ;
        int result;
        LDAPControl **temp3 ;
        int argvi = 0;
        dXSARGS;
        
        temp3=0; arg3=&temp3;
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Client_get_entry_controls(self,entry);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client_get_entry_controls. Expected _p_ldap");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_LDAPMessage,0) < 0) {
                SWIG_croak("Type error in argument 2 of Client_get_entry_controls. Expected _p_LDAPMessage");
            }
        }
        result = (int)ldap_get_entry_controls(arg1,arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        {
            if (argvi >= items) EXTEND(sp, 1);
            ST(argvi) = PPANY2PERLARRAY((void **)(*(arg3)), &LDAPControl2PERL_COPY,
            SWIGTYPE_p_LDAPControl, SWIG_SHADOW, &ldap_controls_free);
            argvi++;
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client_result) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        int arg2 ;
        int arg3 = (int) 0 ;
        struct timeval *arg4 = (struct timeval *) NULL ;
        LDAPMessage **arg5 = (LDAPMessage **) 0 ;
        int result;
        struct ldapmsg *temp5 ;
        int argvi = 0;
        dXSARGS;
        
        temp5=0; arg5=&temp5;
        if ((items < 2) || (items > 4)) {
            SWIG_croak("Usage: Client_result(self,msgid,all,timeout);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client_result. Expected _p_ldap");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (items > 2) {
            arg3 = (int) SvIV(ST(2));
        }
        if (items > 3) {
            {
                if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_timeval,0) < 0) {
                    SWIG_croak("Type error in argument 4 of Client_result. Expected _p_timeval");
                }
            }
        }
        result = (int)ldap_result(arg1,arg2,arg3,arg4,arg5);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        {
            if (argvi >= items) EXTEND(sp, 1);
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi), (void *) *(arg5),
            SWIGTYPE_p_ldapmsg, SWIG_OWNER|SWIG_SHADOW);
            argvi++;
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client_search) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        char *arg2 = (char *) NULL ;
        int arg3 = (int) 0 ;
        char *arg4 = (char *) NULL ;
        char **arg5 = (char **) NULL ;
        int arg6 = (int) 0 ;
        LDAPControl **arg7 = (LDAPControl **) NULL ;
        LDAPControl **arg8 = (LDAPControl **) NULL ;
        struct timeval *arg9 = (struct timeval *) 0 ;
        int arg10 = (int) 0 ;
        int *arg11 = (int *) 0 ;
        int result;
        int temp11 ;
        int argvi = 0;
        dXSARGS;
        
        arg11 = &temp11;
        if ((items < 1) || (items > 10)) {
            SWIG_croak("Usage: Client_search(self,base,scope,filter,PPchar,attrsonly,serverctrls,clientctrls,timeout,sizelimit);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client_search. Expected _p_ldap");
            }
        }
        if (items > 1) {
            if (!SvOK((SV*) ST(1))) arg2 = 0;
            else arg2 = (char *) SvPV(ST(1), PL_na);
        }
        if (items > 2) {
            arg3 = (int) SvIV(ST(2));
        }
        if (items > 3) {
            if (!SvOK((SV*) ST(3))) arg4 = 0;
            else arg4 = (char *) SvPV(ST(3), PL_na);
        }
        if (items > 4) {
            {
                char *croak;
                arg5=PERLARRAY2PPchar(ST(4), &croak);
                if(croak) SWIG_croak(croak);
            }
        }
        if (items > 5) {
            arg6 = (int) SvIV(ST(5));
        }
        if (items > 6) {
            {
                if (SWIG_ConvertPtr(ST(6), (void **) &arg7, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                    SWIG_croak("Type error in argument 7 of Client_search. Expected _p_p_LDAPControl");
                }
            }
        }
        if (items > 7) {
            {
                if (SWIG_ConvertPtr(ST(7), (void **) &arg8, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                    SWIG_croak("Type error in argument 8 of Client_search. Expected _p_p_LDAPControl");
                }
            }
        }
        if (items > 8) {
            {
                if (SWIG_ConvertPtr(ST(8), (void **) &arg9, SWIGTYPE_p_timeval,0) < 0) {
                    SWIG_croak("Type error in argument 9 of Client_search. Expected _p_timeval");
                }
            }
        }
        if (items > 9) {
            arg10 = (int) SvIV(ST(9));
        }
        result = (int)ldap_search_ext(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        {
            if (argvi >= items) {
                EXTEND(sp,1);
            }
            ST(argvi) = sv_newmortal();
            sv_setiv(ST(argvi),(IV) *(arg11));
            argvi++;
        }
        if (arg5) free(arg5);
        XSRETURN(argvi);
        fail:
        if (arg5) free(arg5);
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client_search_s) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        char *arg2 = (char *) NULL ;
        int arg3 = (int) 0 ;
        char *arg4 = (char *) NULL ;
        char **arg5 = (char **) NULL ;
        int arg6 = (int) NULL ;
        LDAPControl **arg7 = (LDAPControl **) NULL ;
        LDAPControl **arg8 = (LDAPControl **) NULL ;
        struct timeval *arg9 = (struct timeval *) NULL ;
        int arg10 = (int) 0 ;
        LDAPMessage **arg11 = (LDAPMessage **) 0 ;
        int result;
        struct ldapmsg *temp11 ;
        int argvi = 0;
        dXSARGS;
        
        temp11=0; arg11=&temp11;
        if ((items < 1) || (items > 10)) {
            SWIG_croak("Usage: Client_search_s(self,base,scope,filter,PPchar,attrsonly,serverctrls,clientctrls,timeout,sizelimit);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client_search_s. Expected _p_ldap");
            }
        }
        if (items > 1) {
            if (!SvOK((SV*) ST(1))) arg2 = 0;
            else arg2 = (char *) SvPV(ST(1), PL_na);
        }
        if (items > 2) {
            arg3 = (int) SvIV(ST(2));
        }
        if (items > 3) {
            if (!SvOK((SV*) ST(3))) arg4 = 0;
            else arg4 = (char *) SvPV(ST(3), PL_na);
        }
        if (items > 4) {
            {
                char *croak;
                arg5=PERLARRAY2PPchar(ST(4), &croak);
                if(croak) SWIG_croak(croak);
            }
        }
        if (items > 5) {
            arg6 = (int) SvIV(ST(5));
        }
        if (items > 6) {
            {
                if (SWIG_ConvertPtr(ST(6), (void **) &arg7, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                    SWIG_croak("Type error in argument 7 of Client_search_s. Expected _p_p_LDAPControl");
                }
            }
        }
        if (items > 7) {
            {
                if (SWIG_ConvertPtr(ST(7), (void **) &arg8, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                    SWIG_croak("Type error in argument 8 of Client_search_s. Expected _p_p_LDAPControl");
                }
            }
        }
        if (items > 8) {
            {
                if (SWIG_ConvertPtr(ST(8), (void **) &arg9, SWIGTYPE_p_timeval,0) < 0) {
                    SWIG_croak("Type error in argument 9 of Client_search_s. Expected _p_timeval");
                }
            }
        }
        if (items > 9) {
            arg10 = (int) SvIV(ST(9));
        }
        result = (int)ldap_search_ext_s(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        {
            if (argvi >= items) EXTEND(sp, 1);
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi), (void *) *(arg11),
            SWIGTYPE_p_ldapmsg, SWIG_OWNER|SWIG_SHADOW);
            argvi++;
        }
        if (arg5) free(arg5);
        XSRETURN(argvi);
        fail:
        if (arg5) free(arg5);
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client_parse_result) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        LDAPMessage *arg2 = (LDAPMessage *) 0 ;
        int *arg3 = (int *) 0 ;
        char **arg4 = (char **) 0 ;
        char **arg5 = (char **) 0 ;
        STRING **arg6 = (STRING **) 0 ;
        LDAPControl ***arg7 = (LDAPControl ***) 0 ;
        int arg8 ;
        int result;
        int temp3 ;
        char *temp4 ;
        char *temp5 ;
        STRING *temp6 ;
        LDAPControl **temp7 ;
        int argvi = 0;
        dXSARGS;
        
        arg3 = &temp3;
        temp4=NULL; arg4=&temp4;
        temp5=NULL; arg5=&temp5;
        temp6=0; arg6=&temp6;
        temp7=0; arg7=&temp7;
        arg8=0;
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Client_parse_result(self,res);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client_parse_result. Expected _p_ldap");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_LDAPMessage,0) < 0) {
                SWIG_croak("Type error in argument 2 of Client_parse_result. Expected _p_LDAPMessage");
            }
        }
        result = (int)ldap_parse_result(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        {
            if (argvi >= items) {
                EXTEND(sp,1);
            }
            ST(argvi) = sv_newmortal();
            sv_setiv(ST(argvi),(IV) *(arg3));
            argvi++;
        }
        {
            if(argvi >= items) EXTEND(sp, 1);
            ST(argvi) = sv_2mortal(newSVpv(*arg4, 0));
            argvi++;
        }
        {
            if(argvi >= items) EXTEND(sp, 1);
            ST(argvi) = sv_2mortal(newSVpv(*arg5, 0));
            argvi++;
        }
        {
            if (argvi >= items) EXTEND(sp, 1);
            ST(argvi) = PPANY2PERLARRAY((void **)(*(arg6)), &PCHAR2PERL,
            SWIGTYPE_STRING, 0, &ldap_value_free);
            argvi++;
        }
        {
            if (argvi >= items) EXTEND(sp, 1);
            ST(argvi) = PPANY2PERLARRAY((void **)(*(arg7)), &LDAPControl2PERL_COPY,
            SWIGTYPE_p_LDAPControl, SWIG_SHADOW, &ldap_controls_free);
            argvi++;
        }
        {
            ldap_memfree(arg4); 
        }
        {
            ldap_memfree(arg5); 
        }
        XSRETURN(argvi);
        fail:
        {
            ldap_memfree(arg4); 
        }
        {
            ldap_memfree(arg5); 
        }
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client_extended_operation) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        char *arg2 = (char *) 0 ;
        struct berval *arg3 = (struct berval *) 0 ;
        LDAPControl **arg4 = (LDAPControl **) NULL ;
        LDAPControl **arg5 = (LDAPControl **) NULL ;
        int *arg6 = (int *) 0 ;
        int result;
        int temp6 ;
        int argvi = 0;
        dXSARGS;
        
        arg6 = &temp6;
        if ((items < 3) || (items > 5)) {
            SWIG_croak("Usage: Client_extended_operation(self,reqoid,reqdata,serverctrls,clientctrls);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client_extended_operation. Expected _p_ldap");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 3 of Client_extended_operation. Expected _p_berval");
            }
        }
        if (items > 3) {
            {
                if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                    SWIG_croak("Type error in argument 4 of Client_extended_operation. Expected _p_p_LDAPControl");
                }
            }
        }
        if (items > 4) {
            {
                if (SWIG_ConvertPtr(ST(4), (void **) &arg5, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                    SWIG_croak("Type error in argument 5 of Client_extended_operation. Expected _p_p_LDAPControl");
                }
            }
        }
        result = (int)ldap_extended_operation(arg1,arg2,arg3,arg4,arg5,arg6);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        {
            if (argvi >= items) {
                EXTEND(sp,1);
            }
            ST(argvi) = sv_newmortal();
            sv_setiv(ST(argvi),(IV) *(arg6));
            argvi++;
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client_extended_operation_s) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        char *arg2 = (char *) 0 ;
        struct berval *arg3 = (struct berval *) 0 ;
        LDAPControl **arg4 = (LDAPControl **) NULL ;
        LDAPControl **arg5 = (LDAPControl **) NULL ;
        char **arg6 = (char **) 0 ;
        BerValue **arg7 = (BerValue **) 0 ;
        int result;
        char *temp6 ;
        BerValue *temp7 ;
        int argvi = 0;
        dXSARGS;
        
        temp6=NULL; arg6=&temp6;
        temp7=0; arg7=&temp7;
        if ((items < 3) || (items > 5)) {
            SWIG_croak("Usage: Client_extended_operation_s(self,reqoid,reqdata,serverctrls,clientctrls);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client_extended_operation_s. Expected _p_ldap");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 3 of Client_extended_operation_s. Expected _p_berval");
            }
        }
        if (items > 3) {
            {
                if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                    SWIG_croak("Type error in argument 4 of Client_extended_operation_s. Expected _p_p_LDAPControl");
                }
            }
        }
        if (items > 4) {
            {
                if (SWIG_ConvertPtr(ST(4), (void **) &arg5, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                    SWIG_croak("Type error in argument 5 of Client_extended_operation_s. Expected _p_p_LDAPControl");
                }
            }
        }
        result = (int)ldap_extended_operation_s(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        {
            if(argvi >= items) EXTEND(sp, 1);
            ST(argvi) = sv_2mortal(newSVpv(*arg6, 0));
            argvi++;
        }
        {
            if (argvi >= items) EXTEND(sp, 1);
            if (*(arg7) && (*(arg7))->bv_val) {
                ST(argvi) = sv_2mortal(newSVpvn((*(arg7))->bv_val, (*(arg7))->bv_len));
                ber_bvfree(*(arg7));
            }
            else
            ST(argvi) = &PL_sv_undef;
            argvi++;
        }
        {
            ldap_memfree(arg6); 
        }
        XSRETURN(argvi);
        fail:
        {
            ldap_memfree(arg6); 
        }
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client_parse_extended_result) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        LDAPMessage *arg2 = (LDAPMessage *) 0 ;
        char **arg3 = (char **) 0 ;
        BerValue **arg4 = (BerValue **) 0 ;
        int arg5 ;
        int result;
        char *temp3 ;
        BerValue *temp4 ;
        int argvi = 0;
        dXSARGS;
        
        temp3=NULL; arg3=&temp3;
        temp4=0; arg4=&temp4;
        arg5=0;
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Client_parse_extended_result(self,res);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client_parse_extended_result. Expected _p_ldap");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_LDAPMessage,0) < 0) {
                SWIG_croak("Type error in argument 2 of Client_parse_extended_result. Expected _p_LDAPMessage");
            }
        }
        result = (int)ldap_parse_extended_result(arg1,arg2,arg3,arg4,arg5);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        {
            if(argvi >= items) EXTEND(sp, 1);
            ST(argvi) = sv_2mortal(newSVpv(*arg3, 0));
            argvi++;
        }
        {
            if (argvi >= items) EXTEND(sp, 1);
            if (*(arg4) && (*(arg4))->bv_val) {
                ST(argvi) = sv_2mortal(newSVpvn((*(arg4))->bv_val, (*(arg4))->bv_len));
                ber_bvfree(*(arg4));
            }
            else
            ST(argvi) = &PL_sv_undef;
            argvi++;
        }
        {
            ldap_memfree(arg3); 
        }
        XSRETURN(argvi);
        fail:
        {
            ldap_memfree(arg3); 
        }
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client_parse_extended_partial) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        LDAPMessage *arg2 = (LDAPMessage *) 0 ;
        char **arg3 = (char **) 0 ;
        BerValue **arg4 = (BerValue **) 0 ;
        LDAPControl ***arg5 = (LDAPControl ***) 0 ;
        int arg6 ;
        int result;
        char *temp3 ;
        BerValue *temp4 ;
        LDAPControl **temp5 ;
        int argvi = 0;
        dXSARGS;
        
        temp3=NULL; arg3=&temp3;
        temp4=0; arg4=&temp4;
        temp5=0; arg5=&temp5;
        arg6=0;
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Client_parse_extended_partial(self,res);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client_parse_extended_partial. Expected _p_ldap");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_LDAPMessage,0) < 0) {
                SWIG_croak("Type error in argument 2 of Client_parse_extended_partial. Expected _p_LDAPMessage");
            }
        }
        result = (int)ldap_parse_extended_partial(arg1,arg2,arg3,arg4,arg5,arg6);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        {
            if(argvi >= items) EXTEND(sp, 1);
            ST(argvi) = sv_2mortal(newSVpv(*arg3, 0));
            argvi++;
        }
        {
            if (argvi >= items) EXTEND(sp, 1);
            if (*(arg4) && (*(arg4))->bv_val) {
                ST(argvi) = sv_2mortal(newSVpvn((*(arg4))->bv_val, (*(arg4))->bv_len));
                ber_bvfree(*(arg4));
            }
            else
            ST(argvi) = &PL_sv_undef;
            argvi++;
        }
        {
            if (argvi >= items) EXTEND(sp, 1);
            ST(argvi) = PPANY2PERLARRAY((void **)(*(arg5)), &LDAPControl2PERL_COPY,
            SWIGTYPE_p_LDAPControl, SWIG_SHADOW, &ldap_controls_free);
            argvi++;
        }
        {
            ldap_memfree(arg3); 
        }
        XSRETURN(argvi);
        fail:
        {
            ldap_memfree(arg3); 
        }
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client_parse_intermediate_resp_result) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        LDAPMessage *arg2 = (LDAPMessage *) 0 ;
        char **arg3 = (char **) 0 ;
        BerValue **arg4 = (BerValue **) 0 ;
        int arg5 ;
        int result;
        char *temp3 ;
        BerValue *temp4 ;
        int argvi = 0;
        dXSARGS;
        
        temp3=NULL; arg3=&temp3;
        temp4=0; arg4=&temp4;
        arg5=0;
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Client_parse_intermediate_resp_result(self,res);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client_parse_intermediate_resp_result. Expected _p_ldap");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_LDAPMessage,0) < 0) {
                SWIG_croak("Type error in argument 2 of Client_parse_intermediate_resp_result. Expected _p_LDAPMessage");
            }
        }
        result = (int)ldap_parse_intermediate_resp_result(arg1,arg2,arg3,arg4,arg5);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        {
            if(argvi >= items) EXTEND(sp, 1);
            ST(argvi) = sv_2mortal(newSVpv(*arg3, 0));
            argvi++;
        }
        {
            if (argvi >= items) EXTEND(sp, 1);
            if (*(arg4) && (*(arg4))->bv_val) {
                ST(argvi) = sv_2mortal(newSVpvn((*(arg4))->bv_val, (*(arg4))->bv_len));
                ber_bvfree(*(arg4));
            }
            else
            ST(argvi) = &PL_sv_undef;
            argvi++;
        }
        {
            ldap_memfree(arg3); 
        }
        XSRETURN(argvi);
        fail:
        {
            ldap_memfree(arg3); 
        }
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client_abandon) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        int arg2 ;
        LDAPControl **arg3 = (LDAPControl **) NULL ;
        LDAPControl **arg4 = (LDAPControl **) NULL ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 4)) {
            SWIG_croak("Usage: Client_abandon(self,msgid,serverctrls,clientctrls);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client_abandon. Expected _p_ldap");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (items > 2) {
            {
                if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                    SWIG_croak("Type error in argument 3 of Client_abandon. Expected _p_p_LDAPControl");
                }
            }
        }
        if (items > 3) {
            {
                if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                    SWIG_croak("Type error in argument 4 of Client_abandon. Expected _p_p_LDAPControl");
                }
            }
        }
        result = (int)ldap_abandon_ext(arg1,arg2,arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client_add) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        char *arg2 = (char *) 0 ;
        LDAPMod **arg3 = (LDAPMod **) 0 ;
        LDAPControl **arg4 = (LDAPControl **) NULL ;
        LDAPControl **arg5 = (LDAPControl **) NULL ;
        int *arg6 = (int *) 0 ;
        int result;
        int temp6 ;
        int argvi = 0;
        dXSARGS;
        
        arg6 = &temp6;
        if ((items < 3) || (items > 5)) {
            SWIG_croak("Usage: Client_add(self,dn,attrs,serverctrls,clientctrls);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client_add. Expected _p_ldap");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_p_LDAPMod,0) < 0) {
                SWIG_croak("Type error in argument 3 of Client_add. Expected _p_p_LDAPMod");
            }
        }
        if (items > 3) {
            {
                if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                    SWIG_croak("Type error in argument 4 of Client_add. Expected _p_p_LDAPControl");
                }
            }
        }
        if (items > 4) {
            {
                if (SWIG_ConvertPtr(ST(4), (void **) &arg5, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                    SWIG_croak("Type error in argument 5 of Client_add. Expected _p_p_LDAPControl");
                }
            }
        }
        result = (int)ldap_add_ext(arg1,arg2,arg3,arg4,arg5,arg6);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        {
            if (argvi >= items) {
                EXTEND(sp,1);
            }
            ST(argvi) = sv_newmortal();
            sv_setiv(ST(argvi),(IV) *(arg6));
            argvi++;
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client_add_s) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        char *arg2 = (char *) 0 ;
        LDAPMod **arg3 = (LDAPMod **) 0 ;
        LDAPControl **arg4 = (LDAPControl **) NULL ;
        LDAPControl **arg5 = (LDAPControl **) NULL ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 5)) {
            SWIG_croak("Usage: Client_add_s(self,dn,attrs,serverctrls,clientctrls);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client_add_s. Expected _p_ldap");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_p_LDAPMod,0) < 0) {
                SWIG_croak("Type error in argument 3 of Client_add_s. Expected _p_p_LDAPMod");
            }
        }
        if (items > 3) {
            {
                if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                    SWIG_croak("Type error in argument 4 of Client_add_s. Expected _p_p_LDAPControl");
                }
            }
        }
        if (items > 4) {
            {
                if (SWIG_ConvertPtr(ST(4), (void **) &arg5, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                    SWIG_croak("Type error in argument 5 of Client_add_s. Expected _p_p_LDAPControl");
                }
            }
        }
        result = (int)ldap_add_ext_s(arg1,arg2,arg3,arg4,arg5);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client_ldap_cancel) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        int arg2 ;
        LDAPControl **arg3 = (LDAPControl **) NULL ;
        LDAPControl **arg4 = (LDAPControl **) NULL ;
        int *arg5 = (int *) 0 ;
        int result;
        int temp5 ;
        int argvi = 0;
        dXSARGS;
        
        arg5 = &temp5;
        if ((items < 2) || (items > 4)) {
            SWIG_croak("Usage: Client_ldap_cancel(self,cancelid,sctrls,cctrls);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client_ldap_cancel. Expected _p_ldap");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (items > 2) {
            {
                if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                    SWIG_croak("Type error in argument 3 of Client_ldap_cancel. Expected _p_p_LDAPControl");
                }
            }
        }
        if (items > 3) {
            {
                if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                    SWIG_croak("Type error in argument 4 of Client_ldap_cancel. Expected _p_p_LDAPControl");
                }
            }
        }
        result = (int)ldap_ldap_cancel(arg1,arg2,arg3,arg4,arg5);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        {
            if (argvi >= items) {
                EXTEND(sp,1);
            }
            ST(argvi) = sv_newmortal();
            sv_setiv(ST(argvi),(IV) *(arg5));
            argvi++;
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client_ldap_cancel_s) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        int arg2 ;
        LDAPControl **arg3 = (LDAPControl **) NULL ;
        LDAPControl **arg4 = (LDAPControl **) NULL ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 4)) {
            SWIG_croak("Usage: Client_ldap_cancel_s(self,cancelid,sctrls,cctrls);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client_ldap_cancel_s. Expected _p_ldap");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (items > 2) {
            {
                if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                    SWIG_croak("Type error in argument 3 of Client_ldap_cancel_s. Expected _p_p_LDAPControl");
                }
            }
        }
        if (items > 3) {
            {
                if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                    SWIG_croak("Type error in argument 4 of Client_ldap_cancel_s. Expected _p_p_LDAPControl");
                }
            }
        }
        result = (int)ldap_ldap_cancel_s(arg1,arg2,arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client_compare) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        char *arg2 = (char *) 0 ;
        char *arg3 = (char *) 0 ;
        struct berval *arg4 = (struct berval *) 0 ;
        LDAPControl **arg5 = (LDAPControl **) 0 ;
        LDAPControl **arg6 = (LDAPControl **) 0 ;
        int *arg7 = (int *) 0 ;
        int result;
        int temp7 ;
        int argvi = 0;
        dXSARGS;
        
        arg7 = &temp7;
        if ((items < 6) || (items > 6)) {
            SWIG_croak("Usage: Client_compare(self,dn,attr,bvalue,serverctrls,clientctrls);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client_compare. Expected _p_ldap");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 4 of Client_compare. Expected _p_berval");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(4), (void **) &arg5, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 5 of Client_compare. Expected _p_p_LDAPControl");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(5), (void **) &arg6, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 6 of Client_compare. Expected _p_p_LDAPControl");
            }
        }
        result = (int)ldap_compare_ext(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        {
            if (argvi >= items) {
                EXTEND(sp,1);
            }
            ST(argvi) = sv_newmortal();
            sv_setiv(ST(argvi),(IV) *(arg7));
            argvi++;
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client_compare_s) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        char *arg2 = (char *) 0 ;
        char *arg3 = (char *) 0 ;
        struct berval *arg4 = (struct berval *) 0 ;
        LDAPControl **arg5 = (LDAPControl **) 0 ;
        LDAPControl **arg6 = (LDAPControl **) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 6) || (items > 6)) {
            SWIG_croak("Usage: Client_compare_s(self,dn,attr,bvalue,serverctrls,clientctrls);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client_compare_s. Expected _p_ldap");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 4 of Client_compare_s. Expected _p_berval");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(4), (void **) &arg5, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 5 of Client_compare_s. Expected _p_p_LDAPControl");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(5), (void **) &arg6, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 6 of Client_compare_s. Expected _p_p_LDAPControl");
            }
        }
        result = (int)ldap_compare_ext_s(arg1,arg2,arg3,arg4,arg5,arg6);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client_delete) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        char *arg2 = (char *) 0 ;
        LDAPControl **arg3 = (LDAPControl **) NULL ;
        LDAPControl **arg4 = (LDAPControl **) NULL ;
        int *arg5 = (int *) 0 ;
        int result;
        int temp5 ;
        int argvi = 0;
        dXSARGS;
        
        arg5 = &temp5;
        if ((items < 2) || (items > 4)) {
            SWIG_croak("Usage: Client_delete(self,dn,sctrls,cctrls);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client_delete. Expected _p_ldap");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        if (items > 2) {
            {
                if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                    SWIG_croak("Type error in argument 3 of Client_delete. Expected _p_p_LDAPControl");
                }
            }
        }
        if (items > 3) {
            {
                if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                    SWIG_croak("Type error in argument 4 of Client_delete. Expected _p_p_LDAPControl");
                }
            }
        }
        result = (int)ldap_delete_ext(arg1,arg2,arg3,arg4,arg5);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        {
            if (argvi >= items) {
                EXTEND(sp,1);
            }
            ST(argvi) = sv_newmortal();
            sv_setiv(ST(argvi),(IV) *(arg5));
            argvi++;
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client_delete_s) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        char *arg2 = (char *) 0 ;
        LDAPControl **arg3 = (LDAPControl **) NULL ;
        LDAPControl **arg4 = (LDAPControl **) NULL ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 4)) {
            SWIG_croak("Usage: Client_delete_s(self,dn,sctrls,cctrls);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client_delete_s. Expected _p_ldap");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        if (items > 2) {
            {
                if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                    SWIG_croak("Type error in argument 3 of Client_delete_s. Expected _p_p_LDAPControl");
                }
            }
        }
        if (items > 3) {
            {
                if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                    SWIG_croak("Type error in argument 4 of Client_delete_s. Expected _p_p_LDAPControl");
                }
            }
        }
        result = (int)ldap_delete_ext_s(arg1,arg2,arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client_modify) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        char *arg2 = (char *) 0 ;
        LDAPMod **arg3 = (LDAPMod **) 0 ;
        LDAPControl **arg4 = (LDAPControl **) NULL ;
        LDAPControl **arg5 = (LDAPControl **) NULL ;
        int *arg6 = (int *) 0 ;
        int result;
        int temp6 ;
        int argvi = 0;
        dXSARGS;
        
        arg6 = &temp6;
        if ((items < 3) || (items > 5)) {
            SWIG_croak("Usage: Client_modify(self,dn,mods,sctrls,cctrls);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client_modify. Expected _p_ldap");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_p_LDAPMod,0) < 0) {
                SWIG_croak("Type error in argument 3 of Client_modify. Expected _p_p_LDAPMod");
            }
        }
        if (items > 3) {
            {
                if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                    SWIG_croak("Type error in argument 4 of Client_modify. Expected _p_p_LDAPControl");
                }
            }
        }
        if (items > 4) {
            {
                if (SWIG_ConvertPtr(ST(4), (void **) &arg5, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                    SWIG_croak("Type error in argument 5 of Client_modify. Expected _p_p_LDAPControl");
                }
            }
        }
        result = (int)ldap_modify_ext(arg1,arg2,arg3,arg4,arg5,arg6);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        {
            if (argvi >= items) {
                EXTEND(sp,1);
            }
            ST(argvi) = sv_newmortal();
            sv_setiv(ST(argvi),(IV) *(arg6));
            argvi++;
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client_modify_s) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        char *arg2 = (char *) 0 ;
        LDAPMod **arg3 = (LDAPMod **) 0 ;
        LDAPControl **arg4 = (LDAPControl **) NULL ;
        LDAPControl **arg5 = (LDAPControl **) NULL ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 5)) {
            SWIG_croak("Usage: Client_modify_s(self,dn,mods,sctrls,cctrls);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client_modify_s. Expected _p_ldap");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_p_LDAPMod,0) < 0) {
                SWIG_croak("Type error in argument 3 of Client_modify_s. Expected _p_p_LDAPMod");
            }
        }
        if (items > 3) {
            {
                if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                    SWIG_croak("Type error in argument 4 of Client_modify_s. Expected _p_p_LDAPControl");
                }
            }
        }
        if (items > 4) {
            {
                if (SWIG_ConvertPtr(ST(4), (void **) &arg5, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                    SWIG_croak("Type error in argument 5 of Client_modify_s. Expected _p_p_LDAPControl");
                }
            }
        }
        result = (int)ldap_modify_ext_s(arg1,arg2,arg3,arg4,arg5);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client_rename) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        char *arg2 = (char *) 0 ;
        char *arg3 = (char *) 0 ;
        char *arg4 = (char *) 0 ;
        int arg5 ;
        LDAPControl **arg6 = (LDAPControl **) NULL ;
        LDAPControl **arg7 = (LDAPControl **) NULL ;
        int *arg8 = (int *) 0 ;
        int result;
        int temp8 ;
        int argvi = 0;
        dXSARGS;
        
        arg8 = &temp8;
        if ((items < 5) || (items > 7)) {
            SWIG_croak("Usage: Client_rename(self,dn,new_rdn,new_superior,delete_old_rdn,sctrls,cctrls);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client_rename. Expected _p_ldap");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        if (!SvOK((SV*) ST(3))) arg4 = 0;
        else arg4 = (char *) SvPV(ST(3), PL_na);
        arg5 = (int) SvIV(ST(4));
        if (items > 5) {
            {
                if (SWIG_ConvertPtr(ST(5), (void **) &arg6, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                    SWIG_croak("Type error in argument 6 of Client_rename. Expected _p_p_LDAPControl");
                }
            }
        }
        if (items > 6) {
            {
                if (SWIG_ConvertPtr(ST(6), (void **) &arg7, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                    SWIG_croak("Type error in argument 7 of Client_rename. Expected _p_p_LDAPControl");
                }
            }
        }
        result = (int)ldap_rename(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        {
            if (argvi >= items) {
                EXTEND(sp,1);
            }
            ST(argvi) = sv_newmortal();
            sv_setiv(ST(argvi),(IV) *(arg8));
            argvi++;
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client_rename_s) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        char *arg2 = (char *) 0 ;
        char *arg3 = (char *) 0 ;
        char *arg4 = (char *) 0 ;
        int arg5 ;
        LDAPControl **arg6 = (LDAPControl **) NULL ;
        LDAPControl **arg7 = (LDAPControl **) NULL ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 5) || (items > 7)) {
            SWIG_croak("Usage: Client_rename_s(self,dn,new_rdn,new_superior,delete_old_rdn,sctrls,cctrls);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client_rename_s. Expected _p_ldap");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        if (!SvOK((SV*) ST(3))) arg4 = 0;
        else arg4 = (char *) SvPV(ST(3), PL_na);
        arg5 = (int) SvIV(ST(4));
        if (items > 5) {
            {
                if (SWIG_ConvertPtr(ST(5), (void **) &arg6, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                    SWIG_croak("Type error in argument 6 of Client_rename_s. Expected _p_p_LDAPControl");
                }
            }
        }
        if (items > 6) {
            {
                if (SWIG_ConvertPtr(ST(6), (void **) &arg7, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                    SWIG_croak("Type error in argument 7 of Client_rename_s. Expected _p_p_LDAPControl");
                }
            }
        }
        result = (int)ldap_rename_s(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Client_get_dn) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldap *arg1 = (struct ldap *) 0 ;
        LDAPMessage *arg2 = (LDAPMessage *) 0 ;
        char *result = (char *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Client_get_dn(self,entry);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldap,0) < 0) {
                SWIG_croak("Type error in argument 1 of Client_get_dn. Expected _p_ldap");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_LDAPMessage,0) < 0) {
                SWIG_croak("Type error in argument 2 of Client_get_dn. Expected _p_LDAPMessage");
            }
        }
        result = (char *)ldap_get_dn(arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        } else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_new_Message) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        char **arg1 = (char **) 0 ;
        struct ldapmsg *result = (struct ldapmsg *) 0;
        char *err1 ;
        int argvi = 0;
        dXSARGS;
        
        err1=NULL; arg1=&err1;
        if ((items < 0) || (items > 0)) {
            SWIG_croak("Usage: new_Message();");
        }
        result = (struct ldapmsg *)new_ldapmsg(arg1);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_ldapmsg, SWIG_SHADOW|SWIG_OWNER);
        if (*(arg1)) SWIG_croak(*(arg1));
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_delete_Message) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldapmsg *arg1 = (struct ldapmsg *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_Message(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldapmsg,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_Message. Expected _p_ldapmsg");
            }
        }
        delete_ldapmsg(arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Message_type) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldapmsg *arg1 = (struct ldapmsg *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Message_type(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldapmsg,0) < 0) {
                SWIG_croak("Type error in argument 1 of Message_type. Expected _p_ldapmsg");
            }
        }
        result = (int)ldapmsg_type(arg1);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Message_id) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct ldapmsg *arg1 = (struct ldapmsg *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Message_id(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ldapmsg,0) < 0) {
                SWIG_croak("Type error in argument 1 of Message_id. Expected _p_ldapmsg");
            }
        }
        result = (int)ldapmsg_id(arg1);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_BerValue_bv_len_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerValue *arg1 = (BerValue *) 0 ;
        ber_len_t arg2 ;
        BerValue temp1 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: BerValue_bv_len_set(self,bv_len);");
        }
        
        if (SvROK((SV *)(ST(0)))) {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerValue,0) < 0) {
                SWIG_croak("Type error in argument 1 of BerValue_bv_len_set. Expected _p_BerValue or string");
            }
        }
        else if (SvOK((SV *)(ST(0)))) {
            int n;
            arg1=&temp1;
            temp1.bv_val=SvPV((SV *)(ST(0)), n);
            temp1.bv_len=n;
        }
        else {
            arg1=NULL;
        }
        
        {
            ber_len_t * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_ber_len_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of BerValue_bv_len_set. Expected _p_ber_len_t");
            }
            arg2 = *argp;
        }
        if (arg1) (arg1)->bv_len = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_BerValue_bv_len_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerValue *arg1 = (BerValue *) 0 ;
        ber_len_t result;
        BerValue temp1 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: BerValue_bv_len_get(self);");
        }
        
        if (SvROK((SV *)(ST(0)))) {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerValue,0) < 0) {
                SWIG_croak("Type error in argument 1 of BerValue_bv_len_get. Expected _p_BerValue or string");
            }
        }
        else if (SvOK((SV *)(ST(0)))) {
            int n;
            arg1=&temp1;
            temp1.bv_val=SvPV((SV *)(ST(0)), n);
            temp1.bv_len=n;
        }
        else {
            arg1=NULL;
        }
        
        result =  ((arg1)->bv_len);
        
        {
            ber_len_t * resultobj = (ber_len_t *) malloc(sizeof(ber_len_t));
            memmove(resultobj, &result, sizeof(ber_len_t));
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_ber_len_t, 0|SWIG_OWNER);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_BerValue_bv_val_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerValue *arg1 = (BerValue *) 0 ;
        char *arg2 = (char *) 0 ;
        BerValue temp1 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: BerValue_bv_val_set(self,bv_val);");
        }
        
        if (SvROK((SV *)(ST(0)))) {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerValue,0) < 0) {
                SWIG_croak("Type error in argument 1 of BerValue_bv_val_set. Expected _p_BerValue or string");
            }
        }
        else if (SvOK((SV *)(ST(0)))) {
            int n;
            arg1=&temp1;
            temp1.bv_val=SvPV((SV *)(ST(0)), n);
            temp1.bv_len=n;
        }
        else {
            arg1=NULL;
        }
        
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            if (arg1->bv_val) free((char*)arg1->bv_val);
            if (arg2) {
                arg1->bv_val = (char *) malloc(strlen(arg2)+1);
                strcpy((char*)arg1->bv_val,arg2);
            } else {
                arg1->bv_val = 0;
            }
        }
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_BerValue_bv_val_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerValue *arg1 = (BerValue *) 0 ;
        char *result = (char *) 0;
        BerValue temp1 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: BerValue_bv_val_get(self);");
        }
        
        if (SvROK((SV *)(ST(0)))) {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerValue,0) < 0) {
                SWIG_croak("Type error in argument 1 of BerValue_bv_val_get. Expected _p_BerValue or string");
            }
        }
        else if (SvOK((SV *)(ST(0)))) {
            int n;
            arg1=&temp1;
            temp1.bv_val=SvPV((SV *)(ST(0)), n);
            temp1.bv_len=n;
        }
        else {
            arg1=NULL;
        }
        
        result = (char *) ((arg1)->bv_val);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        } else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_BerValue_lenght) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerValue *arg1 = (BerValue *) 0 ;
        int result;
        BerValue temp1 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: BerValue_lenght(self);");
        }
        
        if (SvROK((SV *)(ST(0)))) {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerValue,0) < 0) {
                SWIG_croak("Type error in argument 1 of BerValue_lenght. Expected _p_BerValue or string");
            }
        }
        else if (SvOK((SV *)(ST(0)))) {
            int n;
            arg1=&temp1;
            temp1.bv_val=SvPV((SV *)(ST(0)), n);
            temp1.bv_len=n;
        }
        else {
            arg1=NULL;
        }
        
        result = (int)BerValue_lenght(arg1);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_BerValue_string) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerValue *arg1 = (BerValue *) 0 ;
        char *result = (char *) 0;
        BerValue temp1 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: BerValue_string(self);");
        }
        
        if (SvROK((SV *)(ST(0)))) {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerValue,0) < 0) {
                SWIG_croak("Type error in argument 1 of BerValue_string. Expected _p_BerValue or string");
            }
        }
        else if (SvOK((SV *)(ST(0)))) {
            int n;
            arg1=&temp1;
            temp1.bv_val=SvPV((SV *)(ST(0)), n);
            temp1.bv_len=n;
        }
        else {
            arg1=NULL;
        }
        
        result = (char *)BerValue_string(arg1);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        } else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_delete_BerValue) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerValue *arg1 = (BerValue *) 0 ;
        BerValue temp1 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_BerValue(self);");
        }
        
        if (SvROK((SV *)(ST(0)))) {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerValue,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_BerValue. Expected _p_BerValue or string");
            }
        }
        else if (SvOK((SV *)(ST(0)))) {
            int n;
            arg1=&temp1;
            temp1.bv_val=SvPV((SV *)(ST(0)), n);
            temp1.bv_len=n;
        }
        else {
            arg1=NULL;
        }
        
        delete_BerValue(arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_new_BerValue) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerValue *result = (BerValue *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 0) || (items > 0)) {
            SWIG_croak("Usage: new_BerValue();");
        }
        result = (BerValue *)(BerValue *) calloc(1, sizeof(BerValue));
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_BerValue, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_error_print) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        char *arg1 = (char *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ber_error_print(data);");
        }
        if (!SvOK((SV*) ST(0))) arg1 = 0;
        else arg1 = (char *) SvPV(ST(0), PL_na);
        ber_error_print((char const *)arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_bprint) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        char *arg1 = (char *) 0 ;
        ber_len_t arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ber_bprint(data,len);");
        }
        if (!SvOK((SV*) ST(0))) arg1 = 0;
        else arg1 = (char *) SvPV(ST(0), PL_na);
        {
            ber_len_t * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_ber_len_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of ber_bprint. Expected _p_ber_len_t");
            }
            arg2 = *argp;
        }
        ber_bprint((char const *)arg1,arg2);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_dump) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerElement *arg1 = (BerElement *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ber_dump(ber,inout);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_dump. Expected _p_BerElement");
            }
        }
        arg2 = (int) SvIV(ST(1));
        ber_dump(arg1,arg2);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_sos_dump) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        Seqorset *arg1 = (Seqorset *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ber_sos_dump(sos);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Seqorset,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_sos_dump. Expected _p_Seqorset");
            }
        }
        ber_sos_dump(arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_get_tag) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerElement *arg1 = (BerElement *) 0 ;
        ber_tag_t result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ber_get_tag(ber);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_get_tag. Expected _p_BerElement");
            }
        }
        result = ber_get_tag(arg1);
        
        {
            ber_tag_t * resultobj = (ber_tag_t *) malloc(sizeof(ber_tag_t));
            memmove(resultobj, &result, sizeof(ber_tag_t));
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_ber_tag_t, 0|SWIG_OWNER);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_skip_tag) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerElement *arg1 = (BerElement *) 0 ;
        ber_len_t *arg2 = (ber_len_t *) 0 ;
        ber_tag_t result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ber_skip_tag(ber,len);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_skip_tag. Expected _p_BerElement");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_ber_len_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of ber_skip_tag. Expected _p_ber_len_t");
            }
        }
        result = ber_skip_tag(arg1,arg2);
        
        {
            ber_tag_t * resultobj = (ber_tag_t *) malloc(sizeof(ber_tag_t));
            memmove(resultobj, &result, sizeof(ber_tag_t));
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_ber_tag_t, 0|SWIG_OWNER);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_peek_tag) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerElement *arg1 = (BerElement *) 0 ;
        ber_len_t *arg2 = (ber_len_t *) 0 ;
        ber_tag_t result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ber_peek_tag(ber,len);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_peek_tag. Expected _p_BerElement");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_ber_len_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of ber_peek_tag. Expected _p_ber_len_t");
            }
        }
        result = ber_peek_tag(arg1,arg2);
        
        {
            ber_tag_t * resultobj = (ber_tag_t *) malloc(sizeof(ber_tag_t));
            memmove(resultobj, &result, sizeof(ber_tag_t));
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_ber_tag_t, 0|SWIG_OWNER);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_get_int) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerElement *arg1 = (BerElement *) 0 ;
        ber_int_t *arg2 = (ber_int_t *) 0 ;
        ber_tag_t result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ber_get_int(ber,num);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_get_int. Expected _p_BerElement");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_ber_int_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of ber_get_int. Expected _p_ber_int_t");
            }
        }
        result = ber_get_int(arg1,arg2);
        
        {
            ber_tag_t * resultobj = (ber_tag_t *) malloc(sizeof(ber_tag_t));
            memmove(resultobj, &result, sizeof(ber_tag_t));
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_ber_tag_t, 0|SWIG_OWNER);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_get_enum) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerElement *arg1 = (BerElement *) 0 ;
        ber_int_t *arg2 = (ber_int_t *) 0 ;
        ber_tag_t result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ber_get_enum(ber,num);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_get_enum. Expected _p_BerElement");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_ber_int_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of ber_get_enum. Expected _p_ber_int_t");
            }
        }
        result = ber_get_enum(arg1,arg2);
        
        {
            ber_tag_t * resultobj = (ber_tag_t *) malloc(sizeof(ber_tag_t));
            memmove(resultobj, &result, sizeof(ber_tag_t));
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_ber_tag_t, 0|SWIG_OWNER);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_get_stringb) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerElement *arg1 = (BerElement *) 0 ;
        char *arg2 = (char *) 0 ;
        ber_len_t *arg3 = (ber_len_t *) 0 ;
        ber_tag_t result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ber_get_stringb(ber,buf,len);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_get_stringb. Expected _p_BerElement");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_ber_len_t,0) < 0) {
                SWIG_croak("Type error in argument 3 of ber_get_stringb. Expected _p_ber_len_t");
            }
        }
        result = ber_get_stringb(arg1,arg2,arg3);
        
        {
            ber_tag_t * resultobj = (ber_tag_t *) malloc(sizeof(ber_tag_t));
            memmove(resultobj, &result, sizeof(ber_tag_t));
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_ber_tag_t, 0|SWIG_OWNER);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_get_stringbv) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerElement *arg1 = (BerElement *) 0 ;
        struct berval *arg2 = (struct berval *) 0 ;
        int arg3 ;
        ber_tag_t result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ber_get_stringbv(ber,bv,alloc);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_get_stringbv. Expected _p_BerElement");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 2 of ber_get_stringbv. Expected _p_berval");
            }
        }
        arg3 = (int) SvIV(ST(2));
        result = ber_get_stringbv(arg1,arg2,arg3);
        
        {
            ber_tag_t * resultobj = (ber_tag_t *) malloc(sizeof(ber_tag_t));
            memmove(resultobj, &result, sizeof(ber_tag_t));
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_ber_tag_t, 0|SWIG_OWNER);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_get_stringa) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerElement *arg1 = (BerElement *) 0 ;
        char **arg2 = (char **) 0 ;
        ber_tag_t result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ber_get_stringa(ber,buf);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_get_stringa. Expected _p_BerElement");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_p_char,0) < 0) {
                SWIG_croak("Type error in argument 2 of ber_get_stringa. Expected _p_p_char");
            }
        }
        result = ber_get_stringa(arg1,arg2);
        
        {
            ber_tag_t * resultobj = (ber_tag_t *) malloc(sizeof(ber_tag_t));
            memmove(resultobj, &result, sizeof(ber_tag_t));
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_ber_tag_t, 0|SWIG_OWNER);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_get_stringal) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerElement *arg1 = (BerElement *) 0 ;
        struct berval **arg2 = (struct berval **) 0 ;
        ber_tag_t result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ber_get_stringal(ber,bv);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_get_stringal. Expected _p_BerElement");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 2 of ber_get_stringal. Expected _p_p_berval");
            }
        }
        result = ber_get_stringal(arg1,arg2);
        
        {
            ber_tag_t * resultobj = (ber_tag_t *) malloc(sizeof(ber_tag_t));
            memmove(resultobj, &result, sizeof(ber_tag_t));
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_ber_tag_t, 0|SWIG_OWNER);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_get_bitstringa) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerElement *arg1 = (BerElement *) 0 ;
        char **arg2 = (char **) 0 ;
        ber_len_t *arg3 = (ber_len_t *) 0 ;
        ber_tag_t result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ber_get_bitstringa(ber,buf,len);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_get_bitstringa. Expected _p_BerElement");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_p_char,0) < 0) {
                SWIG_croak("Type error in argument 2 of ber_get_bitstringa. Expected _p_p_char");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_ber_len_t,0) < 0) {
                SWIG_croak("Type error in argument 3 of ber_get_bitstringa. Expected _p_ber_len_t");
            }
        }
        result = ber_get_bitstringa(arg1,arg2,arg3);
        
        {
            ber_tag_t * resultobj = (ber_tag_t *) malloc(sizeof(ber_tag_t));
            memmove(resultobj, &result, sizeof(ber_tag_t));
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_ber_tag_t, 0|SWIG_OWNER);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_get_null) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerElement *arg1 = (BerElement *) 0 ;
        ber_tag_t result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ber_get_null(ber);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_get_null. Expected _p_BerElement");
            }
        }
        result = ber_get_null(arg1);
        
        {
            ber_tag_t * resultobj = (ber_tag_t *) malloc(sizeof(ber_tag_t));
            memmove(resultobj, &result, sizeof(ber_tag_t));
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_ber_tag_t, 0|SWIG_OWNER);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_get_boolean) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerElement *arg1 = (BerElement *) 0 ;
        ber_int_t *arg2 = (ber_int_t *) 0 ;
        ber_tag_t result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ber_get_boolean(ber,boolval);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_get_boolean. Expected _p_BerElement");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_ber_int_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of ber_get_boolean. Expected _p_ber_int_t");
            }
        }
        result = ber_get_boolean(arg1,arg2);
        
        {
            ber_tag_t * resultobj = (ber_tag_t *) malloc(sizeof(ber_tag_t));
            memmove(resultobj, &result, sizeof(ber_tag_t));
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_ber_tag_t, 0|SWIG_OWNER);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_first_element) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerElement *arg1 = (BerElement *) 0 ;
        ber_len_t *arg2 = (ber_len_t *) 0 ;
        char **arg3 = (char **) 0 ;
        ber_tag_t result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ber_first_element(ber,len,last);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_first_element. Expected _p_BerElement");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_ber_len_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of ber_first_element. Expected _p_ber_len_t");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_p_char,0) < 0) {
                SWIG_croak("Type error in argument 3 of ber_first_element. Expected _p_p_char");
            }
        }
        result = ber_first_element(arg1,arg2,arg3);
        
        {
            ber_tag_t * resultobj = (ber_tag_t *) malloc(sizeof(ber_tag_t));
            memmove(resultobj, &result, sizeof(ber_tag_t));
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_ber_tag_t, 0|SWIG_OWNER);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_next_element) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerElement *arg1 = (BerElement *) 0 ;
        ber_len_t *arg2 = (ber_len_t *) 0 ;
        char *arg3 = (char *) 0 ;
        ber_tag_t result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ber_next_element(ber,len,last);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_next_element. Expected _p_BerElement");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_ber_len_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of ber_next_element. Expected _p_ber_len_t");
            }
        }
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        result = ber_next_element(arg1,arg2,(char const *)arg3);
        
        {
            ber_tag_t * resultobj = (ber_tag_t *) malloc(sizeof(ber_tag_t));
            memmove(resultobj, &result, sizeof(ber_tag_t));
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_ber_tag_t, 0|SWIG_OWNER);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_scanf) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerElement *arg1 = (BerElement *) 0 ;
        char *arg2 = (char *) 0 ;
        void *arg3 = 0 ;
        ber_tag_t result;
        int argvi = 0;
        dXSARGS;
        
        if (items < 2) {
            SWIG_croak("Usage: ber_scanf(ber,fmt,...);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_scanf. Expected _p_BerElement");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        result = ber_scanf(arg1,(char const *)arg2,arg3);
        
        {
            ber_tag_t * resultobj = (ber_tag_t *) malloc(sizeof(ber_tag_t));
            memmove(resultobj, &result, sizeof(ber_tag_t));
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_ber_tag_t, 0|SWIG_OWNER);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_put_enum) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerElement *arg1 = (BerElement *) 0 ;
        ber_int_t arg2 ;
        ber_tag_t arg3 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ber_put_enum(ber,num,tag);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_put_enum. Expected _p_BerElement");
            }
        }
        {
            ber_int_t * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_ber_int_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of ber_put_enum. Expected _p_ber_int_t");
            }
            arg2 = *argp;
        }
        {
            ber_tag_t * argp;
            if (SWIG_ConvertPtr(ST(2),(void **) &argp, SWIGTYPE_p_ber_tag_t,0) < 0) {
                SWIG_croak("Type error in argument 3 of ber_put_enum. Expected _p_ber_tag_t");
            }
            arg3 = *argp;
        }
        result = (int)ber_put_enum(arg1,arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_put_int) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerElement *arg1 = (BerElement *) 0 ;
        ber_int_t arg2 ;
        ber_tag_t arg3 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ber_put_int(ber,num,tag);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_put_int. Expected _p_BerElement");
            }
        }
        {
            ber_int_t * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_ber_int_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of ber_put_int. Expected _p_ber_int_t");
            }
            arg2 = *argp;
        }
        {
            ber_tag_t * argp;
            if (SWIG_ConvertPtr(ST(2),(void **) &argp, SWIGTYPE_p_ber_tag_t,0) < 0) {
                SWIG_croak("Type error in argument 3 of ber_put_int. Expected _p_ber_tag_t");
            }
            arg3 = *argp;
        }
        result = (int)ber_put_int(arg1,arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_put_ostring) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerElement *arg1 = (BerElement *) 0 ;
        char *arg2 = (char *) 0 ;
        ber_len_t arg3 ;
        ber_tag_t arg4 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: ber_put_ostring(ber,str,len,tag);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_put_ostring. Expected _p_BerElement");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            ber_len_t * argp;
            if (SWIG_ConvertPtr(ST(2),(void **) &argp, SWIGTYPE_p_ber_len_t,0) < 0) {
                SWIG_croak("Type error in argument 3 of ber_put_ostring. Expected _p_ber_len_t");
            }
            arg3 = *argp;
        }
        {
            ber_tag_t * argp;
            if (SWIG_ConvertPtr(ST(3),(void **) &argp, SWIGTYPE_p_ber_tag_t,0) < 0) {
                SWIG_croak("Type error in argument 4 of ber_put_ostring. Expected _p_ber_tag_t");
            }
            arg4 = *argp;
        }
        result = (int)ber_put_ostring(arg1,(char const *)arg2,arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_put_berval) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerElement *arg1 = (BerElement *) 0 ;
        struct berval *arg2 = (struct berval *) 0 ;
        ber_tag_t arg3 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ber_put_berval(ber,bv,tag);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_put_berval. Expected _p_BerElement");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 2 of ber_put_berval. Expected _p_berval");
            }
        }
        {
            ber_tag_t * argp;
            if (SWIG_ConvertPtr(ST(2),(void **) &argp, SWIGTYPE_p_ber_tag_t,0) < 0) {
                SWIG_croak("Type error in argument 3 of ber_put_berval. Expected _p_ber_tag_t");
            }
            arg3 = *argp;
        }
        result = (int)ber_put_berval(arg1,arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_put_string) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerElement *arg1 = (BerElement *) 0 ;
        char *arg2 = (char *) 0 ;
        ber_tag_t arg3 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ber_put_string(ber,str,tag);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_put_string. Expected _p_BerElement");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            ber_tag_t * argp;
            if (SWIG_ConvertPtr(ST(2),(void **) &argp, SWIGTYPE_p_ber_tag_t,0) < 0) {
                SWIG_croak("Type error in argument 3 of ber_put_string. Expected _p_ber_tag_t");
            }
            arg3 = *argp;
        }
        result = (int)ber_put_string(arg1,(char const *)arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_put_bitstring) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerElement *arg1 = (BerElement *) 0 ;
        char *arg2 = (char *) 0 ;
        ber_len_t arg3 ;
        ber_tag_t arg4 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: ber_put_bitstring(ber,str,bitlen,tag);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_put_bitstring. Expected _p_BerElement");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            ber_len_t * argp;
            if (SWIG_ConvertPtr(ST(2),(void **) &argp, SWIGTYPE_p_ber_len_t,0) < 0) {
                SWIG_croak("Type error in argument 3 of ber_put_bitstring. Expected _p_ber_len_t");
            }
            arg3 = *argp;
        }
        {
            ber_tag_t * argp;
            if (SWIG_ConvertPtr(ST(3),(void **) &argp, SWIGTYPE_p_ber_tag_t,0) < 0) {
                SWIG_croak("Type error in argument 4 of ber_put_bitstring. Expected _p_ber_tag_t");
            }
            arg4 = *argp;
        }
        result = (int)ber_put_bitstring(arg1,(char const *)arg2,arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_put_null) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerElement *arg1 = (BerElement *) 0 ;
        ber_tag_t arg2 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ber_put_null(ber,tag);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_put_null. Expected _p_BerElement");
            }
        }
        {
            ber_tag_t * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_ber_tag_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of ber_put_null. Expected _p_ber_tag_t");
            }
            arg2 = *argp;
        }
        result = (int)ber_put_null(arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_put_boolean) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerElement *arg1 = (BerElement *) 0 ;
        ber_int_t arg2 ;
        ber_tag_t arg3 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ber_put_boolean(ber,boolval,tag);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_put_boolean. Expected _p_BerElement");
            }
        }
        {
            ber_int_t * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_ber_int_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of ber_put_boolean. Expected _p_ber_int_t");
            }
            arg2 = *argp;
        }
        {
            ber_tag_t * argp;
            if (SWIG_ConvertPtr(ST(2),(void **) &argp, SWIGTYPE_p_ber_tag_t,0) < 0) {
                SWIG_croak("Type error in argument 3 of ber_put_boolean. Expected _p_ber_tag_t");
            }
            arg3 = *argp;
        }
        result = (int)ber_put_boolean(arg1,arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_start_seq) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerElement *arg1 = (BerElement *) 0 ;
        ber_tag_t arg2 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ber_start_seq(ber,tag);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_start_seq. Expected _p_BerElement");
            }
        }
        {
            ber_tag_t * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_ber_tag_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of ber_start_seq. Expected _p_ber_tag_t");
            }
            arg2 = *argp;
        }
        result = (int)ber_start_seq(arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_start_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerElement *arg1 = (BerElement *) 0 ;
        ber_tag_t arg2 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ber_start_set(ber,tag);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_start_set. Expected _p_BerElement");
            }
        }
        {
            ber_tag_t * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_ber_tag_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of ber_start_set. Expected _p_ber_tag_t");
            }
            arg2 = *argp;
        }
        result = (int)ber_start_set(arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_put_seq) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerElement *arg1 = (BerElement *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ber_put_seq(ber);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_put_seq. Expected _p_BerElement");
            }
        }
        result = (int)ber_put_seq(arg1);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_put_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerElement *arg1 = (BerElement *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ber_put_set(ber);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_put_set. Expected _p_BerElement");
            }
        }
        result = (int)ber_put_set(arg1);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_printf) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerElement *arg1 = (BerElement *) 0 ;
        char *arg2 = (char *) 0 ;
        void *arg3 = 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if (items < 2) {
            SWIG_croak("Usage: ber_printf(ber,fmt,...);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_printf. Expected _p_BerElement");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        result = (int)ber_printf(arg1,(char const *)arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_read) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerElement *arg1 = (BerElement *) 0 ;
        char *arg2 = (char *) 0 ;
        ber_len_t arg3 ;
        ber_slen_t result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ber_read(ber,buf,len);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_read. Expected _p_BerElement");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            ber_len_t * argp;
            if (SWIG_ConvertPtr(ST(2),(void **) &argp, SWIGTYPE_p_ber_len_t,0) < 0) {
                SWIG_croak("Type error in argument 3 of ber_read. Expected _p_ber_len_t");
            }
            arg3 = *argp;
        }
        result = ber_read(arg1,arg2,arg3);
        
        {
            ber_slen_t * resultobj = (ber_slen_t *) malloc(sizeof(ber_slen_t));
            memmove(resultobj, &result, sizeof(ber_slen_t));
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_ber_slen_t, 0|SWIG_OWNER);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_write) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerElement *arg1 = (BerElement *) 0 ;
        char *arg2 = (char *) 0 ;
        ber_len_t arg3 ;
        int arg4 ;
        ber_slen_t result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: ber_write(ber,buf,len,nosos);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_write. Expected _p_BerElement");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            ber_len_t * argp;
            if (SWIG_ConvertPtr(ST(2),(void **) &argp, SWIGTYPE_p_ber_len_t,0) < 0) {
                SWIG_croak("Type error in argument 3 of ber_write. Expected _p_ber_len_t");
            }
            arg3 = *argp;
        }
        arg4 = (int) SvIV(ST(3));
        result = ber_write(arg1,(char const *)arg2,arg3,arg4);
        
        {
            ber_slen_t * resultobj = (ber_slen_t *) malloc(sizeof(ber_slen_t));
            memmove(resultobj, &result, sizeof(ber_slen_t));
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_ber_slen_t, 0|SWIG_OWNER);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_free) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerElement *arg1 = (BerElement *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ber_free(ber,freebuf);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_free. Expected _p_BerElement");
            }
        }
        arg2 = (int) SvIV(ST(1));
        ber_free(arg1,arg2);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_free_buf) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerElement *arg1 = (BerElement *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ber_free_buf(ber);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_free_buf. Expected _p_BerElement");
            }
        }
        ber_free_buf(arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_flush) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        Sockbuf *arg1 = (Sockbuf *) 0 ;
        BerElement *arg2 = (BerElement *) 0 ;
        int arg3 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ber_flush(sb,ber,freeit);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Sockbuf,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_flush. Expected _p_Sockbuf");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 2 of ber_flush. Expected _p_BerElement");
            }
        }
        arg3 = (int) SvIV(ST(2));
        result = (int)ber_flush(arg1,arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_alloc) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerElement *result = (BerElement *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 0) || (items > 0)) {
            SWIG_croak("Usage: ber_alloc();");
        }
        result = (BerElement *)ber_alloc();
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_BerElement, 0|0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_der_alloc) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerElement *result = (BerElement *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 0) || (items > 0)) {
            SWIG_croak("Usage: der_alloc();");
        }
        result = (BerElement *)der_alloc();
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_BerElement, 0|0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_alloc_t) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        int arg1 ;
        BerElement *result = (BerElement *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ber_alloc_t(beroptions);");
        }
        arg1 = (int) SvIV(ST(0));
        result = (BerElement *)ber_alloc_t(arg1);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_BerElement, 0|0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_dup) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerElement *arg1 = (BerElement *) 0 ;
        BerElement *result = (BerElement *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ber_dup(ber);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_dup. Expected _p_BerElement");
            }
        }
        result = (BerElement *)ber_dup(arg1);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_BerElement, 0|0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_get_next) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        Sockbuf *arg1 = (Sockbuf *) 0 ;
        ber_len_t *arg2 = (ber_len_t *) 0 ;
        BerElement *arg3 = (BerElement *) 0 ;
        ber_tag_t result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ber_get_next(sb,len,ber);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Sockbuf,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_get_next. Expected _p_Sockbuf");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_ber_len_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of ber_get_next. Expected _p_ber_len_t");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 3 of ber_get_next. Expected _p_BerElement");
            }
        }
        result = ber_get_next(arg1,arg2,arg3);
        
        {
            ber_tag_t * resultobj = (ber_tag_t *) malloc(sizeof(ber_tag_t));
            memmove(resultobj, &result, sizeof(ber_tag_t));
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_ber_tag_t, 0|SWIG_OWNER);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_init2) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerElement *arg1 = (BerElement *) 0 ;
        struct berval *arg2 = (struct berval *) 0 ;
        int arg3 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ber_init2(ber,bv,options);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_init2. Expected _p_BerElement");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 2 of ber_init2. Expected _p_berval");
            }
        }
        arg3 = (int) SvIV(ST(2));
        ber_init2(arg1,arg2,arg3);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_init_w_nullc) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerElement *arg1 = (BerElement *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ber_init_w_nullc(ber,options);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_init_w_nullc. Expected _p_BerElement");
            }
        }
        arg2 = (int) SvIV(ST(1));
        ber_init_w_nullc(arg1,arg2);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_reset) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerElement *arg1 = (BerElement *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ber_reset(ber,was_writing);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_reset. Expected _p_BerElement");
            }
        }
        arg2 = (int) SvIV(ST(1));
        ber_reset(arg1,arg2);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_init) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct berval *arg1 = (struct berval *) 0 ;
        BerElement *result = (BerElement *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ber_init(bv);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_init. Expected _p_berval");
            }
        }
        result = (BerElement *)ber_init(arg1);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_BerElement, 0|0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_flatten) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerElement *arg1 = (BerElement *) 0 ;
        struct berval **arg2 = (struct berval **) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ber_flatten(ber,bvPtr);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_flatten. Expected _p_BerElement");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 2 of ber_flatten. Expected _p_p_berval");
            }
        }
        result = (int)ber_flatten(arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_flatten2) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerElement *arg1 = (BerElement *) 0 ;
        struct berval *arg2 = (struct berval *) 0 ;
        int arg3 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ber_flatten2(ber,bv,alloc);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_flatten2. Expected _p_BerElement");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 2 of ber_flatten2. Expected _p_berval");
            }
        }
        arg3 = (int) SvIV(ST(2));
        result = (int)ber_flatten2(arg1,arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_get_option) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        void *arg1 = (void *) 0 ;
        int arg2 ;
        void *arg3 = (void *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ber_get_option(item,option,outvalue);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, 0,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_get_option. Expected _p_void");
            }
        }
        arg2 = (int) SvIV(ST(1));
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, 0,0) < 0) {
                SWIG_croak("Type error in argument 3 of ber_get_option. Expected _p_void");
            }
        }
        result = (int)ber_get_option(arg1,arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_set_option) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        void *arg1 = (void *) 0 ;
        int arg2 ;
        void *arg3 = (void *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ber_set_option(item,option,invalue);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, 0,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_set_option. Expected _p_void");
            }
        }
        arg2 = (int) SvIV(ST(1));
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, 0,0) < 0) {
                SWIG_croak("Type error in argument 3 of ber_set_option. Expected _p_void");
            }
        }
        result = (int)ber_set_option(arg1,arg2,(void const *)arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_sockbuf_alloc) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        Sockbuf *result = (Sockbuf *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 0) || (items > 0)) {
            SWIG_croak("Usage: ber_sockbuf_alloc();");
        }
        result = (Sockbuf *)ber_sockbuf_alloc();
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Sockbuf, 0|0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_sockbuf_free) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        Sockbuf *arg1 = (Sockbuf *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ber_sockbuf_free(sb);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Sockbuf,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_sockbuf_free. Expected _p_Sockbuf");
            }
        }
        ber_sockbuf_free(arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_sockbuf_add_io) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        Sockbuf *arg1 = (Sockbuf *) 0 ;
        Sockbuf_IO *arg2 = (Sockbuf_IO *) 0 ;
        int arg3 ;
        void *arg4 = (void *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: ber_sockbuf_add_io(sb,sbio,layer,arg);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Sockbuf,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_sockbuf_add_io. Expected _p_Sockbuf");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_Sockbuf_IO,0) < 0) {
                SWIG_croak("Type error in argument 2 of ber_sockbuf_add_io. Expected _p_Sockbuf_IO");
            }
        }
        arg3 = (int) SvIV(ST(2));
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, 0,0) < 0) {
                SWIG_croak("Type error in argument 4 of ber_sockbuf_add_io. Expected _p_void");
            }
        }
        result = (int)ber_sockbuf_add_io(arg1,arg2,arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_sockbuf_remove_io) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        Sockbuf *arg1 = (Sockbuf *) 0 ;
        Sockbuf_IO *arg2 = (Sockbuf_IO *) 0 ;
        int arg3 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ber_sockbuf_remove_io(sb,sbio,layer);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Sockbuf,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_sockbuf_remove_io. Expected _p_Sockbuf");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_Sockbuf_IO,0) < 0) {
                SWIG_croak("Type error in argument 2 of ber_sockbuf_remove_io. Expected _p_Sockbuf_IO");
            }
        }
        arg3 = (int) SvIV(ST(2));
        result = (int)ber_sockbuf_remove_io(arg1,arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_sockbuf_ctrl) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        Sockbuf *arg1 = (Sockbuf *) 0 ;
        int arg2 ;
        void *arg3 = (void *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ber_sockbuf_ctrl(sb,opt,arg);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Sockbuf,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_sockbuf_ctrl. Expected _p_Sockbuf");
            }
        }
        arg2 = (int) SvIV(ST(1));
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, 0,0) < 0) {
                SWIG_croak("Type error in argument 3 of ber_sockbuf_ctrl. Expected _p_void");
            }
        }
        result = (int)ber_sockbuf_ctrl(arg1,arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_bvarray_add) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerVarray *arg1 = (BerVarray *) 0 ;
        BerValue *arg2 = (BerValue *) 0 ;
        int result;
        BerValue temp2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ber_bvarray_add(p,bv);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerVarray,0) < 0) {
                SWIG_croak("Type error in argument 1 of ber_bvarray_add. Expected _p_BerVarray");
            }
        }
        
        if (SvROK((SV *)(ST(1)))) {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_BerValue,0) < 0) {
                SWIG_croak("Type error in argument 2 of ber_bvarray_add. Expected _p_BerValue or string");
            }
        }
        else if (SvOK((SV *)(ST(1)))) {
            int n;
            arg2=&temp2;
            temp2.bv_val=SvPV((SV *)(ST(1)), n);
            temp2.bv_len=n;
        }
        else {
            arg2=NULL;
        }
        
        result = (int)ber_bvarray_add(arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ber_errno_addr) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        int *result = (int *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 0) || (items > 0)) {
            SWIG_croak("Usage: ber_errno_addr();");
        }
        result = (int *)ber_errno_addr();
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_int, 0|0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_APIInfo_ldapai_info_version_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPAPIInfo *arg1 = (LDAPAPIInfo *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: APIInfo_ldapai_info_version_set(self,ldapai_info_version);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPAPIInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of APIInfo_ldapai_info_version_set. Expected _p_LDAPAPIInfo");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->ldapai_info_version = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_APIInfo_ldapai_info_version_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPAPIInfo *arg1 = (LDAPAPIInfo *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: APIInfo_ldapai_info_version_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPAPIInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of APIInfo_ldapai_info_version_get. Expected _p_LDAPAPIInfo");
            }
        }
        result = (int) ((arg1)->ldapai_info_version);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_APIInfo_ldapai_api_version_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPAPIInfo *arg1 = (LDAPAPIInfo *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: APIInfo_ldapai_api_version_set(self,ldapai_api_version);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPAPIInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of APIInfo_ldapai_api_version_set. Expected _p_LDAPAPIInfo");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->ldapai_api_version = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_APIInfo_ldapai_api_version_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPAPIInfo *arg1 = (LDAPAPIInfo *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: APIInfo_ldapai_api_version_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPAPIInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of APIInfo_ldapai_api_version_get. Expected _p_LDAPAPIInfo");
            }
        }
        result = (int) ((arg1)->ldapai_api_version);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_APIInfo_ldapai_protocol_version_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPAPIInfo *arg1 = (LDAPAPIInfo *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: APIInfo_ldapai_protocol_version_set(self,ldapai_protocol_version);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPAPIInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of APIInfo_ldapai_protocol_version_set. Expected _p_LDAPAPIInfo");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->ldapai_protocol_version = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_APIInfo_ldapai_protocol_version_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPAPIInfo *arg1 = (LDAPAPIInfo *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: APIInfo_ldapai_protocol_version_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPAPIInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of APIInfo_ldapai_protocol_version_get. Expected _p_LDAPAPIInfo");
            }
        }
        result = (int) ((arg1)->ldapai_protocol_version);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_APIInfo_ldapai_extensions_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPAPIInfo *arg1 = (LDAPAPIInfo *) 0 ;
        char **arg2 = (char **) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: APIInfo_ldapai_extensions_set(self,ldapai_extensions);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPAPIInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of APIInfo_ldapai_extensions_set. Expected _p_LDAPAPIInfo");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_p_char,0) < 0) {
                SWIG_croak("Type error in argument 2 of APIInfo_ldapai_extensions_set. Expected _p_p_char");
            }
        }
        if (arg1) (arg1)->ldapai_extensions = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_APIInfo_ldapai_extensions_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPAPIInfo *arg1 = (LDAPAPIInfo *) 0 ;
        char **result = (char **) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: APIInfo_ldapai_extensions_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPAPIInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of APIInfo_ldapai_extensions_get. Expected _p_LDAPAPIInfo");
            }
        }
        result = (char **) ((arg1)->ldapai_extensions);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_p_char, 0|0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_APIInfo_ldapai_vendor_name_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPAPIInfo *arg1 = (LDAPAPIInfo *) 0 ;
        char *arg2 = (char *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: APIInfo_ldapai_vendor_name_set(self,ldapai_vendor_name);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPAPIInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of APIInfo_ldapai_vendor_name_set. Expected _p_LDAPAPIInfo");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            if (arg1->ldapai_vendor_name) free((char*)arg1->ldapai_vendor_name);
            if (arg2) {
                arg1->ldapai_vendor_name = (char *) malloc(strlen(arg2)+1);
                strcpy((char*)arg1->ldapai_vendor_name,arg2);
            } else {
                arg1->ldapai_vendor_name = 0;
            }
        }
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_APIInfo_ldapai_vendor_name_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPAPIInfo *arg1 = (LDAPAPIInfo *) 0 ;
        char *result = (char *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: APIInfo_ldapai_vendor_name_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPAPIInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of APIInfo_ldapai_vendor_name_get. Expected _p_LDAPAPIInfo");
            }
        }
        result = (char *) ((arg1)->ldapai_vendor_name);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        } else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_APIInfo_ldapai_vendor_version_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPAPIInfo *arg1 = (LDAPAPIInfo *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: APIInfo_ldapai_vendor_version_set(self,ldapai_vendor_version);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPAPIInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of APIInfo_ldapai_vendor_version_set. Expected _p_LDAPAPIInfo");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->ldapai_vendor_version = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_APIInfo_ldapai_vendor_version_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPAPIInfo *arg1 = (LDAPAPIInfo *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: APIInfo_ldapai_vendor_version_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPAPIInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of APIInfo_ldapai_vendor_version_get. Expected _p_LDAPAPIInfo");
            }
        }
        result = (int) ((arg1)->ldapai_vendor_version);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_APIInfo_info_version) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPAPIInfo *arg1 = (LDAPAPIInfo *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: APIInfo_info_version(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPAPIInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of APIInfo_info_version. Expected _p_LDAPAPIInfo");
            }
        }
        result = (int)LDAPAPIInfo_info_version(arg1);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_APIInfo_api_version) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPAPIInfo *arg1 = (LDAPAPIInfo *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: APIInfo_api_version(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPAPIInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of APIInfo_api_version. Expected _p_LDAPAPIInfo");
            }
        }
        result = (int)LDAPAPIInfo_api_version(arg1);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_APIInfo_protocol_version) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPAPIInfo *arg1 = (LDAPAPIInfo *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: APIInfo_protocol_version(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPAPIInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of APIInfo_protocol_version. Expected _p_LDAPAPIInfo");
            }
        }
        result = (int)LDAPAPIInfo_protocol_version(arg1);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_APIInfo_extensions) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPAPIInfo *arg1 = (LDAPAPIInfo *) 0 ;
        PUSHPPchar result = (PUSHPPchar) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: APIInfo_extensions(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPAPIInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of APIInfo_extensions. Expected _p_LDAPAPIInfo");
            }
        }
        result = (PUSHPPchar)LDAPAPIInfo_extensions(arg1);
        
        
        if (result) {
            char **p;
            for (p=result; *p; p++) {
                if(argvi >= items) EXTEND(sp, 1);
                ST(argvi) = sv_2mortal(newSVpv(*p, 0));
                argvi++;
            }
        }
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_APIInfo_vendor_name) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPAPIInfo *arg1 = (LDAPAPIInfo *) 0 ;
        char *result = (char *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: APIInfo_vendor_name(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPAPIInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of APIInfo_vendor_name. Expected _p_LDAPAPIInfo");
            }
        }
        result = (char *)LDAPAPIInfo_vendor_name(arg1);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        } else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_APIInfo_vendor_version) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPAPIInfo *arg1 = (LDAPAPIInfo *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: APIInfo_vendor_version(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPAPIInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of APIInfo_vendor_version. Expected _p_LDAPAPIInfo");
            }
        }
        result = (int)LDAPAPIInfo_vendor_version(arg1);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_new_APIInfo) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPAPIInfo *result = (LDAPAPIInfo *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 0) || (items > 0)) {
            SWIG_croak("Usage: new_APIInfo();");
        }
        result = (LDAPAPIInfo *)(LDAPAPIInfo *) calloc(1, sizeof(LDAPAPIInfo));
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_LDAPAPIInfo, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_delete_APIInfo) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPAPIInfo *arg1 = (LDAPAPIInfo *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_APIInfo(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPAPIInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_APIInfo. Expected _p_LDAPAPIInfo");
            }
        }
        free((char *) arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_APIFeatureInfo_ldapaif_info_version_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPAPIFeatureInfo *arg1 = (LDAPAPIFeatureInfo *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: APIFeatureInfo_ldapaif_info_version_set(self,ldapaif_info_version);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPAPIFeatureInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of APIFeatureInfo_ldapaif_info_version_set. Expected _p_LDAPAPIFeatureInfo");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->ldapaif_info_version = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_APIFeatureInfo_ldapaif_info_version_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPAPIFeatureInfo *arg1 = (LDAPAPIFeatureInfo *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: APIFeatureInfo_ldapaif_info_version_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPAPIFeatureInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of APIFeatureInfo_ldapaif_info_version_get. Expected _p_LDAPAPIFeatureInfo");
            }
        }
        result = (int) ((arg1)->ldapaif_info_version);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_APIFeatureInfo_ldapaif_name_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPAPIFeatureInfo *arg1 = (LDAPAPIFeatureInfo *) 0 ;
        char *arg2 = (char *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: APIFeatureInfo_ldapaif_name_set(self,ldapaif_name);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPAPIFeatureInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of APIFeatureInfo_ldapaif_name_set. Expected _p_LDAPAPIFeatureInfo");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            if (arg1->ldapaif_name) free((char*)arg1->ldapaif_name);
            if (arg2) {
                arg1->ldapaif_name = (char *) malloc(strlen(arg2)+1);
                strcpy((char*)arg1->ldapaif_name,arg2);
            } else {
                arg1->ldapaif_name = 0;
            }
        }
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_APIFeatureInfo_ldapaif_name_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPAPIFeatureInfo *arg1 = (LDAPAPIFeatureInfo *) 0 ;
        char *result = (char *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: APIFeatureInfo_ldapaif_name_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPAPIFeatureInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of APIFeatureInfo_ldapaif_name_get. Expected _p_LDAPAPIFeatureInfo");
            }
        }
        result = (char *) ((arg1)->ldapaif_name);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        } else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_APIFeatureInfo_ldapaif_version_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPAPIFeatureInfo *arg1 = (LDAPAPIFeatureInfo *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: APIFeatureInfo_ldapaif_version_set(self,ldapaif_version);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPAPIFeatureInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of APIFeatureInfo_ldapaif_version_set. Expected _p_LDAPAPIFeatureInfo");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->ldapaif_version = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_APIFeatureInfo_ldapaif_version_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPAPIFeatureInfo *arg1 = (LDAPAPIFeatureInfo *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: APIFeatureInfo_ldapaif_version_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPAPIFeatureInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of APIFeatureInfo_ldapaif_version_get. Expected _p_LDAPAPIFeatureInfo");
            }
        }
        result = (int) ((arg1)->ldapaif_version);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_APIFeatureInfo_info_version) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPAPIFeatureInfo *arg1 = (LDAPAPIFeatureInfo *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: APIFeatureInfo_info_version(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPAPIFeatureInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of APIFeatureInfo_info_version. Expected _p_LDAPAPIFeatureInfo");
            }
        }
        result = (int)LDAPAPIFeatureInfo_info_version(arg1);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_APIFeatureInfo_name) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPAPIFeatureInfo *arg1 = (LDAPAPIFeatureInfo *) 0 ;
        char *result = (char *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: APIFeatureInfo_name(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPAPIFeatureInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of APIFeatureInfo_name. Expected _p_LDAPAPIFeatureInfo");
            }
        }
        result = (char *)LDAPAPIFeatureInfo_name(arg1);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        } else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_APIFeatureInfo_version) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPAPIFeatureInfo *arg1 = (LDAPAPIFeatureInfo *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: APIFeatureInfo_version(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPAPIFeatureInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of APIFeatureInfo_version. Expected _p_LDAPAPIFeatureInfo");
            }
        }
        result = (int)LDAPAPIFeatureInfo_version(arg1);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_delete_APIFeatureInfo) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPAPIFeatureInfo *arg1 = (LDAPAPIFeatureInfo *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_APIFeatureInfo(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPAPIFeatureInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_APIFeatureInfo. Expected _p_LDAPAPIFeatureInfo");
            }
        }
        delete_LDAPAPIFeatureInfo(arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_new_APIFeatureInfo) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPAPIFeatureInfo *result = (LDAPAPIFeatureInfo *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 0) || (items > 0)) {
            SWIG_croak("Usage: new_APIFeatureInfo();");
        }
        result = (LDAPAPIFeatureInfo *)(LDAPAPIFeatureInfo *) calloc(1, sizeof(LDAPAPIFeatureInfo));
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_LDAPAPIFeatureInfo, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_new_Control) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        char *arg1 = (char *) 0 ;
        BerValue *arg2 = (BerValue *) 0 ;
        int arg3 ;
        LDAPControl *result = (LDAPControl *) 0;
        BerValue temp2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: new_Control(oid,bv,critical);");
        }
        if (!SvOK((SV*) ST(0))) arg1 = 0;
        else arg1 = (char *) SvPV(ST(0), PL_na);
        
        if (SvROK((SV *)(ST(1)))) {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_BerValue,0) < 0) {
                SWIG_croak("Type error in argument 2 of new_Control. Expected _p_BerValue or string");
            }
        }
        else if (SvOK((SV *)(ST(1)))) {
            int n;
            arg2=&temp2;
            temp2.bv_val=SvPV((SV *)(ST(1)), n);
            temp2.bv_len=n;
        }
        else {
            arg2=NULL;
        }
        
        arg3 = (int) SvIV(ST(2));
        result = (LDAPControl *)new_LDAPControl(arg1,arg2,arg3);
        
        
        LDAPControl2PERL_COPY(ST(argvi++), (void *)(result),
        SWIGTYPE_p_LDAPControl, SWIG_SHADOW|SWIG_OWNER);
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_delete_Control) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPControl *arg1 = (LDAPControl *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_Control(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_Control. Expected _p_LDAPControl");
            }
        }
        delete_LDAPControl(arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Control_oid) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPControl *arg1 = (LDAPControl *) 0 ;
        char *result = (char *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Control_oid(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 1 of Control_oid. Expected _p_LDAPControl");
            }
        }
        result = (char *)LDAPControl_oid(arg1);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        } else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Control_value) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPControl *arg1 = (LDAPControl *) 0 ;
        BerValue result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Control_value(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 1 of Control_value. Expected _p_LDAPControl");
            }
        }
        result = LDAPControl_value(arg1);
        
        {
            if ((result).bv_val)
            ST(argvi) = sv_2mortal(newSVpvn((result).bv_val, (result).bv_len));
            else
            ST(argvi) = &PL_sv_undef;
            argvi++;
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Control_critical) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPControl *arg1 = (LDAPControl *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Control_critical(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 1 of Control_critical. Expected _p_LDAPControl");
            }
        }
        result = (int)LDAPControl_critical(arg1);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_new_Mod) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        int arg1 ;
        char *arg2 = (char *) 0 ;
        SV *arg3 = (SV *) 0 ;
        char **arg4 = (char **) 0 ;
        LDAPMod *result = (LDAPMod *) 0;
        char *err4 ;
        int argvi = 0;
        dXSARGS;
        
        err4=NULL; arg4=&err4;
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: new_Mod(op,type,array);");
        }
        arg1 = (int) SvIV(ST(0));
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_SV,0) < 0) {
                SWIG_croak("Type error in argument 3 of new_Mod. Expected _p_SV");
            }
        }
        result = (LDAPMod *)new_LDAPMod(arg1,arg2,arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_LDAPMod, SWIG_SHADOW|SWIG_OWNER);
        if (*(arg4)) SWIG_croak(*(arg4));
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_delete_Mod) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPMod *arg1 = (LDAPMod *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_Mod(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPMod,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_Mod. Expected _p_LDAPMod");
            }
        }
        delete_LDAPMod(arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Mod_op) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPMod *arg1 = (LDAPMod *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Mod_op(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPMod,0) < 0) {
                SWIG_croak("Type error in argument 1 of Mod_op. Expected _p_LDAPMod");
            }
        }
        result = (int)LDAPMod_op(arg1);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Mod_type) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPMod *arg1 = (LDAPMod *) 0 ;
        char *result = (char *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Mod_type(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPMod,0) < 0) {
                SWIG_croak("Type error in argument 1 of Mod_type. Expected _p_LDAPMod");
            }
        }
        result = (char *)LDAPMod_type(arg1);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        } else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_Mod_values) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPMod *arg1 = (LDAPMod *) 0 ;
        BerValue **result = (BerValue **) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Mod_values(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPMod,0) < 0) {
                SWIG_croak("Type error in argument 1 of Mod_values. Expected _p_LDAPMod");
            }
        }
        result = (BerValue **)LDAPMod_values(arg1);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_p_BerValue, 0|0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_LDAPMod_mod_vals_modv_strvals_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPMod_mod_vals *arg1 = (LDAPMod_mod_vals *) 0 ;
        char **arg2 = (char **) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: LDAPMod_mod_vals_modv_strvals_set(self,modv_strvals);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPMod_mod_vals,0) < 0) {
                SWIG_croak("Type error in argument 1 of LDAPMod_mod_vals_modv_strvals_set. Expected _p_LDAPMod_mod_vals");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_p_char,0) < 0) {
                SWIG_croak("Type error in argument 2 of LDAPMod_mod_vals_modv_strvals_set. Expected _p_p_char");
            }
        }
        if (arg1) (arg1)->modv_strvals = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_LDAPMod_mod_vals_modv_strvals_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPMod_mod_vals *arg1 = (LDAPMod_mod_vals *) 0 ;
        char **result = (char **) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: LDAPMod_mod_vals_modv_strvals_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPMod_mod_vals,0) < 0) {
                SWIG_croak("Type error in argument 1 of LDAPMod_mod_vals_modv_strvals_get. Expected _p_LDAPMod_mod_vals");
            }
        }
        result = (char **) ((arg1)->modv_strvals);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_p_char, 0|0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_LDAPMod_mod_vals_modv_bvals_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPMod_mod_vals *arg1 = (LDAPMod_mod_vals *) 0 ;
        struct berval **arg2 = (struct berval **) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: LDAPMod_mod_vals_modv_bvals_set(self,modv_bvals);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPMod_mod_vals,0) < 0) {
                SWIG_croak("Type error in argument 1 of LDAPMod_mod_vals_modv_bvals_set. Expected _p_LDAPMod_mod_vals");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 2 of LDAPMod_mod_vals_modv_bvals_set. Expected _p_p_berval");
            }
        }
        if (arg1) (arg1)->modv_bvals = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_LDAPMod_mod_vals_modv_bvals_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPMod_mod_vals *arg1 = (LDAPMod_mod_vals *) 0 ;
        struct berval **result = (struct berval **) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: LDAPMod_mod_vals_modv_bvals_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPMod_mod_vals,0) < 0) {
                SWIG_croak("Type error in argument 1 of LDAPMod_mod_vals_modv_bvals_get. Expected _p_LDAPMod_mod_vals");
            }
        }
        result = (struct berval **) ((arg1)->modv_bvals);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_p_berval, 0|0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_new_LDAPMod_mod_vals) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPMod_mod_vals *result = (LDAPMod_mod_vals *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 0) || (items > 0)) {
            SWIG_croak("Usage: new_LDAPMod_mod_vals();");
        }
        result = (LDAPMod_mod_vals *)(LDAPMod_mod_vals *) calloc(1, sizeof(LDAPMod_mod_vals));
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_LDAPMod_mod_vals, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_delete_LDAPMod_mod_vals) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPMod_mod_vals *arg1 = (LDAPMod_mod_vals *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_LDAPMod_mod_vals(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPMod_mod_vals,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_LDAPMod_mod_vals. Expected _p_LDAPMod_mod_vals");
            }
        }
        free((char *) arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_URLDesc_lud_next_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPURLDesc *arg1 = (LDAPURLDesc *) 0 ;
        struct ldap_url_desc *arg2 = (struct ldap_url_desc *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: URLDesc_lud_next_set(self,lud_next);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPURLDesc,0) < 0) {
                SWIG_croak("Type error in argument 1 of URLDesc_lud_next_set. Expected _p_LDAPURLDesc");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_ldap_url_desc,0) < 0) {
                SWIG_croak("Type error in argument 2 of URLDesc_lud_next_set. Expected _p_ldap_url_desc");
            }
        }
        if (arg1) (arg1)->lud_next = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_URLDesc_lud_next_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPURLDesc *arg1 = (LDAPURLDesc *) 0 ;
        struct ldap_url_desc *result = (struct ldap_url_desc *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: URLDesc_lud_next_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPURLDesc,0) < 0) {
                SWIG_croak("Type error in argument 1 of URLDesc_lud_next_get. Expected _p_LDAPURLDesc");
            }
        }
        result = (struct ldap_url_desc *) ((arg1)->lud_next);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_ldap_url_desc, SWIG_SHADOW|0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_URLDesc_lud_scheme_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPURLDesc *arg1 = (LDAPURLDesc *) 0 ;
        char *arg2 = (char *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: URLDesc_lud_scheme_set(self,lud_scheme);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPURLDesc,0) < 0) {
                SWIG_croak("Type error in argument 1 of URLDesc_lud_scheme_set. Expected _p_LDAPURLDesc");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            if (arg1->lud_scheme) free((char*)arg1->lud_scheme);
            if (arg2) {
                arg1->lud_scheme = (char *) malloc(strlen(arg2)+1);
                strcpy((char*)arg1->lud_scheme,arg2);
            } else {
                arg1->lud_scheme = 0;
            }
        }
        
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_URLDesc_lud_scheme_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPURLDesc *arg1 = (LDAPURLDesc *) 0 ;
        char *result = (char *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: URLDesc_lud_scheme_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPURLDesc,0) < 0) {
                SWIG_croak("Type error in argument 1 of URLDesc_lud_scheme_get. Expected _p_LDAPURLDesc");
            }
        }
        result = (char *) ((arg1)->lud_scheme);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        } else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_URLDesc_lud_host_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPURLDesc *arg1 = (LDAPURLDesc *) 0 ;
        char *arg2 = (char *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: URLDesc_lud_host_set(self,lud_host);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPURLDesc,0) < 0) {
                SWIG_croak("Type error in argument 1 of URLDesc_lud_host_set. Expected _p_LDAPURLDesc");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            if (arg1->lud_host) free((char*)arg1->lud_host);
            if (arg2) {
                arg1->lud_host = (char *) malloc(strlen(arg2)+1);
                strcpy((char*)arg1->lud_host,arg2);
            } else {
                arg1->lud_host = 0;
            }
        }
        
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_URLDesc_lud_host_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPURLDesc *arg1 = (LDAPURLDesc *) 0 ;
        char *result = (char *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: URLDesc_lud_host_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPURLDesc,0) < 0) {
                SWIG_croak("Type error in argument 1 of URLDesc_lud_host_get. Expected _p_LDAPURLDesc");
            }
        }
        result = (char *) ((arg1)->lud_host);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        } else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_URLDesc_lud_port_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPURLDesc *arg1 = (LDAPURLDesc *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: URLDesc_lud_port_set(self,lud_port);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPURLDesc,0) < 0) {
                SWIG_croak("Type error in argument 1 of URLDesc_lud_port_set. Expected _p_LDAPURLDesc");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->lud_port = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_URLDesc_lud_port_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPURLDesc *arg1 = (LDAPURLDesc *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: URLDesc_lud_port_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPURLDesc,0) < 0) {
                SWIG_croak("Type error in argument 1 of URLDesc_lud_port_get. Expected _p_LDAPURLDesc");
            }
        }
        result = (int) ((arg1)->lud_port);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_URLDesc_lud_dn_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPURLDesc *arg1 = (LDAPURLDesc *) 0 ;
        char *arg2 = (char *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: URLDesc_lud_dn_set(self,lud_dn);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPURLDesc,0) < 0) {
                SWIG_croak("Type error in argument 1 of URLDesc_lud_dn_set. Expected _p_LDAPURLDesc");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            if (arg1->lud_dn) free((char*)arg1->lud_dn);
            if (arg2) {
                arg1->lud_dn = (char *) malloc(strlen(arg2)+1);
                strcpy((char*)arg1->lud_dn,arg2);
            } else {
                arg1->lud_dn = 0;
            }
        }
        
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_URLDesc_lud_dn_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPURLDesc *arg1 = (LDAPURLDesc *) 0 ;
        char *result = (char *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: URLDesc_lud_dn_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPURLDesc,0) < 0) {
                SWIG_croak("Type error in argument 1 of URLDesc_lud_dn_get. Expected _p_LDAPURLDesc");
            }
        }
        result = (char *) ((arg1)->lud_dn);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        } else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_URLDesc_lud_attrs_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPURLDesc *arg1 = (LDAPURLDesc *) 0 ;
        char **arg2 = (char **) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: URLDesc_lud_attrs_set(self,lud_attrs);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPURLDesc,0) < 0) {
                SWIG_croak("Type error in argument 1 of URLDesc_lud_attrs_set. Expected _p_LDAPURLDesc");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_p_char,0) < 0) {
                SWIG_croak("Type error in argument 2 of URLDesc_lud_attrs_set. Expected _p_p_char");
            }
        }
        if (arg1) (arg1)->lud_attrs = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_URLDesc_lud_attrs_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPURLDesc *arg1 = (LDAPURLDesc *) 0 ;
        char **result = (char **) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: URLDesc_lud_attrs_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPURLDesc,0) < 0) {
                SWIG_croak("Type error in argument 1 of URLDesc_lud_attrs_get. Expected _p_LDAPURLDesc");
            }
        }
        result = (char **) ((arg1)->lud_attrs);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_p_char, 0|0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_URLDesc_lud_scope_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPURLDesc *arg1 = (LDAPURLDesc *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: URLDesc_lud_scope_set(self,lud_scope);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPURLDesc,0) < 0) {
                SWIG_croak("Type error in argument 1 of URLDesc_lud_scope_set. Expected _p_LDAPURLDesc");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->lud_scope = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_URLDesc_lud_scope_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPURLDesc *arg1 = (LDAPURLDesc *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: URLDesc_lud_scope_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPURLDesc,0) < 0) {
                SWIG_croak("Type error in argument 1 of URLDesc_lud_scope_get. Expected _p_LDAPURLDesc");
            }
        }
        result = (int) ((arg1)->lud_scope);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_URLDesc_lud_filter_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPURLDesc *arg1 = (LDAPURLDesc *) 0 ;
        char *arg2 = (char *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: URLDesc_lud_filter_set(self,lud_filter);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPURLDesc,0) < 0) {
                SWIG_croak("Type error in argument 1 of URLDesc_lud_filter_set. Expected _p_LDAPURLDesc");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            if (arg1->lud_filter) free((char*)arg1->lud_filter);
            if (arg2) {
                arg1->lud_filter = (char *) malloc(strlen(arg2)+1);
                strcpy((char*)arg1->lud_filter,arg2);
            } else {
                arg1->lud_filter = 0;
            }
        }
        
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_URLDesc_lud_filter_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPURLDesc *arg1 = (LDAPURLDesc *) 0 ;
        char *result = (char *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: URLDesc_lud_filter_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPURLDesc,0) < 0) {
                SWIG_croak("Type error in argument 1 of URLDesc_lud_filter_get. Expected _p_LDAPURLDesc");
            }
        }
        result = (char *) ((arg1)->lud_filter);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        } else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_URLDesc_lud_exts_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPURLDesc *arg1 = (LDAPURLDesc *) 0 ;
        char **arg2 = (char **) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: URLDesc_lud_exts_set(self,lud_exts);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPURLDesc,0) < 0) {
                SWIG_croak("Type error in argument 1 of URLDesc_lud_exts_set. Expected _p_LDAPURLDesc");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_p_char,0) < 0) {
                SWIG_croak("Type error in argument 2 of URLDesc_lud_exts_set. Expected _p_p_char");
            }
        }
        if (arg1) (arg1)->lud_exts = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_URLDesc_lud_exts_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPURLDesc *arg1 = (LDAPURLDesc *) 0 ;
        char **result = (char **) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: URLDesc_lud_exts_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPURLDesc,0) < 0) {
                SWIG_croak("Type error in argument 1 of URLDesc_lud_exts_get. Expected _p_LDAPURLDesc");
            }
        }
        result = (char **) ((arg1)->lud_exts);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_p_char, 0|0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_URLDesc_lud_crit_exts_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPURLDesc *arg1 = (LDAPURLDesc *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: URLDesc_lud_crit_exts_set(self,lud_crit_exts);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPURLDesc,0) < 0) {
                SWIG_croak("Type error in argument 1 of URLDesc_lud_crit_exts_set. Expected _p_LDAPURLDesc");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->lud_crit_exts = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_URLDesc_lud_crit_exts_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPURLDesc *arg1 = (LDAPURLDesc *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: URLDesc_lud_crit_exts_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPURLDesc,0) < 0) {
                SWIG_croak("Type error in argument 1 of URLDesc_lud_crit_exts_get. Expected _p_LDAPURLDesc");
            }
        }
        result = (int) ((arg1)->lud_crit_exts);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_new_URLDesc) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPURLDesc *result = (LDAPURLDesc *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 0) || (items > 0)) {
            SWIG_croak("Usage: new_URLDesc();");
        }
        result = (LDAPURLDesc *)(LDAPURLDesc *) calloc(1, sizeof(LDAPURLDesc));
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_LDAPURLDesc, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_delete_URLDesc) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPURLDesc *arg1 = (LDAPURLDesc *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_URLDesc(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPURLDesc,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_URLDesc. Expected _p_LDAPURLDesc");
            }
        }
        free((char *) arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_set_rebind_proc) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        LDAP_REBIND_PROC *arg2 = (LDAP_REBIND_PROC *) 0 ;
        void *arg3 = (void *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ldap_set_rebind_proc(ld,rebind_proc,params);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_set_rebind_proc. Expected _p_LDAP");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_LDAP_REBIND_PROC,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_set_rebind_proc. Expected _p_LDAP_REBIND_PROC");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, 0,0) < 0) {
                SWIG_croak("Type error in argument 3 of ldap_set_rebind_proc. Expected _p_void");
            }
        }
        result = (int)ldap_set_rebind_proc(arg1,arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_domain2dn) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        char *arg1 = (char *) 0 ;
        char **arg2 = (char **) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ldap_domain2dn(domain,dn);");
        }
        if (!SvOK((SV*) ST(0))) arg1 = 0;
        else arg1 = (char *) SvPV(ST(0), PL_na);
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_p_char,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_domain2dn. Expected _p_p_char");
            }
        }
        result = (int)ldap_domain2dn((char const *)arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_dn2domain) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        char *arg1 = (char *) 0 ;
        char **arg2 = (char **) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ldap_dn2domain(dn,domain);");
        }
        if (!SvOK((SV*) ST(0))) arg1 = 0;
        else arg1 = (char *) SvPV(ST(0), PL_na);
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_p_char,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_dn2domain. Expected _p_p_char");
            }
        }
        result = (int)ldap_dn2domain((char const *)arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_domain2hostlist) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        char *arg1 = (char *) 0 ;
        char **arg2 = (char **) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ldap_domain2hostlist(domain,hostlist);");
        }
        if (!SvOK((SV*) ST(0))) arg1 = 0;
        else arg1 = (char *) SvPV(ST(0), PL_na);
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_p_char,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_domain2hostlist. Expected _p_p_char");
            }
        }
        result = (int)ldap_domain2hostlist((char const *)arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_extended_operation) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        char *arg2 = (char *) 0 ;
        struct berval *arg3 = (struct berval *) 0 ;
        LDAPControl **arg4 = (LDAPControl **) 0 ;
        LDAPControl **arg5 = (LDAPControl **) 0 ;
        int *arg6 = (int *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 6) || (items > 6)) {
            SWIG_croak("Usage: ldap_extended_operation(ld,reqoid,reqdata,serverctrls,clientctrls,msgidp);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_extended_operation. Expected _p_LDAP");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 3 of ldap_extended_operation. Expected _p_berval");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 4 of ldap_extended_operation. Expected _p_p_LDAPControl");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(4), (void **) &arg5, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 5 of ldap_extended_operation. Expected _p_p_LDAPControl");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(5), (void **) &arg6, SWIGTYPE_p_int,0) < 0) {
                SWIG_croak("Type error in argument 6 of ldap_extended_operation. Expected _p_int");
            }
        }
        result = (int)ldap_extended_operation(arg1,(char const *)arg2,arg3,arg4,arg5,arg6);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_extended_operation_s) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        char *arg2 = (char *) 0 ;
        struct berval *arg3 = (struct berval *) 0 ;
        LDAPControl **arg4 = (LDAPControl **) 0 ;
        LDAPControl **arg5 = (LDAPControl **) 0 ;
        char **arg6 = (char **) 0 ;
        struct berval **arg7 = (struct berval **) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 7) || (items > 7)) {
            SWIG_croak("Usage: ldap_extended_operation_s(ld,reqoid,reqdata,serverctrls,clientctrls,retoidp,retdatap);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_extended_operation_s. Expected _p_LDAP");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 3 of ldap_extended_operation_s. Expected _p_berval");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 4 of ldap_extended_operation_s. Expected _p_p_LDAPControl");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(4), (void **) &arg5, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 5 of ldap_extended_operation_s. Expected _p_p_LDAPControl");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(5), (void **) &arg6, SWIGTYPE_p_p_char,0) < 0) {
                SWIG_croak("Type error in argument 6 of ldap_extended_operation_s. Expected _p_p_char");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(6), (void **) &arg7, SWIGTYPE_p_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 7 of ldap_extended_operation_s. Expected _p_p_berval");
            }
        }
        result = (int)ldap_extended_operation_s(arg1,(char const *)arg2,arg3,arg4,arg5,arg6,arg7);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_parse_extended_result) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        LDAPMessage *arg2 = (LDAPMessage *) 0 ;
        char **arg3 = (char **) 0 ;
        struct berval **arg4 = (struct berval **) 0 ;
        int arg5 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 5) || (items > 5)) {
            SWIG_croak("Usage: ldap_parse_extended_result(ld,res,retoidp,retdatap,freeit);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_parse_extended_result. Expected _p_LDAP");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_LDAPMessage,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_parse_extended_result. Expected _p_LDAPMessage");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_p_char,0) < 0) {
                SWIG_croak("Type error in argument 3 of ldap_parse_extended_result. Expected _p_p_char");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 4 of ldap_parse_extended_result. Expected _p_p_berval");
            }
        }
        arg5 = (int) SvIV(ST(4));
        result = (int)ldap_parse_extended_result(arg1,arg2,arg3,arg4,arg5);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_parse_extended_partial) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        LDAPMessage *arg2 = (LDAPMessage *) 0 ;
        char **arg3 = (char **) 0 ;
        struct berval **arg4 = (struct berval **) 0 ;
        LDAPControl ***arg5 = (LDAPControl ***) 0 ;
        int arg6 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 6) || (items > 6)) {
            SWIG_croak("Usage: ldap_parse_extended_partial(ld,res,retoidp,retdatap,serverctrls,freeit);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_parse_extended_partial. Expected _p_LDAP");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_LDAPMessage,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_parse_extended_partial. Expected _p_LDAPMessage");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_p_char,0) < 0) {
                SWIG_croak("Type error in argument 3 of ldap_parse_extended_partial. Expected _p_p_char");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 4 of ldap_parse_extended_partial. Expected _p_p_berval");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(4), (void **) &arg5, SWIGTYPE_p_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 5 of ldap_parse_extended_partial. Expected _p_p_p_LDAPControl");
            }
        }
        arg6 = (int) SvIV(ST(5));
        result = (int)ldap_parse_extended_partial(arg1,arg2,arg3,arg4,arg5,arg6);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_parse_intermediate_resp_result) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        LDAPMessage *arg2 = (LDAPMessage *) 0 ;
        char **arg3 = (char **) 0 ;
        struct berval **arg4 = (struct berval **) 0 ;
        int arg5 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 5) || (items > 5)) {
            SWIG_croak("Usage: ldap_parse_intermediate_resp_result(ld,res,retoidp,retdatap,freeit);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_parse_intermediate_resp_result. Expected _p_LDAP");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_LDAPMessage,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_parse_intermediate_resp_result. Expected _p_LDAPMessage");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_p_char,0) < 0) {
                SWIG_croak("Type error in argument 3 of ldap_parse_intermediate_resp_result. Expected _p_p_char");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 4 of ldap_parse_intermediate_resp_result. Expected _p_p_berval");
            }
        }
        arg5 = (int) SvIV(ST(4));
        result = (int)ldap_parse_intermediate_resp_result(arg1,arg2,arg3,arg4,arg5);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_abandon_ext) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        int arg2 ;
        LDAPControl **arg3 = (LDAPControl **) 0 ;
        LDAPControl **arg4 = (LDAPControl **) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: ldap_abandon_ext(ld,msgid,serverctrls,clientctrls);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_abandon_ext. Expected _p_LDAP");
            }
        }
        arg2 = (int) SvIV(ST(1));
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 3 of ldap_abandon_ext. Expected _p_p_LDAPControl");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 4 of ldap_abandon_ext. Expected _p_p_LDAPControl");
            }
        }
        result = (int)ldap_abandon_ext(arg1,arg2,arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_abandon) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        int arg2 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ldap_abandon(ld,msgid);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_abandon. Expected _p_LDAP");
            }
        }
        arg2 = (int) SvIV(ST(1));
        result = (int)ldap_abandon(arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_add_ext) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        char *arg2 = (char *) 0 ;
        LDAPMod **arg3 = (LDAPMod **) 0 ;
        LDAPControl **arg4 = (LDAPControl **) 0 ;
        LDAPControl **arg5 = (LDAPControl **) 0 ;
        int *arg6 = (int *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 6) || (items > 6)) {
            SWIG_croak("Usage: ldap_add_ext(ld,dn,attrs,serverctrls,clientctrls,msgidp);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_add_ext. Expected _p_LDAP");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_p_LDAPMod,0) < 0) {
                SWIG_croak("Type error in argument 3 of ldap_add_ext. Expected _p_p_LDAPMod");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 4 of ldap_add_ext. Expected _p_p_LDAPControl");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(4), (void **) &arg5, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 5 of ldap_add_ext. Expected _p_p_LDAPControl");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(5), (void **) &arg6, SWIGTYPE_p_int,0) < 0) {
                SWIG_croak("Type error in argument 6 of ldap_add_ext. Expected _p_int");
            }
        }
        result = (int)ldap_add_ext(arg1,(char const *)arg2,arg3,arg4,arg5,arg6);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_add_ext_s) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        char *arg2 = (char *) 0 ;
        LDAPMod **arg3 = (LDAPMod **) 0 ;
        LDAPControl **arg4 = (LDAPControl **) 0 ;
        LDAPControl **arg5 = (LDAPControl **) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 5) || (items > 5)) {
            SWIG_croak("Usage: ldap_add_ext_s(ld,dn,attrs,serverctrls,clientctrls);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_add_ext_s. Expected _p_LDAP");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_p_LDAPMod,0) < 0) {
                SWIG_croak("Type error in argument 3 of ldap_add_ext_s. Expected _p_p_LDAPMod");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 4 of ldap_add_ext_s. Expected _p_p_LDAPControl");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(4), (void **) &arg5, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 5 of ldap_add_ext_s. Expected _p_p_LDAPControl");
            }
        }
        result = (int)ldap_add_ext_s(arg1,(char const *)arg2,arg3,arg4,arg5);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_add) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        char *arg2 = (char *) 0 ;
        LDAPMod **arg3 = (LDAPMod **) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ldap_add(ld,dn,attrs);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_add. Expected _p_LDAP");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_p_LDAPMod,0) < 0) {
                SWIG_croak("Type error in argument 3 of ldap_add. Expected _p_p_LDAPMod");
            }
        }
        result = (int)ldap_add(arg1,(char const *)arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_add_s) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        char *arg2 = (char *) 0 ;
        LDAPMod **arg3 = (LDAPMod **) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ldap_add_s(ld,dn,attrs);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_add_s. Expected _p_LDAP");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_p_LDAPMod,0) < 0) {
                SWIG_croak("Type error in argument 3 of ldap_add_s. Expected _p_p_LDAPMod");
            }
        }
        result = (int)ldap_add_s(arg1,(char const *)arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_sasl_interactive_bind_s) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        char *arg2 = (char *) 0 ;
        char *arg3 = (char *) 0 ;
        LDAPControl **arg4 = (LDAPControl **) 0 ;
        LDAPControl **arg5 = (LDAPControl **) 0 ;
        unsigned int arg6 ;
        LDAP_SASL_INTERACT_PROC *arg7 = (LDAP_SASL_INTERACT_PROC *) 0 ;
        void *arg8 = (void *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 8) || (items > 8)) {
            SWIG_croak("Usage: ldap_sasl_interactive_bind_s(ld,dn,saslMechanism,serverControls,clientControls,flags,proc,defaults);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_sasl_interactive_bind_s. Expected _p_LDAP");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 4 of ldap_sasl_interactive_bind_s. Expected _p_p_LDAPControl");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(4), (void **) &arg5, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 5 of ldap_sasl_interactive_bind_s. Expected _p_p_LDAPControl");
            }
        }
        arg6 = (unsigned int) SvUV(ST(5));
        {
            if (SWIG_ConvertPtr(ST(6), (void **) &arg7, SWIGTYPE_p_LDAP_SASL_INTERACT_PROC,0) < 0) {
                SWIG_croak("Type error in argument 7 of ldap_sasl_interactive_bind_s. Expected _p_LDAP_SASL_INTERACT_PROC");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(7), (void **) &arg8, 0,0) < 0) {
                SWIG_croak("Type error in argument 8 of ldap_sasl_interactive_bind_s. Expected _p_void");
            }
        }
        result = (int)ldap_sasl_interactive_bind_s(arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6,arg7,arg8);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        
        XSRETURN(argvi);
        fail:
        
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_bind) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        char *arg2 = (char *) 0 ;
        char *arg3 = (char *) 0 ;
        int arg4 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: ldap_bind(ld,who,passwd,authmethod);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_bind. Expected _p_LDAP");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        arg4 = (int) SvIV(ST(3));
        result = (int)ldap_bind(arg1,(char const *)arg2,(char const *)arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        
        XSRETURN(argvi);
        fail:
        
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_bind_s) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        char *arg2 = (char *) 0 ;
        char *arg3 = (char *) 0 ;
        int arg4 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: ldap_bind_s(ld,who,cred,authmethod);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_bind_s. Expected _p_LDAP");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        arg4 = (int) SvIV(ST(3));
        result = (int)ldap_bind_s(arg1,(char const *)arg2,(char const *)arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        
        XSRETURN(argvi);
        fail:
        
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_kerberos_bind_s) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        char *arg2 = (char *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ldap_kerberos_bind_s(ld,who);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_kerberos_bind_s. Expected _p_LDAP");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        result = (int)ldap_kerberos_bind_s(arg1,(char const *)arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_kerberos_bind1) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        char *arg2 = (char *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ldap_kerberos_bind1(ld,who);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_kerberos_bind1. Expected _p_LDAP");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        result = (int)ldap_kerberos_bind1(arg1,(char const *)arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_kerberos_bind1_s) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        char *arg2 = (char *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ldap_kerberos_bind1_s(ld,who);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_kerberos_bind1_s. Expected _p_LDAP");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        result = (int)ldap_kerberos_bind1_s(arg1,(char const *)arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_kerberos_bind2) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        char *arg2 = (char *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ldap_kerberos_bind2(ld,who);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_kerberos_bind2. Expected _p_LDAP");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        result = (int)ldap_kerberos_bind2(arg1,(char const *)arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_kerberos_bind2_s) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        char *arg2 = (char *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ldap_kerberos_bind2_s(ld,who);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_kerberos_bind2_s. Expected _p_LDAP");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        result = (int)ldap_kerberos_bind2_s(arg1,(char const *)arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_cancel) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        int arg2 ;
        LDAPControl **arg3 = (LDAPControl **) 0 ;
        LDAPControl **arg4 = (LDAPControl **) 0 ;
        int *arg5 = (int *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 5) || (items > 5)) {
            SWIG_croak("Usage: ldap_cancel(ld,cancelid,sctrls,cctrls,msgidp);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_cancel. Expected _p_LDAP");
            }
        }
        arg2 = (int) SvIV(ST(1));
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 3 of ldap_cancel. Expected _p_p_LDAPControl");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 4 of ldap_cancel. Expected _p_p_LDAPControl");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(4), (void **) &arg5, SWIGTYPE_p_int,0) < 0) {
                SWIG_croak("Type error in argument 5 of ldap_cancel. Expected _p_int");
            }
        }
        result = (int)ldap_cancel(arg1,arg2,arg3,arg4,arg5);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_cancel_s) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        int arg2 ;
        LDAPControl **arg3 = (LDAPControl **) 0 ;
        LDAPControl **arg4 = (LDAPControl **) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: ldap_cancel_s(ld,cancelid,sctrl,cctrl);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_cancel_s. Expected _p_LDAP");
            }
        }
        arg2 = (int) SvIV(ST(1));
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 3 of ldap_cancel_s. Expected _p_p_LDAPControl");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 4 of ldap_cancel_s. Expected _p_p_LDAPControl");
            }
        }
        result = (int)ldap_cancel_s(arg1,arg2,arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_compare_ext) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        char *arg2 = (char *) 0 ;
        char *arg3 = (char *) 0 ;
        struct berval *arg4 = (struct berval *) 0 ;
        LDAPControl **arg5 = (LDAPControl **) 0 ;
        LDAPControl **arg6 = (LDAPControl **) 0 ;
        int *arg7 = (int *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 7) || (items > 7)) {
            SWIG_croak("Usage: ldap_compare_ext(ld,dn,attr,bvalue,serverctrls,clientctrls,msgidp);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_compare_ext. Expected _p_LDAP");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 4 of ldap_compare_ext. Expected _p_berval");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(4), (void **) &arg5, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 5 of ldap_compare_ext. Expected _p_p_LDAPControl");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(5), (void **) &arg6, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 6 of ldap_compare_ext. Expected _p_p_LDAPControl");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(6), (void **) &arg7, SWIGTYPE_p_int,0) < 0) {
                SWIG_croak("Type error in argument 7 of ldap_compare_ext. Expected _p_int");
            }
        }
        result = (int)ldap_compare_ext(arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6,arg7);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        
        XSRETURN(argvi);
        fail:
        
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_compare_ext_s) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        char *arg2 = (char *) 0 ;
        char *arg3 = (char *) 0 ;
        struct berval *arg4 = (struct berval *) 0 ;
        LDAPControl **arg5 = (LDAPControl **) 0 ;
        LDAPControl **arg6 = (LDAPControl **) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 6) || (items > 6)) {
            SWIG_croak("Usage: ldap_compare_ext_s(ld,dn,attr,bvalue,serverctrls,clientctrls);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_compare_ext_s. Expected _p_LDAP");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 4 of ldap_compare_ext_s. Expected _p_berval");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(4), (void **) &arg5, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 5 of ldap_compare_ext_s. Expected _p_p_LDAPControl");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(5), (void **) &arg6, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 6 of ldap_compare_ext_s. Expected _p_p_LDAPControl");
            }
        }
        result = (int)ldap_compare_ext_s(arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        
        XSRETURN(argvi);
        fail:
        
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_compare) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        char *arg2 = (char *) 0 ;
        char *arg3 = (char *) 0 ;
        char *arg4 = (char *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: ldap_compare(ld,dn,attr,value);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_compare. Expected _p_LDAP");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        if (!SvOK((SV*) ST(3))) arg4 = 0;
        else arg4 = (char *) SvPV(ST(3), PL_na);
        result = (int)ldap_compare(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        
        
        XSRETURN(argvi);
        fail:
        
        
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_compare_s) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        char *arg2 = (char *) 0 ;
        char *arg3 = (char *) 0 ;
        char *arg4 = (char *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: ldap_compare_s(ld,dn,attr,value);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_compare_s. Expected _p_LDAP");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        if (!SvOK((SV*) ST(3))) arg4 = 0;
        else arg4 = (char *) SvPV(ST(3), PL_na);
        result = (int)ldap_compare_s(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        
        
        XSRETURN(argvi);
        fail:
        
        
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_delete_ext) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        char *arg2 = (char *) 0 ;
        LDAPControl **arg3 = (LDAPControl **) 0 ;
        LDAPControl **arg4 = (LDAPControl **) 0 ;
        int *arg5 = (int *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 5) || (items > 5)) {
            SWIG_croak("Usage: ldap_delete_ext(ld,dn,serverctrls,clientctrls,msgidp);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_delete_ext. Expected _p_LDAP");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 3 of ldap_delete_ext. Expected _p_p_LDAPControl");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 4 of ldap_delete_ext. Expected _p_p_LDAPControl");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(4), (void **) &arg5, SWIGTYPE_p_int,0) < 0) {
                SWIG_croak("Type error in argument 5 of ldap_delete_ext. Expected _p_int");
            }
        }
        result = (int)ldap_delete_ext(arg1,(char const *)arg2,arg3,arg4,arg5);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_delete_ext_s) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        char *arg2 = (char *) 0 ;
        LDAPControl **arg3 = (LDAPControl **) 0 ;
        LDAPControl **arg4 = (LDAPControl **) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: ldap_delete_ext_s(ld,dn,serverctrls,clientctrls);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_delete_ext_s. Expected _p_LDAP");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 3 of ldap_delete_ext_s. Expected _p_p_LDAPControl");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 4 of ldap_delete_ext_s. Expected _p_p_LDAPControl");
            }
        }
        result = (int)ldap_delete_ext_s(arg1,(char const *)arg2,arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_delete) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        char *arg2 = (char *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ldap_delete(ld,dn);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_delete. Expected _p_LDAP");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        result = (int)ldap_delete(arg1,(char const *)arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_delete_s) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        char *arg2 = (char *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ldap_delete_s(ld,dn);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_delete_s. Expected _p_LDAP");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        result = (int)ldap_delete_s(arg1,(char const *)arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_err2string) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        int arg1 ;
        char *result = (char *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ldap_err2string(err);");
        }
        arg1 = (int) SvIV(ST(0));
        result = (char *)ldap_err2string(arg1);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        } else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_result2error) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        LDAPMessage *arg2 = (LDAPMessage *) 0 ;
        int arg3 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ldap_result2error(ld,r,freeit);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_result2error. Expected _p_LDAP");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_LDAPMessage,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_result2error. Expected _p_LDAPMessage");
            }
        }
        arg3 = (int) SvIV(ST(2));
        result = (int)ldap_result2error(arg1,arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_perror) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        char *arg2 = (char *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ldap_perror(ld,s);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_perror. Expected _p_LDAP");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        ldap_perror(arg1,(char const *)arg2);
        
        
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_modify_ext) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        char *arg2 = (char *) 0 ;
        LDAPMod **arg3 = (LDAPMod **) 0 ;
        LDAPControl **arg4 = (LDAPControl **) 0 ;
        LDAPControl **arg5 = (LDAPControl **) 0 ;
        int *arg6 = (int *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 6) || (items > 6)) {
            SWIG_croak("Usage: ldap_modify_ext(ld,dn,mods,serverctrls,clientctrls,msgidp);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_modify_ext. Expected _p_LDAP");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_p_LDAPMod,0) < 0) {
                SWIG_croak("Type error in argument 3 of ldap_modify_ext. Expected _p_p_LDAPMod");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 4 of ldap_modify_ext. Expected _p_p_LDAPControl");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(4), (void **) &arg5, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 5 of ldap_modify_ext. Expected _p_p_LDAPControl");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(5), (void **) &arg6, SWIGTYPE_p_int,0) < 0) {
                SWIG_croak("Type error in argument 6 of ldap_modify_ext. Expected _p_int");
            }
        }
        result = (int)ldap_modify_ext(arg1,(char const *)arg2,arg3,arg4,arg5,arg6);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_modify_ext_s) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        char *arg2 = (char *) 0 ;
        LDAPMod **arg3 = (LDAPMod **) 0 ;
        LDAPControl **arg4 = (LDAPControl **) 0 ;
        LDAPControl **arg5 = (LDAPControl **) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 5) || (items > 5)) {
            SWIG_croak("Usage: ldap_modify_ext_s(ld,dn,mods,serverctrls,clientctrls);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_modify_ext_s. Expected _p_LDAP");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_p_LDAPMod,0) < 0) {
                SWIG_croak("Type error in argument 3 of ldap_modify_ext_s. Expected _p_p_LDAPMod");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 4 of ldap_modify_ext_s. Expected _p_p_LDAPControl");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(4), (void **) &arg5, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 5 of ldap_modify_ext_s. Expected _p_p_LDAPControl");
            }
        }
        result = (int)ldap_modify_ext_s(arg1,(char const *)arg2,arg3,arg4,arg5);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_modify) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        char *arg2 = (char *) 0 ;
        LDAPMod **arg3 = (LDAPMod **) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ldap_modify(ld,dn,mods);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_modify. Expected _p_LDAP");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_p_LDAPMod,0) < 0) {
                SWIG_croak("Type error in argument 3 of ldap_modify. Expected _p_p_LDAPMod");
            }
        }
        result = (int)ldap_modify(arg1,(char const *)arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_modify_s) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        char *arg2 = (char *) 0 ;
        LDAPMod **arg3 = (LDAPMod **) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ldap_modify_s(ld,dn,mods);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_modify_s. Expected _p_LDAP");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_p_LDAPMod,0) < 0) {
                SWIG_croak("Type error in argument 3 of ldap_modify_s. Expected _p_p_LDAPMod");
            }
        }
        result = (int)ldap_modify_s(arg1,(char const *)arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_rename) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        char *arg2 = (char *) 0 ;
        char *arg3 = (char *) 0 ;
        char *arg4 = (char *) 0 ;
        int arg5 ;
        LDAPControl **arg6 = (LDAPControl **) 0 ;
        LDAPControl **arg7 = (LDAPControl **) 0 ;
        int *arg8 = (int *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 8) || (items > 8)) {
            SWIG_croak("Usage: ldap_rename(ld,dn,newrdn,newSuperior,deleteoldrdn,sctrls,cctrls,msgidp);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_rename. Expected _p_LDAP");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        if (!SvOK((SV*) ST(3))) arg4 = 0;
        else arg4 = (char *) SvPV(ST(3), PL_na);
        arg5 = (int) SvIV(ST(4));
        {
            if (SWIG_ConvertPtr(ST(5), (void **) &arg6, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 6 of ldap_rename. Expected _p_p_LDAPControl");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(6), (void **) &arg7, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 7 of ldap_rename. Expected _p_p_LDAPControl");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(7), (void **) &arg8, SWIGTYPE_p_int,0) < 0) {
                SWIG_croak("Type error in argument 8 of ldap_rename. Expected _p_int");
            }
        }
        result = (int)ldap_rename(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4,arg5,arg6,arg7,arg8);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        
        
        XSRETURN(argvi);
        fail:
        
        
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_rename_s) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        char *arg2 = (char *) 0 ;
        char *arg3 = (char *) 0 ;
        char *arg4 = (char *) 0 ;
        int arg5 ;
        LDAPControl **arg6 = (LDAPControl **) 0 ;
        LDAPControl **arg7 = (LDAPControl **) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 7) || (items > 7)) {
            SWIG_croak("Usage: ldap_rename_s(ld,dn,newrdn,newSuperior,deleteoldrdn,sctrls,cctrls);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_rename_s. Expected _p_LDAP");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        if (!SvOK((SV*) ST(3))) arg4 = 0;
        else arg4 = (char *) SvPV(ST(3), PL_na);
        arg5 = (int) SvIV(ST(4));
        {
            if (SWIG_ConvertPtr(ST(5), (void **) &arg6, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 6 of ldap_rename_s. Expected _p_p_LDAPControl");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(6), (void **) &arg7, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 7 of ldap_rename_s. Expected _p_p_LDAPControl");
            }
        }
        result = (int)ldap_rename_s(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4,arg5,arg6,arg7);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        
        
        XSRETURN(argvi);
        fail:
        
        
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_rename2) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        char *arg2 = (char *) 0 ;
        char *arg3 = (char *) 0 ;
        char *arg4 = (char *) 0 ;
        int arg5 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 5) || (items > 5)) {
            SWIG_croak("Usage: ldap_rename2(ld,dn,newrdn,newSuperior,deleteoldrdn);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_rename2. Expected _p_LDAP");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        if (!SvOK((SV*) ST(3))) arg4 = 0;
        else arg4 = (char *) SvPV(ST(3), PL_na);
        arg5 = (int) SvIV(ST(4));
        result = (int)ldap_rename2(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4,arg5);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        
        
        XSRETURN(argvi);
        fail:
        
        
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_rename2_s) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        char *arg2 = (char *) 0 ;
        char *arg3 = (char *) 0 ;
        char *arg4 = (char *) 0 ;
        int arg5 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 5) || (items > 5)) {
            SWIG_croak("Usage: ldap_rename2_s(ld,dn,newrdn,newSuperior,deleteoldrdn);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_rename2_s. Expected _p_LDAP");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        if (!SvOK((SV*) ST(3))) arg4 = 0;
        else arg4 = (char *) SvPV(ST(3), PL_na);
        arg5 = (int) SvIV(ST(4));
        result = (int)ldap_rename2_s(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4,arg5);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        
        
        XSRETURN(argvi);
        fail:
        
        
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_modrdn) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        char *arg2 = (char *) 0 ;
        char *arg3 = (char *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ldap_modrdn(ld,dn,newrdn);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_modrdn. Expected _p_LDAP");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        result = (int)ldap_modrdn(arg1,(char const *)arg2,(char const *)arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        
        XSRETURN(argvi);
        fail:
        
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_modrdn_s) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        char *arg2 = (char *) 0 ;
        char *arg3 = (char *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ldap_modrdn_s(ld,dn,newrdn);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_modrdn_s. Expected _p_LDAP");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        result = (int)ldap_modrdn_s(arg1,(char const *)arg2,(char const *)arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        
        XSRETURN(argvi);
        fail:
        
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_modrdn2) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        char *arg2 = (char *) 0 ;
        char *arg3 = (char *) 0 ;
        int arg4 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: ldap_modrdn2(ld,dn,newrdn,deleteoldrdn);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_modrdn2. Expected _p_LDAP");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        arg4 = (int) SvIV(ST(3));
        result = (int)ldap_modrdn2(arg1,(char const *)arg2,(char const *)arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        
        XSRETURN(argvi);
        fail:
        
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_modrdn2_s) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        char *arg2 = (char *) 0 ;
        char *arg3 = (char *) 0 ;
        int arg4 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: ldap_modrdn2_s(ld,dn,newrdn,deleteoldrdn);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_modrdn2_s. Expected _p_LDAP");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        arg4 = (int) SvIV(ST(3));
        result = (int)ldap_modrdn2_s(arg1,(char const *)arg2,(char const *)arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        
        XSRETURN(argvi);
        fail:
        
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_open) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        char *arg1 = (char *) 0 ;
        int arg2 ;
        LDAP *result = (LDAP *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ldap_open(host,port);");
        }
        if (!SvOK((SV*) ST(0))) arg1 = 0;
        else arg1 = (char *) SvPV(ST(0), PL_na);
        arg2 = (int) SvIV(ST(1));
        result = (LDAP *)ldap_open((char const *)arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_LDAP, SWIG_SHADOW|0);
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_create) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP **arg1 = (LDAP **) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ldap_create(ldp);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_create. Expected _p_p_LDAP");
            }
        }
        result = (int)ldap_create(arg1);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_initialize) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP **arg1 = (LDAP **) 0 ;
        char *arg2 = (char *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ldap_initialize(ldp,url);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_initialize. Expected _p_p_LDAP");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        result = (int)ldap_initialize(arg1,(char const *)arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_start_tls_s) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        LDAPControl **arg2 = (LDAPControl **) 0 ;
        LDAPControl **arg3 = (LDAPControl **) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ldap_start_tls_s(ld,serverctrls,clientctrls);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_start_tls_s. Expected _p_LDAP");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_start_tls_s. Expected _p_p_LDAPControl");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 3 of ldap_start_tls_s. Expected _p_p_LDAPControl");
            }
        }
        result = (int)ldap_start_tls_s(arg1,arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_parse_reference) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        LDAPMessage *arg2 = (LDAPMessage *) 0 ;
        char ***arg3 = (char ***) 0 ;
        LDAPControl ***arg4 = (LDAPControl ***) 0 ;
        int arg5 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 5) || (items > 5)) {
            SWIG_croak("Usage: ldap_parse_reference(ld,ref,referralsp,serverctrls,freeit);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_parse_reference. Expected _p_LDAP");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_LDAPMessage,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_parse_reference. Expected _p_LDAPMessage");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_p_p_char,0) < 0) {
                SWIG_croak("Type error in argument 3 of ldap_parse_reference. Expected _p_p_p_char");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 4 of ldap_parse_reference. Expected _p_p_p_LDAPControl");
            }
        }
        arg5 = (int) SvIV(ST(4));
        result = (int)ldap_parse_reference(arg1,arg2,arg3,arg4,arg5);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_get_entry_controls) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        LDAPMessage *arg2 = (LDAPMessage *) 0 ;
        LDAPControl ***arg3 = (LDAPControl ***) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ldap_get_entry_controls(ld,entry,serverctrls);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_get_entry_controls. Expected _p_LDAP");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_LDAPMessage,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_get_entry_controls. Expected _p_LDAPMessage");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 3 of ldap_get_entry_controls. Expected _p_p_p_LDAPControl");
            }
        }
        result = (int)ldap_get_entry_controls(arg1,arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_delete_result_entry) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPMessage **arg1 = (LDAPMessage **) 0 ;
        LDAPMessage *arg2 = (LDAPMessage *) 0 ;
        LDAPMessage *result = (LDAPMessage *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ldap_delete_result_entry(list,e);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_p_LDAPMessage,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_delete_result_entry. Expected _p_p_LDAPMessage");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_LDAPMessage,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_delete_result_entry. Expected _p_LDAPMessage");
            }
        }
        result = (LDAPMessage *)ldap_delete_result_entry(arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_LDAPMessage, SWIG_SHADOW|0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_add_result_entry) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPMessage **arg1 = (LDAPMessage **) 0 ;
        LDAPMessage *arg2 = (LDAPMessage *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ldap_add_result_entry(list,e);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_p_LDAPMessage,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_add_result_entry. Expected _p_p_LDAPMessage");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_LDAPMessage,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_add_result_entry. Expected _p_LDAPMessage");
            }
        }
        ldap_add_result_entry(arg1,arg2);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_get_dn) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        LDAPMessage *arg2 = (LDAPMessage *) 0 ;
        char *result = (char *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ldap_get_dn(ld,entry);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_get_dn. Expected _p_LDAP");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_LDAPMessage,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_get_dn. Expected _p_LDAPMessage");
            }
        }
        result = (char *)ldap_get_dn(arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        } else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_AVA_la_attr_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPAVA *arg1 = (LDAPAVA *) 0 ;
        struct berval *arg2 = (struct berval *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: AVA_la_attr_set(self,la_attr);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPAVA,0) < 0) {
                SWIG_croak("Type error in argument 1 of AVA_la_attr_set. Expected _p_LDAPAVA");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 2 of AVA_la_attr_set. Expected _p_berval");
            }
        }
        if (arg1) (arg1)->la_attr = *arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_AVA_la_attr_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPAVA *arg1 = (LDAPAVA *) 0 ;
        struct berval *result = (struct berval *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: AVA_la_attr_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPAVA,0) < 0) {
                SWIG_croak("Type error in argument 1 of AVA_la_attr_get. Expected _p_LDAPAVA");
            }
        }
        result = (struct berval *)& ((arg1)->la_attr);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_berval, SWIG_SHADOW|0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_AVA_la_value_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPAVA *arg1 = (LDAPAVA *) 0 ;
        struct berval *arg2 = (struct berval *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: AVA_la_value_set(self,la_value);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPAVA,0) < 0) {
                SWIG_croak("Type error in argument 1 of AVA_la_value_set. Expected _p_LDAPAVA");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 2 of AVA_la_value_set. Expected _p_berval");
            }
        }
        if (arg1) (arg1)->la_value = *arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_AVA_la_value_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPAVA *arg1 = (LDAPAVA *) 0 ;
        struct berval *result = (struct berval *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: AVA_la_value_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPAVA,0) < 0) {
                SWIG_croak("Type error in argument 1 of AVA_la_value_get. Expected _p_LDAPAVA");
            }
        }
        result = (struct berval *)& ((arg1)->la_value);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_berval, SWIG_SHADOW|0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_AVA_la_flags_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPAVA *arg1 = (LDAPAVA *) 0 ;
        unsigned int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: AVA_la_flags_set(self,la_flags);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPAVA,0) < 0) {
                SWIG_croak("Type error in argument 1 of AVA_la_flags_set. Expected _p_LDAPAVA");
            }
        }
        arg2 = (unsigned int) SvUV(ST(1));
        if (arg1) (arg1)->la_flags = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_AVA_la_flags_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPAVA *arg1 = (LDAPAVA *) 0 ;
        unsigned int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: AVA_la_flags_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPAVA,0) < 0) {
                SWIG_croak("Type error in argument 1 of AVA_la_flags_get. Expected _p_LDAPAVA");
            }
        }
        result = (unsigned int) ((arg1)->la_flags);
        
        ST(argvi) = sv_newmortal();
        sv_setuv(ST(argvi++), (UV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_AVA_la_private_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPAVA *arg1 = (LDAPAVA *) 0 ;
        void *arg2 = (void *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: AVA_la_private_set(self,la_private);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPAVA,0) < 0) {
                SWIG_croak("Type error in argument 1 of AVA_la_private_set. Expected _p_LDAPAVA");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, 0,0) < 0) {
                SWIG_croak("Type error in argument 2 of AVA_la_private_set. Expected _p_void");
            }
        }
        if (arg1) (arg1)->la_private = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_AVA_la_private_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPAVA *arg1 = (LDAPAVA *) 0 ;
        void *result = (void *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: AVA_la_private_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPAVA,0) < 0) {
                SWIG_croak("Type error in argument 1 of AVA_la_private_get. Expected _p_LDAPAVA");
            }
        }
        result = (void *) ((arg1)->la_private);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_void, 0|0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_new_AVA) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPAVA *result = (LDAPAVA *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 0) || (items > 0)) {
            SWIG_croak("Usage: new_AVA();");
        }
        result = (LDAPAVA *)(LDAPAVA *) calloc(1, sizeof(LDAPAVA));
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_LDAPAVA, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_delete_AVA) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPAVA *arg1 = (LDAPAVA *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_AVA(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPAVA,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_AVA. Expected _p_LDAPAVA");
            }
        }
        free((char *) arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_avafree) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPAVA *arg1 = (LDAPAVA *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ldap_avafree(ava);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPAVA,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_avafree. Expected _p_LDAPAVA");
            }
        }
        ldap_avafree(arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_rdnfree) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPRDN *arg1 = (LDAPRDN *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ldap_rdnfree(rdn);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPRDN,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_rdnfree. Expected _p_LDAPRDN");
            }
        }
        ldap_rdnfree(arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_dnfree) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPDN *arg1 = (LDAPDN *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ldap_dnfree(dn);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPDN,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_dnfree. Expected _p_LDAPDN");
            }
        }
        ldap_dnfree(arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_bv2dn) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct berval *arg1 = (struct berval *) 0 ;
        LDAPDN **arg2 = (LDAPDN **) 0 ;
        unsigned int arg3 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ldap_bv2dn(bv,dn,flags);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_bv2dn. Expected _p_berval");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_p_LDAPDN,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_bv2dn. Expected _p_p_LDAPDN");
            }
        }
        arg3 = (unsigned int) SvUV(ST(2));
        result = (int)ldap_bv2dn(arg1,arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_str2dn) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        char *arg1 = (char *) 0 ;
        LDAPDN **arg2 = (LDAPDN **) 0 ;
        unsigned int arg3 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ldap_str2dn(str,dn,flags);");
        }
        if (!SvOK((SV*) ST(0))) arg1 = 0;
        else arg1 = (char *) SvPV(ST(0), PL_na);
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_p_LDAPDN,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_str2dn. Expected _p_p_LDAPDN");
            }
        }
        arg3 = (unsigned int) SvUV(ST(2));
        result = (int)ldap_str2dn((char const *)arg1,arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_dn2bv) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPDN *arg1 = (LDAPDN *) 0 ;
        struct berval *arg2 = (struct berval *) 0 ;
        unsigned int arg3 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ldap_dn2bv(dn,bv,flags);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPDN,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_dn2bv. Expected _p_LDAPDN");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_dn2bv. Expected _p_berval");
            }
        }
        arg3 = (unsigned int) SvUV(ST(2));
        result = (int)ldap_dn2bv(arg1,arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_dn2str) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPDN *arg1 = (LDAPDN *) 0 ;
        char **arg2 = (char **) 0 ;
        unsigned int arg3 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ldap_dn2str(dn,str,flags);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPDN,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_dn2str. Expected _p_LDAPDN");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_p_char,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_dn2str. Expected _p_p_char");
            }
        }
        arg3 = (unsigned int) SvUV(ST(2));
        result = (int)ldap_dn2str(arg1,arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_bv2rdn) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct berval *arg1 = (struct berval *) 0 ;
        LDAPRDN **arg2 = (LDAPRDN **) 0 ;
        char **arg3 = (char **) 0 ;
        unsigned int arg4 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: ldap_bv2rdn(bv,rdn,next,flags);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_bv2rdn. Expected _p_berval");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_p_LDAPRDN,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_bv2rdn. Expected _p_p_LDAPRDN");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_p_char,0) < 0) {
                SWIG_croak("Type error in argument 3 of ldap_bv2rdn. Expected _p_p_char");
            }
        }
        arg4 = (unsigned int) SvUV(ST(3));
        result = (int)ldap_bv2rdn(arg1,arg2,arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_str2rdn) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        char *arg1 = (char *) 0 ;
        LDAPRDN **arg2 = (LDAPRDN **) 0 ;
        char **arg3 = (char **) 0 ;
        unsigned int arg4 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: ldap_str2rdn(str,rdn,next,flags);");
        }
        if (!SvOK((SV*) ST(0))) arg1 = 0;
        else arg1 = (char *) SvPV(ST(0), PL_na);
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_p_LDAPRDN,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_str2rdn. Expected _p_p_LDAPRDN");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_p_char,0) < 0) {
                SWIG_croak("Type error in argument 3 of ldap_str2rdn. Expected _p_p_char");
            }
        }
        arg4 = (unsigned int) SvUV(ST(3));
        result = (int)ldap_str2rdn((char const *)arg1,arg2,arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_rdn2bv) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPRDN *arg1 = (LDAPRDN *) 0 ;
        struct berval *arg2 = (struct berval *) 0 ;
        unsigned int arg3 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ldap_rdn2bv(rdn,bv,flags);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPRDN,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_rdn2bv. Expected _p_LDAPRDN");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_rdn2bv. Expected _p_berval");
            }
        }
        arg3 = (unsigned int) SvUV(ST(2));
        result = (int)ldap_rdn2bv(arg1,arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_rdn2str) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPRDN *arg1 = (LDAPRDN *) 0 ;
        char **arg2 = (char **) 0 ;
        unsigned int arg3 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ldap_rdn2str(rdn,str,flags);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPRDN,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_rdn2str. Expected _p_LDAPRDN");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_p_char,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_rdn2str. Expected _p_p_char");
            }
        }
        arg3 = (unsigned int) SvUV(ST(2));
        result = (int)ldap_rdn2str(arg1,arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_dn_normalize) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        char *arg1 = (char *) 0 ;
        unsigned int arg2 ;
        char **arg3 = (char **) 0 ;
        unsigned int arg4 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: ldap_dn_normalize(in,iflags,out,oflags);");
        }
        if (!SvOK((SV*) ST(0))) arg1 = 0;
        else arg1 = (char *) SvPV(ST(0), PL_na);
        arg2 = (unsigned int) SvUV(ST(1));
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_p_char,0) < 0) {
                SWIG_croak("Type error in argument 3 of ldap_dn_normalize. Expected _p_p_char");
            }
        }
        arg4 = (unsigned int) SvUV(ST(3));
        result = (int)ldap_dn_normalize((char const *)arg1,arg2,arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_dn2ufn) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        char *arg1 = (char *) 0 ;
        char *result = (char *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ldap_dn2ufn(dn);");
        }
        if (!SvOK((SV*) ST(0))) arg1 = 0;
        else arg1 = (char *) SvPV(ST(0), PL_na);
        result = (char *)ldap_dn2ufn((char const *)arg1);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        } else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_explode_dn) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        char *arg1 = (char *) 0 ;
        int arg2 ;
        char **result = (char **) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ldap_explode_dn(dn,notypes);");
        }
        if (!SvOK((SV*) ST(0))) arg1 = 0;
        else arg1 = (char *) SvPV(ST(0), PL_na);
        arg2 = (int) SvIV(ST(1));
        result = (char **)ldap_explode_dn((char const *)arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_p_char, 0|0);
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_explode_rdn) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        char *arg1 = (char *) 0 ;
        int arg2 ;
        char **result = (char **) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ldap_explode_rdn(rdn,notypes);");
        }
        if (!SvOK((SV*) ST(0))) arg1 = 0;
        else arg1 = (char *) SvPV(ST(0), PL_na);
        arg2 = (int) SvIV(ST(1));
        result = (char **)ldap_explode_rdn((char const *)arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_p_char, 0|0);
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_X509dn2bv) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        void *arg1 = (void *) 0 ;
        struct berval *arg2 = (struct berval *) 0 ;
        LDAPDN_rewrite_func *arg3 = (LDAPDN_rewrite_func *) 0 ;
        unsigned int arg4 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: ldap_X509dn2bv(x509_name,dn,func,flags);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, 0,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_X509dn2bv. Expected _p_void");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_X509dn2bv. Expected _p_berval");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_LDAPDN_rewrite_func,0) < 0) {
                SWIG_croak("Type error in argument 3 of ldap_X509dn2bv. Expected _p_LDAPDN_rewrite_func");
            }
        }
        arg4 = (unsigned int) SvUV(ST(3));
        result = (int)ldap_X509dn2bv(arg1,arg2,arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_dn2dcedn) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        char *arg1 = (char *) 0 ;
        char *result = (char *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ldap_dn2dcedn(dn);");
        }
        if (!SvOK((SV*) ST(0))) arg1 = 0;
        else arg1 = (char *) SvPV(ST(0), PL_na);
        result = (char *)ldap_dn2dcedn((char const *)arg1);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        } else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_dcedn2dn) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        char *arg1 = (char *) 0 ;
        char *result = (char *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ldap_dcedn2dn(dce);");
        }
        if (!SvOK((SV*) ST(0))) arg1 = 0;
        else arg1 = (char *) SvPV(ST(0), PL_na);
        result = (char *)ldap_dcedn2dn((char const *)arg1);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        } else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_dn2ad_canonical) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        char *arg1 = (char *) 0 ;
        char *result = (char *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ldap_dn2ad_canonical(dn);");
        }
        if (!SvOK((SV*) ST(0))) arg1 = 0;
        else arg1 = (char *) SvPV(ST(0), PL_na);
        result = (char *)ldap_dn2ad_canonical((char const *)arg1);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        } else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_get_dn_ber) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        LDAPMessage *arg2 = (LDAPMessage *) 0 ;
        BerElement **arg3 = (BerElement **) 0 ;
        struct berval *arg4 = (struct berval *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: ldap_get_dn_ber(ld,e,berout,dn);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_get_dn_ber. Expected _p_LDAP");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_LDAPMessage,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_get_dn_ber. Expected _p_LDAPMessage");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 3 of ldap_get_dn_ber. Expected _p_p_BerElement");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 4 of ldap_get_dn_ber. Expected _p_berval");
            }
        }
        result = (int)ldap_get_dn_ber(arg1,arg2,arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_get_attribute_ber) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        LDAPMessage *arg2 = (LDAPMessage *) 0 ;
        BerElement *arg3 = (BerElement *) 0 ;
        struct berval *arg4 = (struct berval *) 0 ;
        struct berval **arg5 = (struct berval **) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 5) || (items > 5)) {
            SWIG_croak("Usage: ldap_get_attribute_ber(ld,e,ber,attr,vals);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_get_attribute_ber. Expected _p_LDAP");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_LDAPMessage,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_get_attribute_ber. Expected _p_LDAPMessage");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 3 of ldap_get_attribute_ber. Expected _p_BerElement");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 4 of ldap_get_attribute_ber. Expected _p_berval");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(4), (void **) &arg5, SWIGTYPE_p_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 5 of ldap_get_attribute_ber. Expected _p_p_berval");
            }
        }
        result = (int)ldap_get_attribute_ber(arg1,arg2,arg3,arg4,arg5);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_first_attribute) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        LDAPMessage *arg2 = (LDAPMessage *) 0 ;
        BerElement **arg3 = (BerElement **) 0 ;
        char *result = (char *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ldap_first_attribute(ld,entry,ber);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_first_attribute. Expected _p_LDAP");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_LDAPMessage,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_first_attribute. Expected _p_LDAPMessage");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 3 of ldap_first_attribute. Expected _p_p_BerElement");
            }
        }
        result = (char *)ldap_first_attribute(arg1,arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        } else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_next_attribute) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        LDAPMessage *arg2 = (LDAPMessage *) 0 ;
        BerElement *arg3 = (BerElement *) 0 ;
        char *result = (char *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ldap_next_attribute(ld,entry,ber);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_next_attribute. Expected _p_LDAP");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_LDAPMessage,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_next_attribute. Expected _p_LDAPMessage");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 3 of ldap_next_attribute. Expected _p_BerElement");
            }
        }
        result = (char *)ldap_next_attribute(arg1,arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        } else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_get_values_len) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        LDAPMessage *arg2 = (LDAPMessage *) 0 ;
        char *arg3 = (char *) 0 ;
        struct berval **result = (struct berval **) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ldap_get_values_len(ld,entry,target);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_get_values_len. Expected _p_LDAP");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_LDAPMessage,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_get_values_len. Expected _p_LDAPMessage");
            }
        }
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        result = (struct berval **)ldap_get_values_len(arg1,arg2,(char const *)arg3);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_p_berval, 0|0);
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_count_values_len) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct berval **arg1 = (struct berval **) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ldap_count_values_len(vals);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_count_values_len. Expected _p_p_berval");
            }
        }
        result = (int)ldap_count_values_len(arg1);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_value_free_len) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct berval **arg1 = (struct berval **) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ldap_value_free_len(vals);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_value_free_len. Expected _p_p_berval");
            }
        }
        ldap_value_free_len(arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_get_values) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        LDAPMessage *arg2 = (LDAPMessage *) 0 ;
        char *arg3 = (char *) 0 ;
        char **result = (char **) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ldap_get_values(ld,entry,target);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_get_values. Expected _p_LDAP");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_LDAPMessage,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_get_values. Expected _p_LDAPMessage");
            }
        }
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        result = (char **)ldap_get_values(arg1,arg2,(char const *)arg3);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_p_char, 0|0);
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_count_values) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        char **arg1 = (char **) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ldap_count_values(vals);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_p_char,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_count_values. Expected _p_p_char");
            }
        }
        result = (int)ldap_count_values(arg1);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_value_free) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        char **arg1 = (char **) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ldap_value_free(vals);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_p_char,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_value_free. Expected _p_p_char");
            }
        }
        ldap_value_free(arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_msgtype) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPMessage *arg1 = (LDAPMessage *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ldap_msgtype(lm);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPMessage,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_msgtype. Expected _p_LDAPMessage");
            }
        }
        result = (int)ldap_msgtype(arg1);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_msgid) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPMessage *arg1 = (LDAPMessage *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ldap_msgid(lm);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPMessage,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_msgid. Expected _p_LDAPMessage");
            }
        }
        result = (int)ldap_msgid(arg1);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_msgfree) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPMessage *arg1 = (LDAPMessage *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ldap_msgfree(lm);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPMessage,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_msgfree. Expected _p_LDAPMessage");
            }
        }
        result = (int)ldap_msgfree(arg1);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_msgdelete) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        int arg2 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ldap_msgdelete(ld,msgid);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_msgdelete. Expected _p_LDAP");
            }
        }
        arg2 = (int) SvIV(ST(1));
        result = (int)ldap_msgdelete(arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_unbind) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ldap_unbind(ld);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_unbind. Expected _p_LDAP");
            }
        }
        result = (int)ldap_unbind(arg1);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_unbind_s) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ldap_unbind_s(ld);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_unbind_s. Expected _p_LDAP");
            }
        }
        result = (int)ldap_unbind_s(arg1);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_unbind_ext) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        LDAPControl **arg2 = (LDAPControl **) 0 ;
        LDAPControl **arg3 = (LDAPControl **) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ldap_unbind_ext(ld,serverctrls,clientctrls);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_unbind_ext. Expected _p_LDAP");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_unbind_ext. Expected _p_p_LDAPControl");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 3 of ldap_unbind_ext. Expected _p_p_LDAPControl");
            }
        }
        result = (int)ldap_unbind_ext(arg1,arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_unbind_ext_s) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        LDAPControl **arg2 = (LDAPControl **) 0 ;
        LDAPControl **arg3 = (LDAPControl **) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ldap_unbind_ext_s(ld,serverctrls,clientctrls);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_unbind_ext_s. Expected _p_LDAP");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_unbind_ext_s. Expected _p_p_LDAPControl");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 3 of ldap_unbind_ext_s. Expected _p_p_LDAPControl");
            }
        }
        result = (int)ldap_unbind_ext_s(arg1,arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_put_vrFilter) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        BerElement *arg1 = (BerElement *) 0 ;
        char *arg2 = (char *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ldap_put_vrFilter(ber,vrf);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BerElement,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_put_vrFilter. Expected _p_BerElement");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        result = (int)ldap_put_vrFilter(arg1,(char const *)arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_memalloc) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ber_len_t arg1 ;
        void *result = (void *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ldap_memalloc(s);");
        }
        {
            ber_len_t * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_ber_len_t,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_memalloc. Expected _p_ber_len_t");
            }
            arg1 = *argp;
        }
        result = (void *)ldap_memalloc(arg1);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_void, 0|0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_memrealloc) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        void *arg1 = (void *) 0 ;
        ber_len_t arg2 ;
        void *result = (void *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ldap_memrealloc(p,s);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, 0,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_memrealloc. Expected _p_void");
            }
        }
        {
            ber_len_t * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_ber_len_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_memrealloc. Expected _p_ber_len_t");
            }
            arg2 = *argp;
        }
        result = (void *)ldap_memrealloc(arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_void, 0|0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_memcalloc) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ber_len_t arg1 ;
        ber_len_t arg2 ;
        void *result = (void *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ldap_memcalloc(n,s);");
        }
        {
            ber_len_t * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_ber_len_t,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_memcalloc. Expected _p_ber_len_t");
            }
            arg1 = *argp;
        }
        {
            ber_len_t * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_ber_len_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_memcalloc. Expected _p_ber_len_t");
            }
            arg2 = *argp;
        }
        result = (void *)ldap_memcalloc(arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_void, 0|0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_memfree) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        void *arg1 = (void *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ldap_memfree(p);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, 0,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_memfree. Expected _p_void");
            }
        }
        ldap_memfree(arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_memvfree) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        void **arg1 = (void **) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ldap_memvfree(v);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_p_void,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_memvfree. Expected _p_p_void");
            }
        }
        ldap_memvfree(arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_strdup) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        char *arg1 = (char *) 0 ;
        char *result = (char *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ldap_strdup(char const *);");
        }
        if (!SvOK((SV*) ST(0))) arg1 = 0;
        else arg1 = (char *) SvPV(ST(0), PL_na);
        result = (char *)ldap_strdup((char const *)arg1);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        } else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_mods_free) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPMod **arg1 = (LDAPMod **) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ldap_mods_free(mods,freemods);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_p_LDAPMod,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_mods_free. Expected _p_p_LDAPMod");
            }
        }
        arg2 = (int) SvIV(ST(1));
        ldap_mods_free(arg1,arg2);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_sort_entries) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        LDAPMessage **arg2 = (LDAPMessage **) 0 ;
        char *arg3 = (char *) 0 ;
        LDAP_SORT_AD_CMP_PROC *arg4 = (LDAP_SORT_AD_CMP_PROC *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: ldap_sort_entries(ld,chain,attr,cmp);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_sort_entries. Expected _p_LDAP");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_p_LDAPMessage,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_sort_entries. Expected _p_p_LDAPMessage");
            }
        }
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_LDAP_SORT_AD_CMP_PROC,0) < 0) {
                SWIG_croak("Type error in argument 4 of ldap_sort_entries. Expected _p_LDAP_SORT_AD_CMP_PROC");
            }
        }
        result = (int)ldap_sort_entries(arg1,arg2,(char const *)arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_sort_values) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        char **arg2 = (char **) 0 ;
        LDAP_SORT_AV_CMP_PROC *arg3 = (LDAP_SORT_AV_CMP_PROC *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ldap_sort_values(ld,vals,cmp);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_sort_values. Expected _p_LDAP");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_p_char,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_sort_values. Expected _p_p_char");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_LDAP_SORT_AV_CMP_PROC,0) < 0) {
                SWIG_croak("Type error in argument 3 of ldap_sort_values. Expected _p_LDAP_SORT_AV_CMP_PROC");
            }
        }
        result = (int)ldap_sort_values(arg1,arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_sort_strcasecmp) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        void *arg1 = (void *) 0 ;
        void *arg2 = (void *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ldap_sort_strcasecmp(a,b);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, 0,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_sort_strcasecmp. Expected _p_void");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, 0,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_sort_strcasecmp. Expected _p_void");
            }
        }
        result = (int)ldap_sort_strcasecmp((void const *)arg1,(void const *)arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_is_ldap_url) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        char *arg1 = (char *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ldap_is_ldap_url(url);");
        }
        if (!SvOK((SV*) ST(0))) arg1 = 0;
        else arg1 = (char *) SvPV(ST(0), PL_na);
        result = (int)ldap_is_ldap_url((char const *)arg1);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_is_ldaps_url) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        char *arg1 = (char *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ldap_is_ldaps_url(url);");
        }
        if (!SvOK((SV*) ST(0))) arg1 = 0;
        else arg1 = (char *) SvPV(ST(0), PL_na);
        result = (int)ldap_is_ldaps_url((char const *)arg1);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_is_ldapi_url) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        char *arg1 = (char *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ldap_is_ldapi_url(url);");
        }
        if (!SvOK((SV*) ST(0))) arg1 = 0;
        else arg1 = (char *) SvPV(ST(0), PL_na);
        result = (int)ldap_is_ldapi_url((char const *)arg1);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_url_parse) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        char *arg1 = (char *) 0 ;
        LDAPURLDesc **arg2 = (LDAPURLDesc **) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ldap_url_parse(url,ludpp);");
        }
        if (!SvOK((SV*) ST(0))) arg1 = 0;
        else arg1 = (char *) SvPV(ST(0), PL_na);
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_p_LDAPURLDesc,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_url_parse. Expected _p_p_LDAPURLDesc");
            }
        }
        result = (int)ldap_url_parse((char const *)arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_url_desc2str) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPURLDesc *arg1 = (LDAPURLDesc *) 0 ;
        char *result = (char *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ldap_url_desc2str(ludp);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPURLDesc,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_url_desc2str. Expected _p_LDAPURLDesc");
            }
        }
        result = (char *)ldap_url_desc2str(arg1);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        } else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_free_urldesc) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPURLDesc *arg1 = (LDAPURLDesc *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ldap_free_urldesc(ludp);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPURLDesc,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_free_urldesc. Expected _p_LDAPURLDesc");
            }
        }
        ldap_free_urldesc(arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_LDAPSortKey_attributeType_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPSortKey *arg1 = (LDAPSortKey *) 0 ;
        char *arg2 = (char *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: LDAPSortKey_attributeType_set(self,attributeType);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPSortKey,0) < 0) {
                SWIG_croak("Type error in argument 1 of LDAPSortKey_attributeType_set. Expected _p_LDAPSortKey");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            if (arg1->attributeType) free((char*)arg1->attributeType);
            if (arg2) {
                arg1->attributeType = (char *) malloc(strlen(arg2)+1);
                strcpy((char*)arg1->attributeType,arg2);
            } else {
                arg1->attributeType = 0;
            }
        }
        
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_LDAPSortKey_attributeType_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPSortKey *arg1 = (LDAPSortKey *) 0 ;
        char *result = (char *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: LDAPSortKey_attributeType_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPSortKey,0) < 0) {
                SWIG_croak("Type error in argument 1 of LDAPSortKey_attributeType_get. Expected _p_LDAPSortKey");
            }
        }
        result = (char *) ((arg1)->attributeType);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        } else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_LDAPSortKey_orderingRule_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPSortKey *arg1 = (LDAPSortKey *) 0 ;
        char *arg2 = (char *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: LDAPSortKey_orderingRule_set(self,orderingRule);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPSortKey,0) < 0) {
                SWIG_croak("Type error in argument 1 of LDAPSortKey_orderingRule_set. Expected _p_LDAPSortKey");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            if (arg1->orderingRule) free((char*)arg1->orderingRule);
            if (arg2) {
                arg1->orderingRule = (char *) malloc(strlen(arg2)+1);
                strcpy((char*)arg1->orderingRule,arg2);
            } else {
                arg1->orderingRule = 0;
            }
        }
        
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_LDAPSortKey_orderingRule_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPSortKey *arg1 = (LDAPSortKey *) 0 ;
        char *result = (char *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: LDAPSortKey_orderingRule_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPSortKey,0) < 0) {
                SWIG_croak("Type error in argument 1 of LDAPSortKey_orderingRule_get. Expected _p_LDAPSortKey");
            }
        }
        result = (char *) ((arg1)->orderingRule);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        } else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_LDAPSortKey_reverseOrder_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPSortKey *arg1 = (LDAPSortKey *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: LDAPSortKey_reverseOrder_set(self,reverseOrder);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPSortKey,0) < 0) {
                SWIG_croak("Type error in argument 1 of LDAPSortKey_reverseOrder_set. Expected _p_LDAPSortKey");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->reverseOrder = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_LDAPSortKey_reverseOrder_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPSortKey *arg1 = (LDAPSortKey *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: LDAPSortKey_reverseOrder_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPSortKey,0) < 0) {
                SWIG_croak("Type error in argument 1 of LDAPSortKey_reverseOrder_get. Expected _p_LDAPSortKey");
            }
        }
        result = (int) ((arg1)->reverseOrder);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_new_LDAPSortKey) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPSortKey *result = (LDAPSortKey *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 0) || (items > 0)) {
            SWIG_croak("Usage: new_LDAPSortKey();");
        }
        result = (LDAPSortKey *)(LDAPSortKey *) calloc(1, sizeof(LDAPSortKey));
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_LDAPSortKey, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_delete_LDAPSortKey) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPSortKey *arg1 = (LDAPSortKey *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_LDAPSortKey(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPSortKey,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_LDAPSortKey. Expected _p_LDAPSortKey");
            }
        }
        free((char *) arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_create_sort_keylist) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPSortKey ***arg1 = (LDAPSortKey ***) 0 ;
        char *arg2 = (char *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ldap_create_sort_keylist(sortKeyList,keyString);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_p_p_LDAPSortKey,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_create_sort_keylist. Expected _p_p_p_LDAPSortKey");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        result = (int)ldap_create_sort_keylist(arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        
        XSRETURN(argvi);
        fail:
        
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_free_sort_keylist) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPSortKey **arg1 = (LDAPSortKey **) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ldap_free_sort_keylist(sortkeylist);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_p_LDAPSortKey,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_free_sort_keylist. Expected _p_p_LDAPSortKey");
            }
        }
        ldap_free_sort_keylist(arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_create_sort_control) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        LDAPSortKey **arg2 = (LDAPSortKey **) 0 ;
        int arg3 ;
        LDAPControl **arg4 = (LDAPControl **) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: ldap_create_sort_control(ld,keyList,ctl_iscritical,ctrlp);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_create_sort_control. Expected _p_LDAP");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_p_LDAPSortKey,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_create_sort_control. Expected _p_p_LDAPSortKey");
            }
        }
        arg3 = (int) SvIV(ST(2));
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 4 of ldap_create_sort_control. Expected _p_p_LDAPControl");
            }
        }
        result = (int)ldap_create_sort_control(arg1,arg2,arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_parse_sort_control) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        LDAPControl **arg2 = (LDAPControl **) 0 ;
        unsigned long *arg3 = (unsigned long *) 0 ;
        char **arg4 = (char **) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: ldap_parse_sort_control(ld,ctrlp,result,attribute);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_parse_sort_control. Expected _p_LDAP");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_parse_sort_control. Expected _p_p_LDAPControl");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_unsigned_long,0) < 0) {
                SWIG_croak("Type error in argument 3 of ldap_parse_sort_control. Expected _p_unsigned_long");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_p_char,0) < 0) {
                SWIG_croak("Type error in argument 4 of ldap_parse_sort_control. Expected _p_p_char");
            }
        }
        result = (int)ldap_parse_sort_control(arg1,arg2,arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_LDAPVLVInfo_ldvlv_version_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPVLVInfo *arg1 = (LDAPVLVInfo *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: LDAPVLVInfo_ldvlv_version_set(self,ldvlv_version);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPVLVInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of LDAPVLVInfo_ldvlv_version_set. Expected _p_LDAPVLVInfo");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->ldvlv_version = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_LDAPVLVInfo_ldvlv_version_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPVLVInfo *arg1 = (LDAPVLVInfo *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: LDAPVLVInfo_ldvlv_version_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPVLVInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of LDAPVLVInfo_ldvlv_version_get. Expected _p_LDAPVLVInfo");
            }
        }
        result = (int) ((arg1)->ldvlv_version);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_LDAPVLVInfo_ldvlv_before_count_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPVLVInfo *arg1 = (LDAPVLVInfo *) 0 ;
        unsigned long arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: LDAPVLVInfo_ldvlv_before_count_set(self,ldvlv_before_count);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPVLVInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of LDAPVLVInfo_ldvlv_before_count_set. Expected _p_LDAPVLVInfo");
            }
        }
        arg2 = (unsigned long) SvUV(ST(1));
        if (arg1) (arg1)->ldvlv_before_count = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_LDAPVLVInfo_ldvlv_before_count_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPVLVInfo *arg1 = (LDAPVLVInfo *) 0 ;
        unsigned long result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: LDAPVLVInfo_ldvlv_before_count_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPVLVInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of LDAPVLVInfo_ldvlv_before_count_get. Expected _p_LDAPVLVInfo");
            }
        }
        result = (unsigned long) ((arg1)->ldvlv_before_count);
        
        ST(argvi) = sv_newmortal();
        sv_setuv(ST(argvi++), (UV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_LDAPVLVInfo_ldvlv_after_count_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPVLVInfo *arg1 = (LDAPVLVInfo *) 0 ;
        unsigned long arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: LDAPVLVInfo_ldvlv_after_count_set(self,ldvlv_after_count);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPVLVInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of LDAPVLVInfo_ldvlv_after_count_set. Expected _p_LDAPVLVInfo");
            }
        }
        arg2 = (unsigned long) SvUV(ST(1));
        if (arg1) (arg1)->ldvlv_after_count = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_LDAPVLVInfo_ldvlv_after_count_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPVLVInfo *arg1 = (LDAPVLVInfo *) 0 ;
        unsigned long result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: LDAPVLVInfo_ldvlv_after_count_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPVLVInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of LDAPVLVInfo_ldvlv_after_count_get. Expected _p_LDAPVLVInfo");
            }
        }
        result = (unsigned long) ((arg1)->ldvlv_after_count);
        
        ST(argvi) = sv_newmortal();
        sv_setuv(ST(argvi++), (UV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_LDAPVLVInfo_ldvlv_offset_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPVLVInfo *arg1 = (LDAPVLVInfo *) 0 ;
        unsigned long arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: LDAPVLVInfo_ldvlv_offset_set(self,ldvlv_offset);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPVLVInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of LDAPVLVInfo_ldvlv_offset_set. Expected _p_LDAPVLVInfo");
            }
        }
        arg2 = (unsigned long) SvUV(ST(1));
        if (arg1) (arg1)->ldvlv_offset = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_LDAPVLVInfo_ldvlv_offset_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPVLVInfo *arg1 = (LDAPVLVInfo *) 0 ;
        unsigned long result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: LDAPVLVInfo_ldvlv_offset_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPVLVInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of LDAPVLVInfo_ldvlv_offset_get. Expected _p_LDAPVLVInfo");
            }
        }
        result = (unsigned long) ((arg1)->ldvlv_offset);
        
        ST(argvi) = sv_newmortal();
        sv_setuv(ST(argvi++), (UV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_LDAPVLVInfo_ldvlv_count_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPVLVInfo *arg1 = (LDAPVLVInfo *) 0 ;
        unsigned long arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: LDAPVLVInfo_ldvlv_count_set(self,ldvlv_count);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPVLVInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of LDAPVLVInfo_ldvlv_count_set. Expected _p_LDAPVLVInfo");
            }
        }
        arg2 = (unsigned long) SvUV(ST(1));
        if (arg1) (arg1)->ldvlv_count = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_LDAPVLVInfo_ldvlv_count_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPVLVInfo *arg1 = (LDAPVLVInfo *) 0 ;
        unsigned long result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: LDAPVLVInfo_ldvlv_count_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPVLVInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of LDAPVLVInfo_ldvlv_count_get. Expected _p_LDAPVLVInfo");
            }
        }
        result = (unsigned long) ((arg1)->ldvlv_count);
        
        ST(argvi) = sv_newmortal();
        sv_setuv(ST(argvi++), (UV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_LDAPVLVInfo_ldvlv_attrvalue_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPVLVInfo *arg1 = (LDAPVLVInfo *) 0 ;
        struct berval *arg2 = (struct berval *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: LDAPVLVInfo_ldvlv_attrvalue_set(self,ldvlv_attrvalue);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPVLVInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of LDAPVLVInfo_ldvlv_attrvalue_set. Expected _p_LDAPVLVInfo");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 2 of LDAPVLVInfo_ldvlv_attrvalue_set. Expected _p_berval");
            }
        }
        if (arg1) (arg1)->ldvlv_attrvalue = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_LDAPVLVInfo_ldvlv_attrvalue_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPVLVInfo *arg1 = (LDAPVLVInfo *) 0 ;
        struct berval *result = (struct berval *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: LDAPVLVInfo_ldvlv_attrvalue_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPVLVInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of LDAPVLVInfo_ldvlv_attrvalue_get. Expected _p_LDAPVLVInfo");
            }
        }
        result = (struct berval *) ((arg1)->ldvlv_attrvalue);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_berval, SWIG_SHADOW|0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_LDAPVLVInfo_ldvlv_context_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPVLVInfo *arg1 = (LDAPVLVInfo *) 0 ;
        struct berval *arg2 = (struct berval *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: LDAPVLVInfo_ldvlv_context_set(self,ldvlv_context);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPVLVInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of LDAPVLVInfo_ldvlv_context_set. Expected _p_LDAPVLVInfo");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 2 of LDAPVLVInfo_ldvlv_context_set. Expected _p_berval");
            }
        }
        if (arg1) (arg1)->ldvlv_context = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_LDAPVLVInfo_ldvlv_context_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPVLVInfo *arg1 = (LDAPVLVInfo *) 0 ;
        struct berval *result = (struct berval *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: LDAPVLVInfo_ldvlv_context_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPVLVInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of LDAPVLVInfo_ldvlv_context_get. Expected _p_LDAPVLVInfo");
            }
        }
        result = (struct berval *) ((arg1)->ldvlv_context);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_berval, SWIG_SHADOW|0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_LDAPVLVInfo_ldvlv_extradata_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPVLVInfo *arg1 = (LDAPVLVInfo *) 0 ;
        void *arg2 = (void *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: LDAPVLVInfo_ldvlv_extradata_set(self,ldvlv_extradata);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPVLVInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of LDAPVLVInfo_ldvlv_extradata_set. Expected _p_LDAPVLVInfo");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, 0,0) < 0) {
                SWIG_croak("Type error in argument 2 of LDAPVLVInfo_ldvlv_extradata_set. Expected _p_void");
            }
        }
        if (arg1) (arg1)->ldvlv_extradata = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_LDAPVLVInfo_ldvlv_extradata_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPVLVInfo *arg1 = (LDAPVLVInfo *) 0 ;
        void *result = (void *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: LDAPVLVInfo_ldvlv_extradata_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPVLVInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of LDAPVLVInfo_ldvlv_extradata_get. Expected _p_LDAPVLVInfo");
            }
        }
        result = (void *) ((arg1)->ldvlv_extradata);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_void, 0|0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_new_LDAPVLVInfo) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPVLVInfo *result = (LDAPVLVInfo *) 0;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 0) || (items > 0)) {
            SWIG_croak("Usage: new_LDAPVLVInfo();");
        }
        result = (LDAPVLVInfo *)(LDAPVLVInfo *) calloc(1, sizeof(LDAPVLVInfo));
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_LDAPVLVInfo, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_delete_LDAPVLVInfo) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAPVLVInfo *arg1 = (LDAPVLVInfo *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_LDAPVLVInfo(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAPVLVInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_LDAPVLVInfo. Expected _p_LDAPVLVInfo");
            }
        }
        free((char *) arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_create_vlv_control) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        LDAPVLVInfo *arg2 = (LDAPVLVInfo *) 0 ;
        LDAPControl **arg3 = (LDAPControl **) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ldap_create_vlv_control(ld,ldvlistp,ctrlp);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_create_vlv_control. Expected _p_LDAP");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_LDAPVLVInfo,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_create_vlv_control. Expected _p_LDAPVLVInfo");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 3 of ldap_create_vlv_control. Expected _p_p_LDAPControl");
            }
        }
        result = (int)ldap_create_vlv_control(arg1,arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_parse_vlv_control) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        LDAPControl **arg2 = (LDAPControl **) 0 ;
        unsigned long *arg3 = (unsigned long *) 0 ;
        unsigned long *arg4 = (unsigned long *) 0 ;
        struct berval **arg5 = (struct berval **) 0 ;
        int *arg6 = (int *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 6) || (items > 6)) {
            SWIG_croak("Usage: ldap_parse_vlv_control(ld,ctrls,target_posp,list_countp,contextp,errcodep);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_parse_vlv_control. Expected _p_LDAP");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_parse_vlv_control. Expected _p_p_LDAPControl");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_unsigned_long,0) < 0) {
                SWIG_croak("Type error in argument 3 of ldap_parse_vlv_control. Expected _p_unsigned_long");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_unsigned_long,0) < 0) {
                SWIG_croak("Type error in argument 4 of ldap_parse_vlv_control. Expected _p_unsigned_long");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(4), (void **) &arg5, SWIGTYPE_p_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 5 of ldap_parse_vlv_control. Expected _p_p_berval");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(5), (void **) &arg6, SWIGTYPE_p_int,0) < 0) {
                SWIG_croak("Type error in argument 6 of ldap_parse_vlv_control. Expected _p_int");
            }
        }
        result = (int)ldap_parse_vlv_control(arg1,arg2,arg3,arg4,arg5,arg6);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_parse_whoami) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        LDAPMessage *arg2 = (LDAPMessage *) 0 ;
        struct berval **arg3 = (struct berval **) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ldap_parse_whoami(ld,res,authzid);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_parse_whoami. Expected _p_LDAP");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_LDAPMessage,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_parse_whoami. Expected _p_LDAPMessage");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 3 of ldap_parse_whoami. Expected _p_p_berval");
            }
        }
        result = (int)ldap_parse_whoami(arg1,arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_whoami) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        LDAPControl **arg2 = (LDAPControl **) 0 ;
        LDAPControl **arg3 = (LDAPControl **) 0 ;
        int *arg4 = (int *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: ldap_whoami(ld,sctrls,cctrls,msgidp);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_whoami. Expected _p_LDAP");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_whoami. Expected _p_p_LDAPControl");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 3 of ldap_whoami. Expected _p_p_LDAPControl");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_int,0) < 0) {
                SWIG_croak("Type error in argument 4 of ldap_whoami. Expected _p_int");
            }
        }
        result = (int)ldap_whoami(arg1,arg2,arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_whoami_s) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        struct berval **arg2 = (struct berval **) 0 ;
        LDAPControl **arg3 = (LDAPControl **) 0 ;
        LDAPControl **arg4 = (LDAPControl **) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: ldap_whoami_s(ld,authzid,sctrls,cctrls);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_whoami_s. Expected _p_LDAP");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_whoami_s. Expected _p_p_berval");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 3 of ldap_whoami_s. Expected _p_p_LDAPControl");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 4 of ldap_whoami_s. Expected _p_p_LDAPControl");
            }
        }
        result = (int)ldap_whoami_s(arg1,arg2,arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_parse_passwd) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        LDAPMessage *arg2 = (LDAPMessage *) 0 ;
        struct berval *arg3 = (struct berval *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: ldap_parse_passwd(ld,res,newpasswd);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_parse_passwd. Expected _p_LDAP");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_LDAPMessage,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_parse_passwd. Expected _p_LDAPMessage");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 3 of ldap_parse_passwd. Expected _p_berval");
            }
        }
        result = (int)ldap_parse_passwd(arg1,arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_passwd) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        struct berval *arg2 = (struct berval *) 0 ;
        struct berval *arg3 = (struct berval *) 0 ;
        struct berval *arg4 = (struct berval *) 0 ;
        LDAPControl **arg5 = (LDAPControl **) 0 ;
        LDAPControl **arg6 = (LDAPControl **) 0 ;
        int *arg7 = (int *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 7) || (items > 7)) {
            SWIG_croak("Usage: ldap_passwd(ld,user,oldpw,newpw,sctrls,cctrls,msgidp);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_passwd. Expected _p_LDAP");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_passwd. Expected _p_berval");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 3 of ldap_passwd. Expected _p_berval");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 4 of ldap_passwd. Expected _p_berval");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(4), (void **) &arg5, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 5 of ldap_passwd. Expected _p_p_LDAPControl");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(5), (void **) &arg6, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 6 of ldap_passwd. Expected _p_p_LDAPControl");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(6), (void **) &arg7, SWIGTYPE_p_int,0) < 0) {
                SWIG_croak("Type error in argument 7 of ldap_passwd. Expected _p_int");
            }
        }
        result = (int)ldap_passwd(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ldap_passwd_s) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        LDAP *arg1 = (LDAP *) 0 ;
        struct berval *arg2 = (struct berval *) 0 ;
        struct berval *arg3 = (struct berval *) 0 ;
        struct berval *arg4 = (struct berval *) 0 ;
        struct berval *arg5 = (struct berval *) 0 ;
        LDAPControl **arg6 = (LDAPControl **) 0 ;
        LDAPControl **arg7 = (LDAPControl **) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 7) || (items > 7)) {
            SWIG_croak("Usage: ldap_passwd_s(ld,user,oldpw,newpw,newpasswd,sctrls,cctrls);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LDAP,0) < 0) {
                SWIG_croak("Type error in argument 1 of ldap_passwd_s. Expected _p_LDAP");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 2 of ldap_passwd_s. Expected _p_berval");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 3 of ldap_passwd_s. Expected _p_berval");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 4 of ldap_passwd_s. Expected _p_berval");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(4), (void **) &arg5, SWIGTYPE_p_berval,0) < 0) {
                SWIG_croak("Type error in argument 5 of ldap_passwd_s. Expected _p_berval");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(5), (void **) &arg6, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 6 of ldap_passwd_s. Expected _p_p_LDAPControl");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(6), (void **) &arg7, SWIGTYPE_p_p_LDAPControl,0) < 0) {
                SWIG_croak("Type error in argument 7 of ldap_passwd_s. Expected _p_p_LDAPControl");
            }
        }
        result = (int)ldap_passwd_s(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}



/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static swig_type_info _swigt__p_ber_slen_t[] = {{"_p_ber_slen_t", 0, "ber_slen_t *", 0},{"_p_ber_slen_t"},{0}};
static swig_type_info _swigt__p_ldap[] = {{"OnLDAP::Base::Client", 0, "ldap *", 0},{"OnLDAP::Base::Client"},{"_p_LDAP"},{0}};
static swig_type_info _swigt__p_LDAPDN_rewrite_func[] = {{"_p_LDAPDN_rewrite_func", 0, "LDAPDN_rewrite_func *", 0},{"_p_LDAPDN_rewrite_func"},{0}};
static swig_type_info _swigt__p_ldap_url_desc[] = {{"_p_ldap_url_desc", 0, "struct ldap_url_desc *", 0},{"OnLDAP::Base::URLDesc"},{"_p_ldap_url_desc"},{0}};
static swig_type_info _swigt__p_Sockbuf[] = {{"_p_Sockbuf", 0, "Sockbuf *", 0},{"_p_Sockbuf"},{0}};
static swig_type_info _swigt__p_p_LDAPMessage[] = {{"_p_p_LDAPMessage", 0, "LDAPMessage **", 0},{"_p_p_LDAPMessage"},{0}};
static swig_type_info _swigt__p_LDAPMessage[] = {{"_p_LDAPMessage", 0, "LDAPMessage *", 0},{"OnLDAP::Base::Message"},{"_p_LDAPMessage"},{0}};
static swig_type_info _swigt__p_LDAP_SASL_INTERACT_PROC[] = {{"_p_LDAP_SASL_INTERACT_PROC", 0, "LDAP_SASL_INTERACT_PROC *", 0},{"_p_LDAP_SASL_INTERACT_PROC"},{0}};
static swig_type_info _swigt__p_LDAPVLVInfo[] = {{"OnLDAP::Base::LDAPVLVInfo", 0, "LDAPVLVInfo *", 0},{"OnLDAP::Base::LDAPVLVInfo"},{0}};
static swig_type_info _swigt__STRING[] = {{"_STRING", 0, "STRING", 0},{"_STRING"},{0}};
static swig_type_info _swigt__p_p_STRING[] = {{"_p_p_STRING", 0, "STRING **", 0},{"_p_p_p_char"},{"_p_p_STRING"},{0}};
static swig_type_info _swigt__p_p_char[] = {{"_p_p_char", 0, "char **", 0},{"_p_p_char"},{0}};
static swig_type_info _swigt__p_LDAP_REBIND_PROC[] = {{"_p_LDAP_REBIND_PROC", 0, "LDAP_REBIND_PROC *", 0},{"_p_LDAP_REBIND_PROC"},{0}};
static swig_type_info _swigt__p_p_p_char[] = {{"_p_p_p_char", 0, "char ***", 0},{"_p_p_p_char"},{"_p_p_STRING"},{0}};
static swig_type_info _swigt__p_LDAPRDN[] = {{"_p_LDAPRDN", 0, "LDAPRDN *", 0},{"_p_LDAPRDN"},{0}};
static swig_type_info _swigt__p_p_LDAPRDN[] = {{"_p_p_LDAPRDN", 0, "LDAPRDN **", 0},{"_p_p_LDAPRDN"},{0}};
static swig_type_info _swigt__p_LDAPSortKey[] = {{"OnLDAP::Base::LDAPSortKey", 0, "LDAPSortKey *", 0},{"OnLDAP::Base::LDAPSortKey"},{0}};
static swig_type_info _swigt__p_p_p_LDAPSortKey[] = {{"_p_p_p_LDAPSortKey", 0, "LDAPSortKey ***", 0},{"_p_p_p_LDAPSortKey"},{0}};
static swig_type_info _swigt__p_p_LDAPSortKey[] = {{"_p_p_LDAPSortKey", 0, "LDAPSortKey **", 0},{"_p_p_LDAPSortKey"},{0}};
static swig_type_info _swigt__p_Seqorset[] = {{"_p_Seqorset", 0, "Seqorset *", 0},{"_p_Seqorset"},{0}};
static swig_type_info _swigt__p_void[] = {{"_p_void", 0, "void *", 0},{"_p_void"},{0}};
static swig_type_info _swigt__p_p_void[] = {{"_p_p_void", 0, "void **", 0},{"_p_p_void"},{0}};
static swig_type_info _swigt__p_p_p_LDAPControl[] = {{"_p_p_p_LDAPControl", 0, "LDAPControl ***", 0},{"_p_p_p_LDAPControl"},{0}};
static swig_type_info _swigt__p_LDAPControl[] = {{"OnLDAP::Base::Control", 0, "LDAPControl *", 0},{"OnLDAP::Base::Control"},{0}};
static swig_type_info _swigt__p_p_LDAPControl[] = {{"_p_p_LDAPControl", 0, "LDAPControl **", 0},{"_p_p_LDAPControl"},{0}};
static swig_type_info _swigt__p_Sockbuf_IO[] = {{"_p_Sockbuf_IO", 0, "Sockbuf_IO *", 0},{"_p_Sockbuf_IO"},{0}};
static swig_type_info _swigt__p_LDAPMod_mod_vals[] = {{"OnLDAP::Base::LDAPMod_mod_vals", 0, "LDAPMod_mod_vals *", 0},{"OnLDAP::Base::LDAPMod_mod_vals"},{0}};
static swig_type_info _swigt__p_ber_tag_t[] = {{"_p_ber_tag_t", 0, "ber_tag_t *", 0},{"_p_ber_tag_t"},{0}};
static swig_type_info _swigt__p_BerVarray[] = {{"_p_BerVarray", 0, "BerVarray *", 0},{"_p_p_berval"},{"_p_BerVarray"},{"_p_p_BerValue"},{0}};
static swig_type_info _swigt__p_ber_int_t[] = {{"_p_ber_int_t", 0, "ber_int_t *", 0},{"_p_ber_int_t"},{0}};
static swig_type_info _swigt__p_LDAPURLDesc[] = {{"OnLDAP::Base::URLDesc", 0, "LDAPURLDesc *", 0},{"OnLDAP::Base::URLDesc"},{"_p_ldap_url_desc"},{0}};
static swig_type_info _swigt__p_p_LDAPURLDesc[] = {{"_p_p_LDAPURLDesc", 0, "LDAPURLDesc **", 0},{"_p_p_LDAPURLDesc"},{0}};
static swig_type_info _swigt__p_ber_len_t[] = {{"_p_ber_len_t", 0, "ber_len_t *", 0},{"_p_ber_len_t"},{0}};
static swig_type_info _swigt__p_ldapmsg[] = {{"OnLDAP::Base::Message", 0, "ldapmsg *", 0},{"OnLDAP::Base::Message"},{"_p_LDAPMessage"},{0}};
static swig_type_info _swigt__p_p_berval[] = {{"_p_p_berval", 0, "struct berval **", 0},{"_p_p_berval"},{"_p_p_BerValue"},{"_p_BerVarray"},{0}};
static swig_type_info _swigt__p_berval[] = {{"_p_berval", 0, "struct berval *", 0},{"_p_berval"},{"OnLDAP::Base::BerValue"},{0}};
static swig_type_info _swigt__p_LDAPMod[] = {{"OnLDAP::Base::Mod", 0, "LDAPMod *", 0},{"OnLDAP::Base::Mod"},{0}};
static swig_type_info _swigt__p_p_LDAPMod[] = {{"_p_p_LDAPMod", 0, "LDAPMod **", 0},{"_p_p_LDAPMod"},{0}};
static swig_type_info _swigt__BerValue[] = {{"_BerValue", 0, "BerValue", 0},{"_BerValue"},{0}};
static swig_type_info _swigt__p_BerValue[] = {{"OnLDAP::Base::BerValue", 0, "BerValue *", 0},{"_p_berval"},{"OnLDAP::Base::BerValue"},{0}};
static swig_type_info _swigt__p_p_BerValue[] = {{"_p_p_BerValue", 0, "BerValue **", 0},{"_p_p_berval"},{"_p_p_BerValue"},{"_p_BerVarray"},{0}};
static swig_type_info _swigt__p_SV[] = {{"_p_SV", 0, "SV *", 0},{"_p_SV"},{0}};
static swig_type_info _swigt__p_timeval[] = {{"_p_timeval", 0, "struct timeval *", 0},{"_p_timeval"},{0}};
static swig_type_info _swigt__p_LDAPAPIFeatureInfo[] = {{"OnLDAP::Base::APIFeatureInfo", 0, "LDAPAPIFeatureInfo *", 0},{"OnLDAP::Base::APIFeatureInfo"},{0}};
static swig_type_info _swigt__p_LDAPDN[] = {{"_p_LDAPDN", 0, "LDAPDN *", 0},{"_p_LDAPDN"},{0}};
static swig_type_info _swigt__p_p_LDAPDN[] = {{"_p_p_LDAPDN", 0, "LDAPDN **", 0},{"_p_p_LDAPDN"},{0}};
static swig_type_info _swigt__p_BerElement[] = {{"_p_BerElement", 0, "BerElement *", 0},{"_p_BerElement"},{0}};
static swig_type_info _swigt__p_p_BerElement[] = {{"_p_p_BerElement", 0, "BerElement **", 0},{"_p_p_BerElement"},{0}};
static swig_type_info _swigt__p_int[] = {{"_p_int", 0, "int *", 0},{"_p_int"},{0}};
static swig_type_info _swigt__p_LDAPAVA[] = {{"OnLDAP::Base::AVA", 0, "LDAPAVA *", 0},{"OnLDAP::Base::AVA"},{0}};
static swig_type_info _swigt__p_LDAP[] = {{"_p_LDAP", 0, "LDAP *", 0},{"OnLDAP::Base::Client"},{"_p_LDAP"},{0}};
static swig_type_info _swigt__p_p_LDAP[] = {{"_p_p_LDAP", 0, "LDAP **", 0},{"_p_p_LDAP"},{0}};
static swig_type_info _swigt__p_LDAP_SORT_AD_CMP_PROC[] = {{"_p_LDAP_SORT_AD_CMP_PROC", 0, "LDAP_SORT_AD_CMP_PROC *", 0},{"_p_LDAP_SORT_AD_CMP_PROC"},{0}};
static swig_type_info _swigt__p_LDAP_SORT_AV_CMP_PROC[] = {{"_p_LDAP_SORT_AV_CMP_PROC", 0, "LDAP_SORT_AV_CMP_PROC *", 0},{"_p_LDAP_SORT_AV_CMP_PROC"},{0}};
static swig_type_info _swigt__p_unsigned_long[] = {{"_p_unsigned_long", 0, "unsigned long *", 0},{"_p_unsigned_long"},{0}};
static swig_type_info _swigt__p_LDAPAPIInfo[] = {{"OnLDAP::Base::APIInfo", 0, "LDAPAPIInfo *", 0},{"OnLDAP::Base::APIInfo"},{0}};

static swig_type_info *swig_types_initial[] = {
_swigt__p_ber_slen_t, 
_swigt__p_ldap, 
_swigt__p_LDAPDN_rewrite_func, 
_swigt__p_ldap_url_desc, 
_swigt__p_Sockbuf, 
_swigt__p_p_LDAPMessage, 
_swigt__p_LDAPMessage, 
_swigt__p_LDAP_SASL_INTERACT_PROC, 
_swigt__p_LDAPVLVInfo, 
_swigt__STRING, 
_swigt__p_p_STRING, 
_swigt__p_p_char, 
_swigt__p_LDAP_REBIND_PROC, 
_swigt__p_p_p_char, 
_swigt__p_LDAPRDN, 
_swigt__p_p_LDAPRDN, 
_swigt__p_LDAPSortKey, 
_swigt__p_p_p_LDAPSortKey, 
_swigt__p_p_LDAPSortKey, 
_swigt__p_Seqorset, 
_swigt__p_void, 
_swigt__p_p_void, 
_swigt__p_p_p_LDAPControl, 
_swigt__p_LDAPControl, 
_swigt__p_p_LDAPControl, 
_swigt__p_Sockbuf_IO, 
_swigt__p_LDAPMod_mod_vals, 
_swigt__p_ber_tag_t, 
_swigt__p_BerVarray, 
_swigt__p_ber_int_t, 
_swigt__p_LDAPURLDesc, 
_swigt__p_p_LDAPURLDesc, 
_swigt__p_ber_len_t, 
_swigt__p_ldapmsg, 
_swigt__p_p_berval, 
_swigt__p_berval, 
_swigt__p_LDAPMod, 
_swigt__p_p_LDAPMod, 
_swigt__BerValue, 
_swigt__p_BerValue, 
_swigt__p_p_BerValue, 
_swigt__p_SV, 
_swigt__p_timeval, 
_swigt__p_LDAPAPIFeatureInfo, 
_swigt__p_LDAPDN, 
_swigt__p_p_LDAPDN, 
_swigt__p_BerElement, 
_swigt__p_p_BerElement, 
_swigt__p_int, 
_swigt__p_LDAPAVA, 
_swigt__p_LDAP, 
_swigt__p_p_LDAP, 
_swigt__p_LDAP_SORT_AD_CMP_PROC, 
_swigt__p_LDAP_SORT_AV_CMP_PROC, 
_swigt__p_unsigned_long, 
_swigt__p_LDAPAPIInfo, 
0
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

static swig_constant_info swig_constants[] = {
{ SWIG_INT,     (char *) SWIG_prefix "LBER_USE_DER", (long) 0x01, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LBER_OPT_BER_OPTIONS", (long) 0x01, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LBER_OPT_BER_DEBUG", (long) 0x02, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LBER_OPT_BER_REMAINING_BYTES", (long) 0x03, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LBER_OPT_BER_TOTAL_BYTES", (long) 0x04, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LBER_OPT_BER_BYTES_TO_WRITE", (long) 0x05, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LBER_OPT_DEBUG_LEVEL", (long) 0x02, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LBER_OPT_REMAINING_BYTES", (long) 0x03, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LBER_OPT_TOTAL_BYTES", (long) 0x04, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LBER_OPT_BYTES_TO_WRITE", (long) 0x05, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LBER_OPT_LOG_PRINT_FN", (long) 0x8001, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LBER_OPT_MEMORY_FNS", (long) 0x8002, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LBER_OPT_ERROR_FN", (long) 0x8003, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LBER_OPT_LOG_PRINT_FILE", (long) 0x8004, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LBER_OPT_MEMORY_INUSE", (long) 0x8005, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LBER_OPT_LOG_PROC", (long) 0x8006, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LBER_SB_OPT_GET_FD", (long) 1, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LBER_SB_OPT_SET_FD", (long) 2, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LBER_SB_OPT_HAS_IO", (long) 3, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LBER_SB_OPT_SET_NONBLOCK", (long) 4, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LBER_SB_OPT_GET_SSL", (long) 7, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LBER_SB_OPT_DATA_READY", (long) 8, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LBER_SB_OPT_SET_READAHEAD", (long) 9, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LBER_SB_OPT_DRAIN", (long) 10, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LBER_SB_OPT_NEEDS_READ", (long) 11, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LBER_SB_OPT_NEEDS_WRITE", (long) 12, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LBER_SB_OPT_GET_MAX_INCOMING", (long) 13, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LBER_SB_OPT_SET_MAX_INCOMING", (long) 14, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LBER_SB_OPT_OPT_MAX", (long) 14, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LBER_SBIOD_LEVEL_PROVIDER", (long) 10, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LBER_SBIOD_LEVEL_TRANSPORT", (long) 20, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LBER_SBIOD_LEVEL_APPLICATION", (long) 30, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LBER_OPT_SOCKBUF_DESC", (long) 0x1000, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LBER_OPT_SOCKBUF_OPTIONS", (long) 0x1001, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LBER_OPT_SOCKBUF_DEBUG", (long) 0x1002, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LBER_OPT_SUCCESS", (long) (0), 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LBER_OPT_ERROR", (long) (-1), 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LBER_ELEMENT_SIZEOF", (long) (256), 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LBER_ERROR_NONE", (long) 0, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LBER_ERROR_PARAM", (long) 0x1, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LBER_ERROR_MEMORY", (long) 0x2, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_VERSION1", (long) 1, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_VERSION2", (long) 2, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_VERSION3", (long) 3, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_VERSION_MIN", (long) 2, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_VERSION", (long) 2, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_VERSION_MAX", (long) 3, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_API_VERSION", (long) 2004, 0, 0, 0},
{ SWIG_STRING,  (char *) SWIG_prefix "LDAP_VENDOR_NAME", 0, 0, (void *)"OpenLDAP", 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_PORT", (long) 389, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAPS_PORT", (long) 636, 0, 0, 0},
{ SWIG_STRING,  (char *) SWIG_prefix "LDAP_ROOT_DSE", 0, 0, (void *)"\0", 0},
{ SWIG_STRING,  (char *) SWIG_prefix "LDAP_NO_ATTRS", 0, 0, (void *)"1.1", 0},
{ SWIG_STRING,  (char *) SWIG_prefix "LDAP_ALL_USER_ATTRIBUTES", 0, 0, (void *)"*", 0},
{ SWIG_STRING,  (char *) SWIG_prefix "LDAP_ALL_OPERATIONAL_ATTRIBUTES", 0, 0, (void *)"+", 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_API_INFO", (long) 0x0000, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_DESC", (long) 0x0001, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_DEREF", (long) 0x0002, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_SIZELIMIT", (long) 0x0003, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_TIMELIMIT", (long) 0x0004, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_REFERRALS", (long) 0x0008, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_RESTART", (long) 0x0009, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_PROTOCOL_VERSION", (long) 0x0011, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_SERVER_CONTROLS", (long) 0x0012, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_CLIENT_CONTROLS", (long) 0x0013, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_API_FEATURE_INFO", (long) 0x0015, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_HOST_NAME", (long) 0x0030, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_ERROR_NUMBER", (long) 0x0031, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_ERROR_STRING", (long) 0x0032, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_MATCHED_DN", (long) 0x0033, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_PRIVATE_EXTENSION_BASE", (long) 0x4000, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_DEBUG_LEVEL", (long) 0x5001, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_TIMEOUT", (long) 0x5002, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_REFHOPLIMIT", (long) 0x5003, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_NETWORK_TIMEOUT", (long) 0x5005, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_URI", (long) 0x5006, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_REFERRAL_URLS", (long) 0x5007, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_X_TLS", (long) 0x6000, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_X_TLS_CTX", (long) 0x6001, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_X_TLS_CACERTFILE", (long) 0x6002, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_X_TLS_CACERTDIR", (long) 0x6003, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_X_TLS_CERTFILE", (long) 0x6004, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_X_TLS_KEYFILE", (long) 0x6005, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_X_TLS_REQUIRE_CERT", (long) 0x6006, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_X_TLS_CIPHER_SUITE", (long) 0x6008, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_X_TLS_RANDOM_FILE", (long) 0x6009, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_X_TLS_SSL_CTX", (long) 0x600a, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_X_TLS_NEVER", (long) 0, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_X_TLS_HARD", (long) 1, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_X_TLS_DEMAND", (long) 2, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_X_TLS_ALLOW", (long) 3, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_X_TLS_TRY", (long) 4, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_X_SASL_MECH", (long) 0x6100, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_X_SASL_REALM", (long) 0x6101, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_X_SASL_AUTHCID", (long) 0x6102, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_X_SASL_AUTHZID", (long) 0x6103, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_X_SASL_SSF", (long) 0x6104, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_X_SASL_SSF_EXTERNAL", (long) 0x6105, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_X_SASL_SECPROPS", (long) 0x6106, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_X_SASL_SSF_MIN", (long) 0x6107, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_X_SASL_SSF_MAX", (long) 0x6108, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_X_SASL_MAXBUFSIZE", (long) 0x6109, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_SUCCESS", (long) 0, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_ERROR", (long) (-1), 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_API_INFO_VERSION", (long) (1), 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_FEATURE_INFO_VERSION", (long) (1), 0, 0, 0},
{ SWIG_STRING,  (char *) SWIG_prefix "LDAP_CONTROL_VALUESRETURNFILTER", 0, 0, (void *)"1.2.826.0.1.334810.2.3", 0},
{ SWIG_STRING,  (char *) SWIG_prefix "LDAP_CONTROL_SUBENTRIES", 0, 0, (void *)"1.3.6.1.4.1.4203.1.10.1", 0},
{ SWIG_STRING,  (char *) SWIG_prefix "LDAP_CONTROL_NOOP", 0, 0, (void *)"1.3.6.1.4.1.4203.1.10.2", 0},
{ SWIG_STRING,  (char *) SWIG_prefix "LDAP_CONTROL_MANAGEDSAIT", 0, 0, (void *)"2.16.840.1.113730.3.4.2", 0},
{ SWIG_STRING,  (char *) SWIG_prefix "LDAP_CONTROL_PROXY_AUTHZ", 0, 0, (void *)"2.16.840.1.113730.3.4.18", 0},
{ SWIG_STRING,  (char *) SWIG_prefix "LDAP_CONTROL_SORTREQUEST", 0, 0, (void *)"1.2.840.113556.1.4.473", 0},
{ SWIG_STRING,  (char *) SWIG_prefix "LDAP_CONTROL_SORTRESPONSE", 0, 0, (void *)"1.2.840.113556.1.4.474", 0},
{ SWIG_STRING,  (char *) SWIG_prefix "LDAP_CONTROL_VLVREQUEST", 0, 0, (void *)"2.16.840.1.113730.3.4.9", 0},
{ SWIG_STRING,  (char *) SWIG_prefix "LDAP_CONTROL_VLVRESPONSE", 0, 0, (void *)"2.16.840.1.113730.3.4.10", 0},
{ SWIG_STRING,  (char *) SWIG_prefix "LDAP_NOTICE_OF_DISCONNECTION", 0, 0, (void *)"1.3.6.1.4.1.1466.20036", 0},
{ SWIG_STRING,  (char *) SWIG_prefix "LDAP_NOTICE_DISCONNECT", 0, 0, (void *)"1.3.6.1.4.1.1466.20036", 0},
{ SWIG_STRING,  (char *) SWIG_prefix "LDAP_EXOP_START_TLS", 0, 0, (void *)"1.3.6.1.4.1.1466.20037", 0},
{ SWIG_STRING,  (char *) SWIG_prefix "LDAP_EXOP_MODIFY_PASSWD", 0, 0, (void *)"1.3.6.1.4.1.4203.1.11.1", 0},
{ SWIG_STRING,  (char *) SWIG_prefix "LDAP_EXOP_X_WHO_AM_I", 0, 0, (void *)"1.3.6.1.4.1.4203.1.11.3", 0},
{ SWIG_STRING,  (char *) SWIG_prefix "LDAP_FEATURE_ALL_OPERATIONAL_ATTRS", 0, 0, (void *)"1.3.6.1.4.1.4203.1.5.1", 0},
{ SWIG_STRING,  (char *) SWIG_prefix "LDAP_FEATURE_OBJECTCLASS_ATTRS", 0, 0, (void *)"1.3.6.1.4.1.4203.1.5.2", 0},
{ SWIG_STRING,  (char *) SWIG_prefix "LDAP_FEATURE_ABSOLUTE_FILTERS", 0, 0, (void *)"1.3.6.1.4.1.4203.1.5.3", 0},
{ SWIG_STRING,  (char *) SWIG_prefix "LDAP_FEATURE_LANGUAGE_TAG_OPTIONS", 0, 0, (void *)"1.3.6.1.4.1.4203.1.5.4", 0},
{ SWIG_STRING,  (char *) SWIG_prefix "LDAP_FEATURE_LANGUAGE_RANGE_OPTIONS", 0, 0, (void *)"1.3.6.1.4.1.4203.1.5.5", 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_RES_ANY", (long) (-1), 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_RES_UNSOLICITED", (long) (0), 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_SUCCESS", (long) 0x00, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPERATIONS_ERROR", (long) 0x01, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_PROTOCOL_ERROR", (long) 0x02, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_TIMELIMIT_EXCEEDED", (long) 0x03, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_SIZELIMIT_EXCEEDED", (long) 0x04, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_COMPARE_FALSE", (long) 0x05, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_COMPARE_TRUE", (long) 0x06, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_AUTH_METHOD_NOT_SUPPORTED", (long) 0x07, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_STRONG_AUTH_NOT_SUPPORTED", (long) 0x07, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_STRONG_AUTH_REQUIRED", (long) 0x08, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_PARTIAL_RESULTS", (long) 0x09, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_REFERRAL", (long) 0x0a, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_ADMINLIMIT_EXCEEDED", (long) 0x0b, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_UNAVAILABLE_CRITICAL_EXTENSION", (long) 0x0c, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_CONFIDENTIALITY_REQUIRED", (long) 0x0d, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_SASL_BIND_IN_PROGRESS", (long) 0x0e, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_NO_SUCH_ATTRIBUTE", (long) 0x10, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_UNDEFINED_TYPE", (long) 0x11, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_INAPPROPRIATE_MATCHING", (long) 0x12, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_CONSTRAINT_VIOLATION", (long) 0x13, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_TYPE_OR_VALUE_EXISTS", (long) 0x14, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_INVALID_SYNTAX", (long) 0x15, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_NO_SUCH_OBJECT", (long) 0x20, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_ALIAS_PROBLEM", (long) 0x21, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_INVALID_DN_SYNTAX", (long) 0x22, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_IS_LEAF", (long) 0x23, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_ALIAS_DEREF_PROBLEM", (long) 0x24, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_PROXY_AUTHZ_FAILURE", (long) 0x2F, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_INAPPROPRIATE_AUTH", (long) 0x30, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_INVALID_CREDENTIALS", (long) 0x31, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_INSUFFICIENT_ACCESS", (long) 0x32, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_BUSY", (long) 0x33, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_UNAVAILABLE", (long) 0x34, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_UNWILLING_TO_PERFORM", (long) 0x35, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_LOOP_DETECT", (long) 0x36, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_NAMING_VIOLATION", (long) 0x40, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OBJECT_CLASS_VIOLATION", (long) 0x41, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_NOT_ALLOWED_ON_NONLEAF", (long) 0x42, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_NOT_ALLOWED_ON_RDN", (long) 0x43, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_ALREADY_EXISTS", (long) 0x44, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_NO_OBJECT_CLASS_MODS", (long) 0x45, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_RESULTS_TOO_LARGE", (long) 0x46, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_AFFECTS_MULTIPLE_DSAS", (long) 0x47, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OTHER", (long) 0x50, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_SERVER_DOWN", (long) 0x51, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_LOCAL_ERROR", (long) 0x52, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_ENCODING_ERROR", (long) 0x53, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_DECODING_ERROR", (long) 0x54, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_TIMEOUT", (long) 0x55, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_AUTH_UNKNOWN", (long) 0x56, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_FILTER_ERROR", (long) 0x57, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_USER_CANCELLED", (long) 0x58, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_PARAM_ERROR", (long) 0x59, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_NO_MEMORY", (long) 0x5a, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_CONNECT_ERROR", (long) 0x5b, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_NOT_SUPPORTED", (long) 0x5c, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_CONTROL_NOT_FOUND", (long) 0x5d, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_NO_RESULTS_RETURNED", (long) 0x5e, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_MORE_RESULTS_TO_RETURN", (long) 0x5f, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_CLIENT_LOOP", (long) 0x60, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_REFERRAL_LIMIT_EXCEEDED", (long) 0x61, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_MOD_ADD", (long) (0x0000), 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_MOD_DELETE", (long) (0x0001), 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_MOD_REPLACE", (long) (0x0002), 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_MOD_BVALUES", (long) (0x0080), 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_DEREF_NEVER", (long) 0x00, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_DEREF_SEARCHING", (long) 0x01, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_DEREF_FINDING", (long) 0x02, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_DEREF_ALWAYS", (long) 0x03, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_NO_LIMIT", (long) 0, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_MSG_ONE", (long) 0x00, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_MSG_ALL", (long) 0x01, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_MSG_RECEIVED", (long) 0x02, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_URL_SUCCESS", (long) 0x00, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_URL_ERR_MEM", (long) 0x01, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_URL_ERR_PARAM", (long) 0x02, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_URL_ERR_BADSCHEME", (long) 0x03, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_URL_ERR_BADENCLOSURE", (long) 0x04, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_URL_ERR_BADURL", (long) 0x05, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_URL_ERR_BADHOST", (long) 0x06, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_URL_ERR_BADATTRS", (long) 0x07, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_URL_ERR_BADSCOPE", (long) 0x08, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_URL_ERR_BADFILTER", (long) 0x09, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_URL_ERR_BADEXTS", (long) 0x0a, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_SASL_AUTOMATIC", (long) 0U, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_SASL_INTERACTIVE", (long) 1U, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_SASL_QUIET", (long) 2U, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_AVA_STRING", (long) 0x0000U, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_AVA_BINARY", (long) 0x0001U, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_AVA_NONPRINTABLE", (long) 0x0002U, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_DN_FORMAT_LDAP", (long) 0x0000U, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_DN_FORMAT_LDAPV3", (long) 0x0010U, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_DN_FORMAT_LDAPV2", (long) 0x0020U, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_DN_FORMAT_DCE", (long) 0x0030U, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_DN_FORMAT_UFN", (long) 0x0040U, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_DN_FORMAT_AD_CANONICAL", (long) 0x0050U, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_DN_FORMAT_LBER", (long) 0x00F0U, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_DN_FORMAT_MASK", (long) 0x00F0U, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_DN_PRETTY", (long) 0x0100U, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_DN_SKIP", (long) 0x0200U, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_DN_P_NOLEADTRAILSPACES", (long) 0x1000U, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_DN_P_NOSPACEAFTERRDN", (long) 0x2000U, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_DN_PEDANTIC", (long) 0xF000U, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LDAP_OPT_RESULT_CODE", (long) 0x0031, 0, 0, 0},
{0}
};
#ifdef __cplusplus
}
#endif
static swig_variable_info swig_variables[] = {
{0}
};
static swig_command_info swig_commands[] = {
{"OnLDAP::Basec::Client_sasl_bind", _wrap_Client_sasl_bind},
{"OnLDAP::Basec::Client_sasl_bind_s", _wrap_Client_sasl_bind_s},
{"OnLDAP::Basec::Client_parse_sasl_bind_result", _wrap_Client_parse_sasl_bind_result},
{"OnLDAP::Basec::Client_simple_bind", _wrap_Client_simple_bind},
{"OnLDAP::Basec::Client_simple_bind_s", _wrap_Client_simple_bind_s},
{"OnLDAP::Basec::new_Client", _wrap_new_Client},
{"OnLDAP::Basec::delete_Client", _wrap_delete_Client},
{"OnLDAP::Basec::Client__unbind", _wrap_Client__unbind},
{"OnLDAP::Basec::Client__get_option__bool", _wrap_Client__get_option__bool},
{"OnLDAP::Basec::Client__get_option__int", _wrap_Client__get_option__int},
{"OnLDAP::Basec::Client__get_option__string", _wrap_Client__get_option__string},
{"OnLDAP::Basec::Client__get_option__APIInfo", _wrap_Client__get_option__APIInfo},
{"OnLDAP::Basec::Client__get_option__APIFeatureInfo", _wrap_Client__get_option__APIFeatureInfo},
{"OnLDAP::Basec::Client__get_option__Controls", _wrap_Client__get_option__Controls},
{"OnLDAP::Basec::Client__set_option__bool", _wrap_Client__set_option__bool},
{"OnLDAP::Basec::Client__set_option__int", _wrap_Client__set_option__int},
{"OnLDAP::Basec::Client__set_option__string", _wrap_Client__set_option__string},
{"OnLDAP::Basec::Client__set_option__Controls", _wrap_Client__set_option__Controls},
{"OnLDAP::Basec::Client_first_message", _wrap_Client_first_message},
{"OnLDAP::Basec::Client_next_message", _wrap_Client_next_message},
{"OnLDAP::Basec::Client_count_messages", _wrap_Client_count_messages},
{"OnLDAP::Basec::Client_first_reference", _wrap_Client_first_reference},
{"OnLDAP::Basec::Client_next_reference", _wrap_Client_next_reference},
{"OnLDAP::Basec::Client_count_references", _wrap_Client_count_references},
{"OnLDAP::Basec::Client_ldap_parse_reference", _wrap_Client_ldap_parse_reference},
{"OnLDAP::Basec::Client_first_entry", _wrap_Client_first_entry},
{"OnLDAP::Basec::Client_next_entry", _wrap_Client_next_entry},
{"OnLDAP::Basec::Client_count_entries", _wrap_Client_count_entries},
{"OnLDAP::Basec::Client_get_entry_controls", _wrap_Client_get_entry_controls},
{"OnLDAP::Basec::Client_result", _wrap_Client_result},
{"OnLDAP::Basec::Client_search", _wrap_Client_search},
{"OnLDAP::Basec::Client_search_s", _wrap_Client_search_s},
{"OnLDAP::Basec::Client_parse_result", _wrap_Client_parse_result},
{"OnLDAP::Basec::Client_extended_operation", _wrap_Client_extended_operation},
{"OnLDAP::Basec::Client_extended_operation_s", _wrap_Client_extended_operation_s},
{"OnLDAP::Basec::Client_parse_extended_result", _wrap_Client_parse_extended_result},
{"OnLDAP::Basec::Client_parse_extended_partial", _wrap_Client_parse_extended_partial},
{"OnLDAP::Basec::Client_parse_intermediate_resp_result", _wrap_Client_parse_intermediate_resp_result},
{"OnLDAP::Basec::Client_abandon", _wrap_Client_abandon},
{"OnLDAP::Basec::Client_add", _wrap_Client_add},
{"OnLDAP::Basec::Client_add_s", _wrap_Client_add_s},
{"OnLDAP::Basec::Client_ldap_cancel", _wrap_Client_ldap_cancel},
{"OnLDAP::Basec::Client_ldap_cancel_s", _wrap_Client_ldap_cancel_s},
{"OnLDAP::Basec::Client_compare", _wrap_Client_compare},
{"OnLDAP::Basec::Client_compare_s", _wrap_Client_compare_s},
{"OnLDAP::Basec::Client_delete", _wrap_Client_delete},
{"OnLDAP::Basec::Client_delete_s", _wrap_Client_delete_s},
{"OnLDAP::Basec::Client_modify", _wrap_Client_modify},
{"OnLDAP::Basec::Client_modify_s", _wrap_Client_modify_s},
{"OnLDAP::Basec::Client_rename", _wrap_Client_rename},
{"OnLDAP::Basec::Client_rename_s", _wrap_Client_rename_s},
{"OnLDAP::Basec::Client_get_dn", _wrap_Client_get_dn},
{"OnLDAP::Basec::new_Message", _wrap_new_Message},
{"OnLDAP::Basec::delete_Message", _wrap_delete_Message},
{"OnLDAP::Basec::Message_type", _wrap_Message_type},
{"OnLDAP::Basec::Message_id", _wrap_Message_id},
{"OnLDAP::Basec::BerValue_bv_len_set", _wrap_BerValue_bv_len_set},
{"OnLDAP::Basec::BerValue_bv_len_get", _wrap_BerValue_bv_len_get},
{"OnLDAP::Basec::BerValue_bv_val_set", _wrap_BerValue_bv_val_set},
{"OnLDAP::Basec::BerValue_bv_val_get", _wrap_BerValue_bv_val_get},
{"OnLDAP::Basec::BerValue_lenght", _wrap_BerValue_lenght},
{"OnLDAP::Basec::BerValue_string", _wrap_BerValue_string},
{"OnLDAP::Basec::delete_BerValue", _wrap_delete_BerValue},
{"OnLDAP::Basec::new_BerValue", _wrap_new_BerValue},
{"OnLDAP::Basec::ber_error_print", _wrap_ber_error_print},
{"OnLDAP::Basec::ber_bprint", _wrap_ber_bprint},
{"OnLDAP::Basec::ber_dump", _wrap_ber_dump},
{"OnLDAP::Basec::ber_sos_dump", _wrap_ber_sos_dump},
{"OnLDAP::Basec::ber_get_tag", _wrap_ber_get_tag},
{"OnLDAP::Basec::ber_skip_tag", _wrap_ber_skip_tag},
{"OnLDAP::Basec::ber_peek_tag", _wrap_ber_peek_tag},
{"OnLDAP::Basec::ber_get_int", _wrap_ber_get_int},
{"OnLDAP::Basec::ber_get_enum", _wrap_ber_get_enum},
{"OnLDAP::Basec::ber_get_stringb", _wrap_ber_get_stringb},
{"OnLDAP::Basec::ber_get_stringbv", _wrap_ber_get_stringbv},
{"OnLDAP::Basec::ber_get_stringa", _wrap_ber_get_stringa},
{"OnLDAP::Basec::ber_get_stringal", _wrap_ber_get_stringal},
{"OnLDAP::Basec::ber_get_bitstringa", _wrap_ber_get_bitstringa},
{"OnLDAP::Basec::ber_get_null", _wrap_ber_get_null},
{"OnLDAP::Basec::ber_get_boolean", _wrap_ber_get_boolean},
{"OnLDAP::Basec::ber_first_element", _wrap_ber_first_element},
{"OnLDAP::Basec::ber_next_element", _wrap_ber_next_element},
{"OnLDAP::Basec::ber_scanf", _wrap_ber_scanf},
{"OnLDAP::Basec::ber_put_enum", _wrap_ber_put_enum},
{"OnLDAP::Basec::ber_put_int", _wrap_ber_put_int},
{"OnLDAP::Basec::ber_put_ostring", _wrap_ber_put_ostring},
{"OnLDAP::Basec::ber_put_berval", _wrap_ber_put_berval},
{"OnLDAP::Basec::ber_put_string", _wrap_ber_put_string},
{"OnLDAP::Basec::ber_put_bitstring", _wrap_ber_put_bitstring},
{"OnLDAP::Basec::ber_put_null", _wrap_ber_put_null},
{"OnLDAP::Basec::ber_put_boolean", _wrap_ber_put_boolean},
{"OnLDAP::Basec::ber_start_seq", _wrap_ber_start_seq},
{"OnLDAP::Basec::ber_start_set", _wrap_ber_start_set},
{"OnLDAP::Basec::ber_put_seq", _wrap_ber_put_seq},
{"OnLDAP::Basec::ber_put_set", _wrap_ber_put_set},
{"OnLDAP::Basec::ber_printf", _wrap_ber_printf},
{"OnLDAP::Basec::ber_read", _wrap_ber_read},
{"OnLDAP::Basec::ber_write", _wrap_ber_write},
{"OnLDAP::Basec::ber_free", _wrap_ber_free},
{"OnLDAP::Basec::ber_free_buf", _wrap_ber_free_buf},
{"OnLDAP::Basec::ber_flush", _wrap_ber_flush},
{"OnLDAP::Basec::ber_alloc", _wrap_ber_alloc},
{"OnLDAP::Basec::der_alloc", _wrap_der_alloc},
{"OnLDAP::Basec::ber_alloc_t", _wrap_ber_alloc_t},
{"OnLDAP::Basec::ber_dup", _wrap_ber_dup},
{"OnLDAP::Basec::ber_get_next", _wrap_ber_get_next},
{"OnLDAP::Basec::ber_init2", _wrap_ber_init2},
{"OnLDAP::Basec::ber_init_w_nullc", _wrap_ber_init_w_nullc},
{"OnLDAP::Basec::ber_reset", _wrap_ber_reset},
{"OnLDAP::Basec::ber_init", _wrap_ber_init},
{"OnLDAP::Basec::ber_flatten", _wrap_ber_flatten},
{"OnLDAP::Basec::ber_flatten2", _wrap_ber_flatten2},
{"OnLDAP::Basec::ber_get_option", _wrap_ber_get_option},
{"OnLDAP::Basec::ber_set_option", _wrap_ber_set_option},
{"OnLDAP::Basec::ber_sockbuf_alloc", _wrap_ber_sockbuf_alloc},
{"OnLDAP::Basec::ber_sockbuf_free", _wrap_ber_sockbuf_free},
{"OnLDAP::Basec::ber_sockbuf_add_io", _wrap_ber_sockbuf_add_io},
{"OnLDAP::Basec::ber_sockbuf_remove_io", _wrap_ber_sockbuf_remove_io},
{"OnLDAP::Basec::ber_sockbuf_ctrl", _wrap_ber_sockbuf_ctrl},
{"OnLDAP::Basec::ber_bvarray_add", _wrap_ber_bvarray_add},
{"OnLDAP::Basec::ber_errno_addr", _wrap_ber_errno_addr},
{"OnLDAP::Basec::APIInfo_ldapai_info_version_set", _wrap_APIInfo_ldapai_info_version_set},
{"OnLDAP::Basec::APIInfo_ldapai_info_version_get", _wrap_APIInfo_ldapai_info_version_get},
{"OnLDAP::Basec::APIInfo_ldapai_api_version_set", _wrap_APIInfo_ldapai_api_version_set},
{"OnLDAP::Basec::APIInfo_ldapai_api_version_get", _wrap_APIInfo_ldapai_api_version_get},
{"OnLDAP::Basec::APIInfo_ldapai_protocol_version_set", _wrap_APIInfo_ldapai_protocol_version_set},
{"OnLDAP::Basec::APIInfo_ldapai_protocol_version_get", _wrap_APIInfo_ldapai_protocol_version_get},
{"OnLDAP::Basec::APIInfo_ldapai_extensions_set", _wrap_APIInfo_ldapai_extensions_set},
{"OnLDAP::Basec::APIInfo_ldapai_extensions_get", _wrap_APIInfo_ldapai_extensions_get},
{"OnLDAP::Basec::APIInfo_ldapai_vendor_name_set", _wrap_APIInfo_ldapai_vendor_name_set},
{"OnLDAP::Basec::APIInfo_ldapai_vendor_name_get", _wrap_APIInfo_ldapai_vendor_name_get},
{"OnLDAP::Basec::APIInfo_ldapai_vendor_version_set", _wrap_APIInfo_ldapai_vendor_version_set},
{"OnLDAP::Basec::APIInfo_ldapai_vendor_version_get", _wrap_APIInfo_ldapai_vendor_version_get},
{"OnLDAP::Basec::APIInfo_info_version", _wrap_APIInfo_info_version},
{"OnLDAP::Basec::APIInfo_api_version", _wrap_APIInfo_api_version},
{"OnLDAP::Basec::APIInfo_protocol_version", _wrap_APIInfo_protocol_version},
{"OnLDAP::Basec::APIInfo_extensions", _wrap_APIInfo_extensions},
{"OnLDAP::Basec::APIInfo_vendor_name", _wrap_APIInfo_vendor_name},
{"OnLDAP::Basec::APIInfo_vendor_version", _wrap_APIInfo_vendor_version},
{"OnLDAP::Basec::new_APIInfo", _wrap_new_APIInfo},
{"OnLDAP::Basec::delete_APIInfo", _wrap_delete_APIInfo},
{"OnLDAP::Basec::APIFeatureInfo_ldapaif_info_version_set", _wrap_APIFeatureInfo_ldapaif_info_version_set},
{"OnLDAP::Basec::APIFeatureInfo_ldapaif_info_version_get", _wrap_APIFeatureInfo_ldapaif_info_version_get},
{"OnLDAP::Basec::APIFeatureInfo_ldapaif_name_set", _wrap_APIFeatureInfo_ldapaif_name_set},
{"OnLDAP::Basec::APIFeatureInfo_ldapaif_name_get", _wrap_APIFeatureInfo_ldapaif_name_get},
{"OnLDAP::Basec::APIFeatureInfo_ldapaif_version_set", _wrap_APIFeatureInfo_ldapaif_version_set},
{"OnLDAP::Basec::APIFeatureInfo_ldapaif_version_get", _wrap_APIFeatureInfo_ldapaif_version_get},
{"OnLDAP::Basec::APIFeatureInfo_info_version", _wrap_APIFeatureInfo_info_version},
{"OnLDAP::Basec::APIFeatureInfo_name", _wrap_APIFeatureInfo_name},
{"OnLDAP::Basec::APIFeatureInfo_version", _wrap_APIFeatureInfo_version},
{"OnLDAP::Basec::delete_APIFeatureInfo", _wrap_delete_APIFeatureInfo},
{"OnLDAP::Basec::new_APIFeatureInfo", _wrap_new_APIFeatureInfo},
{"OnLDAP::Basec::new_Control", _wrap_new_Control},
{"OnLDAP::Basec::delete_Control", _wrap_delete_Control},
{"OnLDAP::Basec::Control_oid", _wrap_Control_oid},
{"OnLDAP::Basec::Control_value", _wrap_Control_value},
{"OnLDAP::Basec::Control_critical", _wrap_Control_critical},
{"OnLDAP::Basec::new_Mod", _wrap_new_Mod},
{"OnLDAP::Basec::delete_Mod", _wrap_delete_Mod},
{"OnLDAP::Basec::Mod_op", _wrap_Mod_op},
{"OnLDAP::Basec::Mod_type", _wrap_Mod_type},
{"OnLDAP::Basec::Mod_values", _wrap_Mod_values},
{"OnLDAP::Basec::LDAPMod_mod_vals_modv_strvals_set", _wrap_LDAPMod_mod_vals_modv_strvals_set},
{"OnLDAP::Basec::LDAPMod_mod_vals_modv_strvals_get", _wrap_LDAPMod_mod_vals_modv_strvals_get},
{"OnLDAP::Basec::LDAPMod_mod_vals_modv_bvals_set", _wrap_LDAPMod_mod_vals_modv_bvals_set},
{"OnLDAP::Basec::LDAPMod_mod_vals_modv_bvals_get", _wrap_LDAPMod_mod_vals_modv_bvals_get},
{"OnLDAP::Basec::new_LDAPMod_mod_vals", _wrap_new_LDAPMod_mod_vals},
{"OnLDAP::Basec::delete_LDAPMod_mod_vals", _wrap_delete_LDAPMod_mod_vals},
{"OnLDAP::Basec::URLDesc_lud_next_set", _wrap_URLDesc_lud_next_set},
{"OnLDAP::Basec::URLDesc_lud_next_get", _wrap_URLDesc_lud_next_get},
{"OnLDAP::Basec::URLDesc_lud_scheme_set", _wrap_URLDesc_lud_scheme_set},
{"OnLDAP::Basec::URLDesc_lud_scheme_get", _wrap_URLDesc_lud_scheme_get},
{"OnLDAP::Basec::URLDesc_lud_host_set", _wrap_URLDesc_lud_host_set},
{"OnLDAP::Basec::URLDesc_lud_host_get", _wrap_URLDesc_lud_host_get},
{"OnLDAP::Basec::URLDesc_lud_port_set", _wrap_URLDesc_lud_port_set},
{"OnLDAP::Basec::URLDesc_lud_port_get", _wrap_URLDesc_lud_port_get},
{"OnLDAP::Basec::URLDesc_lud_dn_set", _wrap_URLDesc_lud_dn_set},
{"OnLDAP::Basec::URLDesc_lud_dn_get", _wrap_URLDesc_lud_dn_get},
{"OnLDAP::Basec::URLDesc_lud_attrs_set", _wrap_URLDesc_lud_attrs_set},
{"OnLDAP::Basec::URLDesc_lud_attrs_get", _wrap_URLDesc_lud_attrs_get},
{"OnLDAP::Basec::URLDesc_lud_scope_set", _wrap_URLDesc_lud_scope_set},
{"OnLDAP::Basec::URLDesc_lud_scope_get", _wrap_URLDesc_lud_scope_get},
{"OnLDAP::Basec::URLDesc_lud_filter_set", _wrap_URLDesc_lud_filter_set},
{"OnLDAP::Basec::URLDesc_lud_filter_get", _wrap_URLDesc_lud_filter_get},
{"OnLDAP::Basec::URLDesc_lud_exts_set", _wrap_URLDesc_lud_exts_set},
{"OnLDAP::Basec::URLDesc_lud_exts_get", _wrap_URLDesc_lud_exts_get},
{"OnLDAP::Basec::URLDesc_lud_crit_exts_set", _wrap_URLDesc_lud_crit_exts_set},
{"OnLDAP::Basec::URLDesc_lud_crit_exts_get", _wrap_URLDesc_lud_crit_exts_get},
{"OnLDAP::Basec::new_URLDesc", _wrap_new_URLDesc},
{"OnLDAP::Basec::delete_URLDesc", _wrap_delete_URLDesc},
{"OnLDAP::Basec::ldap_set_rebind_proc", _wrap_ldap_set_rebind_proc},
{"OnLDAP::Basec::ldap_domain2dn", _wrap_ldap_domain2dn},
{"OnLDAP::Basec::ldap_dn2domain", _wrap_ldap_dn2domain},
{"OnLDAP::Basec::ldap_domain2hostlist", _wrap_ldap_domain2hostlist},
{"OnLDAP::Basec::ldap_extended_operation", _wrap_ldap_extended_operation},
{"OnLDAP::Basec::ldap_extended_operation_s", _wrap_ldap_extended_operation_s},
{"OnLDAP::Basec::ldap_parse_extended_result", _wrap_ldap_parse_extended_result},
{"OnLDAP::Basec::ldap_parse_extended_partial", _wrap_ldap_parse_extended_partial},
{"OnLDAP::Basec::ldap_parse_intermediate_resp_result", _wrap_ldap_parse_intermediate_resp_result},
{"OnLDAP::Basec::ldap_abandon_ext", _wrap_ldap_abandon_ext},
{"OnLDAP::Basec::ldap_abandon", _wrap_ldap_abandon},
{"OnLDAP::Basec::ldap_add_ext", _wrap_ldap_add_ext},
{"OnLDAP::Basec::ldap_add_ext_s", _wrap_ldap_add_ext_s},
{"OnLDAP::Basec::ldap_add", _wrap_ldap_add},
{"OnLDAP::Basec::ldap_add_s", _wrap_ldap_add_s},
{"OnLDAP::Basec::ldap_sasl_interactive_bind_s", _wrap_ldap_sasl_interactive_bind_s},
{"OnLDAP::Basec::ldap_bind", _wrap_ldap_bind},
{"OnLDAP::Basec::ldap_bind_s", _wrap_ldap_bind_s},
{"OnLDAP::Basec::ldap_kerberos_bind_s", _wrap_ldap_kerberos_bind_s},
{"OnLDAP::Basec::ldap_kerberos_bind1", _wrap_ldap_kerberos_bind1},
{"OnLDAP::Basec::ldap_kerberos_bind1_s", _wrap_ldap_kerberos_bind1_s},
{"OnLDAP::Basec::ldap_kerberos_bind2", _wrap_ldap_kerberos_bind2},
{"OnLDAP::Basec::ldap_kerberos_bind2_s", _wrap_ldap_kerberos_bind2_s},
{"OnLDAP::Basec::ldap_cancel", _wrap_ldap_cancel},
{"OnLDAP::Basec::ldap_cancel_s", _wrap_ldap_cancel_s},
{"OnLDAP::Basec::ldap_compare_ext", _wrap_ldap_compare_ext},
{"OnLDAP::Basec::ldap_compare_ext_s", _wrap_ldap_compare_ext_s},
{"OnLDAP::Basec::ldap_compare", _wrap_ldap_compare},
{"OnLDAP::Basec::ldap_compare_s", _wrap_ldap_compare_s},
{"OnLDAP::Basec::ldap_delete_ext", _wrap_ldap_delete_ext},
{"OnLDAP::Basec::ldap_delete_ext_s", _wrap_ldap_delete_ext_s},
{"OnLDAP::Basec::ldap_delete", _wrap_ldap_delete},
{"OnLDAP::Basec::ldap_delete_s", _wrap_ldap_delete_s},
{"OnLDAP::Basec::ldap_err2string", _wrap_ldap_err2string},
{"OnLDAP::Basec::ldap_result2error", _wrap_ldap_result2error},
{"OnLDAP::Basec::ldap_perror", _wrap_ldap_perror},
{"OnLDAP::Basec::ldap_modify_ext", _wrap_ldap_modify_ext},
{"OnLDAP::Basec::ldap_modify_ext_s", _wrap_ldap_modify_ext_s},
{"OnLDAP::Basec::ldap_modify", _wrap_ldap_modify},
{"OnLDAP::Basec::ldap_modify_s", _wrap_ldap_modify_s},
{"OnLDAP::Basec::ldap_rename", _wrap_ldap_rename},
{"OnLDAP::Basec::ldap_rename_s", _wrap_ldap_rename_s},
{"OnLDAP::Basec::ldap_rename2", _wrap_ldap_rename2},
{"OnLDAP::Basec::ldap_rename2_s", _wrap_ldap_rename2_s},
{"OnLDAP::Basec::ldap_modrdn", _wrap_ldap_modrdn},
{"OnLDAP::Basec::ldap_modrdn_s", _wrap_ldap_modrdn_s},
{"OnLDAP::Basec::ldap_modrdn2", _wrap_ldap_modrdn2},
{"OnLDAP::Basec::ldap_modrdn2_s", _wrap_ldap_modrdn2_s},
{"OnLDAP::Basec::ldap_open", _wrap_ldap_open},
{"OnLDAP::Basec::ldap_create", _wrap_ldap_create},
{"OnLDAP::Basec::ldap_initialize", _wrap_ldap_initialize},
{"OnLDAP::Basec::ldap_start_tls_s", _wrap_ldap_start_tls_s},
{"OnLDAP::Basec::ldap_parse_reference", _wrap_ldap_parse_reference},
{"OnLDAP::Basec::ldap_get_entry_controls", _wrap_ldap_get_entry_controls},
{"OnLDAP::Basec::ldap_delete_result_entry", _wrap_ldap_delete_result_entry},
{"OnLDAP::Basec::ldap_add_result_entry", _wrap_ldap_add_result_entry},
{"OnLDAP::Basec::ldap_get_dn", _wrap_ldap_get_dn},
{"OnLDAP::Basec::AVA_la_attr_set", _wrap_AVA_la_attr_set},
{"OnLDAP::Basec::AVA_la_attr_get", _wrap_AVA_la_attr_get},
{"OnLDAP::Basec::AVA_la_value_set", _wrap_AVA_la_value_set},
{"OnLDAP::Basec::AVA_la_value_get", _wrap_AVA_la_value_get},
{"OnLDAP::Basec::AVA_la_flags_set", _wrap_AVA_la_flags_set},
{"OnLDAP::Basec::AVA_la_flags_get", _wrap_AVA_la_flags_get},
{"OnLDAP::Basec::AVA_la_private_set", _wrap_AVA_la_private_set},
{"OnLDAP::Basec::AVA_la_private_get", _wrap_AVA_la_private_get},
{"OnLDAP::Basec::new_AVA", _wrap_new_AVA},
{"OnLDAP::Basec::delete_AVA", _wrap_delete_AVA},
{"OnLDAP::Basec::ldap_avafree", _wrap_ldap_avafree},
{"OnLDAP::Basec::ldap_rdnfree", _wrap_ldap_rdnfree},
{"OnLDAP::Basec::ldap_dnfree", _wrap_ldap_dnfree},
{"OnLDAP::Basec::ldap_bv2dn", _wrap_ldap_bv2dn},
{"OnLDAP::Basec::ldap_str2dn", _wrap_ldap_str2dn},
{"OnLDAP::Basec::ldap_dn2bv", _wrap_ldap_dn2bv},
{"OnLDAP::Basec::ldap_dn2str", _wrap_ldap_dn2str},
{"OnLDAP::Basec::ldap_bv2rdn", _wrap_ldap_bv2rdn},
{"OnLDAP::Basec::ldap_str2rdn", _wrap_ldap_str2rdn},
{"OnLDAP::Basec::ldap_rdn2bv", _wrap_ldap_rdn2bv},
{"OnLDAP::Basec::ldap_rdn2str", _wrap_ldap_rdn2str},
{"OnLDAP::Basec::ldap_dn_normalize", _wrap_ldap_dn_normalize},
{"OnLDAP::Basec::ldap_dn2ufn", _wrap_ldap_dn2ufn},
{"OnLDAP::Basec::ldap_explode_dn", _wrap_ldap_explode_dn},
{"OnLDAP::Basec::ldap_explode_rdn", _wrap_ldap_explode_rdn},
{"OnLDAP::Basec::ldap_X509dn2bv", _wrap_ldap_X509dn2bv},
{"OnLDAP::Basec::ldap_dn2dcedn", _wrap_ldap_dn2dcedn},
{"OnLDAP::Basec::ldap_dcedn2dn", _wrap_ldap_dcedn2dn},
{"OnLDAP::Basec::ldap_dn2ad_canonical", _wrap_ldap_dn2ad_canonical},
{"OnLDAP::Basec::ldap_get_dn_ber", _wrap_ldap_get_dn_ber},
{"OnLDAP::Basec::ldap_get_attribute_ber", _wrap_ldap_get_attribute_ber},
{"OnLDAP::Basec::ldap_first_attribute", _wrap_ldap_first_attribute},
{"OnLDAP::Basec::ldap_next_attribute", _wrap_ldap_next_attribute},
{"OnLDAP::Basec::ldap_get_values_len", _wrap_ldap_get_values_len},
{"OnLDAP::Basec::ldap_count_values_len", _wrap_ldap_count_values_len},
{"OnLDAP::Basec::ldap_value_free_len", _wrap_ldap_value_free_len},
{"OnLDAP::Basec::ldap_get_values", _wrap_ldap_get_values},
{"OnLDAP::Basec::ldap_count_values", _wrap_ldap_count_values},
{"OnLDAP::Basec::ldap_value_free", _wrap_ldap_value_free},
{"OnLDAP::Basec::ldap_msgtype", _wrap_ldap_msgtype},
{"OnLDAP::Basec::ldap_msgid", _wrap_ldap_msgid},
{"OnLDAP::Basec::ldap_msgfree", _wrap_ldap_msgfree},
{"OnLDAP::Basec::ldap_msgdelete", _wrap_ldap_msgdelete},
{"OnLDAP::Basec::ldap_unbind", _wrap_ldap_unbind},
{"OnLDAP::Basec::ldap_unbind_s", _wrap_ldap_unbind_s},
{"OnLDAP::Basec::ldap_unbind_ext", _wrap_ldap_unbind_ext},
{"OnLDAP::Basec::ldap_unbind_ext_s", _wrap_ldap_unbind_ext_s},
{"OnLDAP::Basec::ldap_put_vrFilter", _wrap_ldap_put_vrFilter},
{"OnLDAP::Basec::ldap_memalloc", _wrap_ldap_memalloc},
{"OnLDAP::Basec::ldap_memrealloc", _wrap_ldap_memrealloc},
{"OnLDAP::Basec::ldap_memcalloc", _wrap_ldap_memcalloc},
{"OnLDAP::Basec::ldap_memfree", _wrap_ldap_memfree},
{"OnLDAP::Basec::ldap_memvfree", _wrap_ldap_memvfree},
{"OnLDAP::Basec::ldap_strdup", _wrap_ldap_strdup},
{"OnLDAP::Basec::ldap_mods_free", _wrap_ldap_mods_free},
{"OnLDAP::Basec::ldap_sort_entries", _wrap_ldap_sort_entries},
{"OnLDAP::Basec::ldap_sort_values", _wrap_ldap_sort_values},
{"OnLDAP::Basec::ldap_sort_strcasecmp", _wrap_ldap_sort_strcasecmp},
{"OnLDAP::Basec::ldap_is_ldap_url", _wrap_ldap_is_ldap_url},
{"OnLDAP::Basec::ldap_is_ldaps_url", _wrap_ldap_is_ldaps_url},
{"OnLDAP::Basec::ldap_is_ldapi_url", _wrap_ldap_is_ldapi_url},
{"OnLDAP::Basec::ldap_url_parse", _wrap_ldap_url_parse},
{"OnLDAP::Basec::ldap_url_desc2str", _wrap_ldap_url_desc2str},
{"OnLDAP::Basec::ldap_free_urldesc", _wrap_ldap_free_urldesc},
{"OnLDAP::Basec::LDAPSortKey_attributeType_set", _wrap_LDAPSortKey_attributeType_set},
{"OnLDAP::Basec::LDAPSortKey_attributeType_get", _wrap_LDAPSortKey_attributeType_get},
{"OnLDAP::Basec::LDAPSortKey_orderingRule_set", _wrap_LDAPSortKey_orderingRule_set},
{"OnLDAP::Basec::LDAPSortKey_orderingRule_get", _wrap_LDAPSortKey_orderingRule_get},
{"OnLDAP::Basec::LDAPSortKey_reverseOrder_set", _wrap_LDAPSortKey_reverseOrder_set},
{"OnLDAP::Basec::LDAPSortKey_reverseOrder_get", _wrap_LDAPSortKey_reverseOrder_get},
{"OnLDAP::Basec::new_LDAPSortKey", _wrap_new_LDAPSortKey},
{"OnLDAP::Basec::delete_LDAPSortKey", _wrap_delete_LDAPSortKey},
{"OnLDAP::Basec::ldap_create_sort_keylist", _wrap_ldap_create_sort_keylist},
{"OnLDAP::Basec::ldap_free_sort_keylist", _wrap_ldap_free_sort_keylist},
{"OnLDAP::Basec::ldap_create_sort_control", _wrap_ldap_create_sort_control},
{"OnLDAP::Basec::ldap_parse_sort_control", _wrap_ldap_parse_sort_control},
{"OnLDAP::Basec::LDAPVLVInfo_ldvlv_version_set", _wrap_LDAPVLVInfo_ldvlv_version_set},
{"OnLDAP::Basec::LDAPVLVInfo_ldvlv_version_get", _wrap_LDAPVLVInfo_ldvlv_version_get},
{"OnLDAP::Basec::LDAPVLVInfo_ldvlv_before_count_set", _wrap_LDAPVLVInfo_ldvlv_before_count_set},
{"OnLDAP::Basec::LDAPVLVInfo_ldvlv_before_count_get", _wrap_LDAPVLVInfo_ldvlv_before_count_get},
{"OnLDAP::Basec::LDAPVLVInfo_ldvlv_after_count_set", _wrap_LDAPVLVInfo_ldvlv_after_count_set},
{"OnLDAP::Basec::LDAPVLVInfo_ldvlv_after_count_get", _wrap_LDAPVLVInfo_ldvlv_after_count_get},
{"OnLDAP::Basec::LDAPVLVInfo_ldvlv_offset_set", _wrap_LDAPVLVInfo_ldvlv_offset_set},
{"OnLDAP::Basec::LDAPVLVInfo_ldvlv_offset_get", _wrap_LDAPVLVInfo_ldvlv_offset_get},
{"OnLDAP::Basec::LDAPVLVInfo_ldvlv_count_set", _wrap_LDAPVLVInfo_ldvlv_count_set},
{"OnLDAP::Basec::LDAPVLVInfo_ldvlv_count_get", _wrap_LDAPVLVInfo_ldvlv_count_get},
{"OnLDAP::Basec::LDAPVLVInfo_ldvlv_attrvalue_set", _wrap_LDAPVLVInfo_ldvlv_attrvalue_set},
{"OnLDAP::Basec::LDAPVLVInfo_ldvlv_attrvalue_get", _wrap_LDAPVLVInfo_ldvlv_attrvalue_get},
{"OnLDAP::Basec::LDAPVLVInfo_ldvlv_context_set", _wrap_LDAPVLVInfo_ldvlv_context_set},
{"OnLDAP::Basec::LDAPVLVInfo_ldvlv_context_get", _wrap_LDAPVLVInfo_ldvlv_context_get},
{"OnLDAP::Basec::LDAPVLVInfo_ldvlv_extradata_set", _wrap_LDAPVLVInfo_ldvlv_extradata_set},
{"OnLDAP::Basec::LDAPVLVInfo_ldvlv_extradata_get", _wrap_LDAPVLVInfo_ldvlv_extradata_get},
{"OnLDAP::Basec::new_LDAPVLVInfo", _wrap_new_LDAPVLVInfo},
{"OnLDAP::Basec::delete_LDAPVLVInfo", _wrap_delete_LDAPVLVInfo},
{"OnLDAP::Basec::ldap_create_vlv_control", _wrap_ldap_create_vlv_control},
{"OnLDAP::Basec::ldap_parse_vlv_control", _wrap_ldap_parse_vlv_control},
{"OnLDAP::Basec::ldap_parse_whoami", _wrap_ldap_parse_whoami},
{"OnLDAP::Basec::ldap_whoami", _wrap_ldap_whoami},
{"OnLDAP::Basec::ldap_whoami_s", _wrap_ldap_whoami_s},
{"OnLDAP::Basec::ldap_parse_passwd", _wrap_ldap_parse_passwd},
{"OnLDAP::Basec::ldap_passwd", _wrap_ldap_passwd},
{"OnLDAP::Basec::ldap_passwd_s", _wrap_ldap_passwd_s},
{0,0}
};

#ifdef __cplusplus
extern "C"
#endif

XS(SWIG_init) {
    dXSARGS;
    int i;
    static int _init = 0;
    if (!_init) {
        for (i = 0; swig_types_initial[i]; i++) {
            swig_types[i] = SWIG_TypeRegister(swig_types_initial[i]);
        }	
        _init = 1;
    }
    
    /* Install commands */
    for (i = 0; swig_commands[i].name; i++) {
        newXS((char*) swig_commands[i].name,swig_commands[i].wrapper, (char*)__FILE__);
    }
    
    /* Install variables */
    for (i = 0; swig_variables[i].name; i++) {
        SV *sv;
        sv = perl_get_sv((char*) swig_variables[i].name, TRUE | 0x2);
        if (swig_variables[i].type) {
            SWIG_MakePtr(sv,(void *)1, *swig_variables[i].type,0);
        } else {
            sv_setiv(sv,(IV) 0);
        }
        swig_create_magic(sv, (char *) swig_variables[i].name, swig_variables[i].set, swig_variables[i].get); 
    }
    
    /* Install constant */
    for (i = 0; swig_constants[i].type; i++) {
        SV *sv;
        sv = perl_get_sv((char*)swig_constants[i].name, TRUE | 0x2);
        switch(swig_constants[i].type) {
            case SWIG_INT:
            sv_setiv(sv, (IV) swig_constants[i].lvalue);
            break;
            case SWIG_FLOAT:
            sv_setnv(sv, (double) swig_constants[i].dvalue);
            break;
            case SWIG_STRING:
            sv_setpv(sv, (char *) swig_constants[i].pvalue);
            break;
            case SWIG_POINTER:
            SWIG_MakePtr(sv, swig_constants[i].pvalue, *(swig_constants[i].ptype),0);
            break;
            case SWIG_BINARY:
            /*      obj = SWIG_NewPackedObj(swig_constants[i].pvalue, swig_constants[i].lvalue, *(swig_constants[i].ptype)); */
            break;
            default:
            break;
        }
        SvREADONLY_on(sv);
    }
    
    SWIG_TypeClientData(SWIGTYPE_p_ldap, (void*) "OnLDAP::Base::Client");
    SWIG_TypeClientData(SWIGTYPE_p_ldapmsg, (void*) "OnLDAP::Base::Message");
    SWIG_TypeClientData(SWIGTYPE_p_BerValue, (void*) "OnLDAP::Base::BerValue");
    SWIG_TypeClientData(SWIGTYPE_p_LDAPAPIInfo, (void*) "OnLDAP::Base::APIInfo");
    SWIG_TypeClientData(SWIGTYPE_p_LDAPAPIFeatureInfo, (void*) "OnLDAP::Base::APIFeatureInfo");
    SWIG_TypeClientData(SWIGTYPE_p_LDAPControl, (void*) "OnLDAP::Base::Control");
    SWIG_TypeClientData(SWIGTYPE_p_LDAPMod, (void*) "OnLDAP::Base::Mod");
    SWIG_TypeClientData(SWIGTYPE_p_LDAPMod_mod_vals, (void*) "OnLDAP::Base::LDAPMod_mod_vals");
    SWIG_TypeClientData(SWIGTYPE_p_LDAPURLDesc, (void*) "OnLDAP::Base::URLDesc");
    SWIG_TypeClientData(SWIGTYPE_p_LDAPAVA, (void*) "OnLDAP::Base::AVA");
    SWIG_TypeClientData(SWIGTYPE_p_LDAPSortKey, (void*) "OnLDAP::Base::LDAPSortKey");
    SWIG_TypeClientData(SWIGTYPE_p_LDAPVLVInfo, (void*) "OnLDAP::Base::LDAPVLVInfo");
    ST(0) = &PL_sv_yes;
    XSRETURN(1);
}

